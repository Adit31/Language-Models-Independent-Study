the value .
a new Observable < T > .
< T > sorted ( Comparator < ? super T > sortFunction ) { ObjectHelper . requireNonNull ( sortFunction , " sortFunction is null " ) ; return toList ( ) . toObservable ( ) . map ( Functions . listSorter ( sortFunction ) ) . flatMapIterable ( Functions . < List < T > > identity ( ) ) ; }
< T > observeOn ( final ConnectableObservable < T > co , final Scheduler scheduler ) { final Observable < T > observable = co . observeOn ( scheduler ) ; return RxJavaPlugins . onAssembly ( observable ) ; }
static < T > UnicastProcessor < T > create ( int capacityHint ) { return new UnicastProcessor < T > ( capacityHint ) ; }
static < T > UnicastProcessor < T > create ( int capacityHint , Runnable onCancelled ) { ObjectHelper . requireNonNull ( onCancelled , " onTerminate " );NEWLINE return new UnicastProcessor<T>(capacityHint , onCancelled);NEWLINE }
( Publisher < T > source , Subscriber < ? super R > subscriber , Function < ? super T , ? extends Publisher < ? extends R > > mapper ) { subscriber . onSubscribe ( new ScalarSubscription < T > ( subscriber , mapper . apply ( source ) ) ) ; return true ; }
< T , U > scalarXMap ( final T value , final Function < ? super T , ? extends Publisher < ? extends U > > mapper ) { return RxJavaPlugins . onAssembly ( new ScalarXMapFlowable < T , U > ( value , mapper ) ) ; }
the scheduler handler .
a Maybe < T > from completable source .
a Maybe < T > from a single source .
retry ( long times , Predicate < ? super Throwable > predicate ) { return toFlowable ( ) . retry ( times , predicate ) ; }
that the object is not null .
< T , T > identity ( ) { return ( Function < T , T > ) IDENTITY ; }
< T > justCallable ( T value ) { return new JustValue < Object , T > ( value ) ; }
< T , U > justFunction ( ) { return new JustValue < T , U > ( value ) ; }
< T , U > castFunction ( Class < U > target ) { return new CastToClass < T , U > ( target ) ; }
< T > create ( ) { return new UnicastSubject < T > ( bufferSize ( ) , true ) ; }
< T > create ( ) { return new UnicastSubject < T > ( ) ; }
< T > create ( int capacityHint ) { return new UnicastSubject < T > ( capacityHint ) ; }
< T > create ( ) { return create ( false ) ; }
( ) { if ( error != null ) { return error ; } return null ; }
the error message .
for the given timeout .
( SimplePlainQueue < T > q , Subscriber < ? super U > a , boolean delayError , QueueDrain < T , U > qd ) { if ( delayError ) { a . onError ( new MissingBackpressureException ( " Could not emit value due to lack of requests . " ) ) ; return ; } return qd . leave ( - missed ) ; }
request ( Subscription s , int prefetch ) { s . request ( prefetch < 0 ? Long . MAX_VALUE : prefetch ) ; return s ; }
( Subscriber < ? super T > actual , Queue < T > queue , AtomicLong state , BooleanSupplier isCancelled ) { if ( queue . isEmpty ( ) ) { actual . onComplete ( ) ; return ; } if ( postCompleteDrain ( state . get ( ) , actual , queue , state , isCancelled ) ) { return ; } postCompleteDrain ( state . get ( ) , actual , queue , state , isCancelled ) ; return ; }
the produced value .
the value of the notification .
the error message .
a Disposable .
setOnce ( AtomicReference < Disposable > upstream , Disposable next , Class < ? > observer ) { ObjectHelper . requireNonNull ( upstream , " upstream is null " ) ; ObjectHelper . requireNonNull ( next , " next is null " ) ; if ( upstream . compareAndSet ( null , next ) ) { next . dispose ( ) ; if ( upstream . get ( ) != DisposableHelper . DISPOSED ) { reportDoubleSubscription ( observer ) ; } return false ; } return true ; }
the next subscription .
the next subscription .
a long to a long .
multipliers a and b .
a long to a AtomicLong .
a NullPointerException .
a new object to the head .
the executor .
a ScheduledExecutorService .
a Subscription to the given Subscription .
( ) { for ( ; ; ) { AppendOnlyLinkedArrayList < Object > q = queue ; if ( q == null ) { emitting = false ; return ; } q . forEachWhile ( this ) ; } }
( Throwable error ) { if ( error instanceof Error ) { throw ( Error ) error ; } if ( error instanceof RuntimeException ) { return ( RuntimeException ) error ; } return new RuntimeException ( error ) ; }
< Throwable > flatten ( Throwable t ) { if ( t instanceof CompositeException ) { return flatten ( ( CompositeException ) t ) ; } if ( t instanceof CompositeException ) { return flatten ( ( CompositeException ) t ) ; } if ( t instanceof CompositeException ) { return flatten ( ( CompositeException ) t ) ; } return flatten ( t ) ; }
( Throwable e ) throws Exception { if ( e instanceof Exception ) { throw ( Exception ) e ; } throwIfThrowable ( e ) ; }
( ) { if ( set != null ) { set . clear ( ) ; } }
int size ( ) { synchronized ( this ) { if ( disposed ) { return 0 ; } OpenHashSet < Disposable > set = resources ; return set != null ? set . size ( ) : 0 ; } }
ObservableSource < T > to ScalarDisposable < R > .
< T , U > scalarXMap ( T value , Function < ? super T , ? extends ObservableSource < ? extends U > > mapper ) { return RxJavaPlugins . onAssembly ( new ScalarXMapObservable < T , U > ( value , mapper ) ) ; }
a notification .
a notification .
a new SpscArrayQueue < T > .
a new SpscLinkedArrayQueue < T > .
a new element to the queue .
get ( ) { return resource . get ( ) ; }
the state of the Observer .
the state of the downstream .
the state of the downstream .
( Function < ? super T , ? extends Publisher < ? extends R > > mapper ) { return concatMapDelayError ( mapper , 1 , true ) ; }
( Function < ? super T , ? extends Iterable < ? extends U > > mapper ) { return concatMapIterable ( mapper , 1 ) ; }
< T > sorted ( Comparator < ? super T > sortFunction ) { ObjectHelper . requireNonNull ( sortFunction , " sortFunction " ) ; return toList ( ) . toFlowable ( ) . sort ( sortFunction ) ; }
a new PerfAsyncConsumer ( ) { return new PerfAsyncConsumer ( ) ; }
a request to the upstream .
a new PublishDisposable < T > .
the subscribers from the queue .
< T > observeOn ( final ConnectableFlowable < T > cf , final Scheduler scheduler ) { final Flowable < T > flowable = cf . observeOn ( scheduler ) ; return RxJavaPlugins . onAssembly ( new ConnectableFlowableReplay < T > ( cf , flowable ) ) ; }
the response to a ResponseBody .
( long amount ) { if ( amount < 0 ) { throw new IllegalArgumentException ( " Amount must be positive value . " ) ; } this . delayMs = amount ; }
a new error response .
the delay .
sample data from given username and password .
a new HttpMethod object .
for user " + username ; }
the password .
true if the given password matches the given salt .
version checks .
checks for the given spring version .
the version of the spring security core .
a new attributeExchangeConfigurer .
< HttpSecurity > oauth2Client ( ) throws Exception { OAuth2ClientConfigurer < HttpSecurity > configurer = getOrApply ( new OAuth2ClientConfigurer < > ( ) ) ; this . postProcess ( configurer ) ; return configurer ; }
< HttpSecurity > oauth2ResourceServer ( ) throws Exception { OAuth2ResourceServerConfigurer < HttpSecurity > configurer = getOrApply ( new OAuth2ResourceServerConfigurer < > ( getContext ( ) ) ) ; return configurer ; }
a new ChannelSecurityConfigurer < HttpSecurity > . ChannelRequestMatcherRegistry .
the given DN to the given value .
the entry from the given DN .
for multiple attribute values .
for multiple attribute values .
for entry under DN ' " + base + " ' .
buildControls ( ) { return new SearchControls ( originalControls . getSearchScope ( ) , originalControls . getCountLimit ( ) , originalControls . getTimeLimit ( ) , originalControls . getReturningAttributes ( ) , RETURN_OBJECT , originalControls . getDerefLinkFlag ( ) ) ; }
all the primary keys of a given Acl .
buildDetails ( HttpServletRequest context ) { Collection < String > j2eeUserRoles = getUserRoles ( context ) ; Collection < ? extends GrantedAuthority > userGas = j2eeUserRoles2GrantedAuthoritiesMapper . getGrantedAuthorities ( j2eeUserRoles ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( " J2EE roles [ " + j2eeUserRoles + " ] mapped to Granted Authorities : [ " + userGas + " ] " ) ; } PreAuthenticatedGrantedAuthoritiesWebAuthenticationDetails result = new PreAuthenticatedGrantedAuthoritiesWebAuthenticationDetails ( context , userGas ) ; return result ; }
an embedded LDAP server bean .
a servlet api filter .
a JaasApiIntegrationFilter .
a WhitelistedTypeResolverBuilder .
a spring security filter .
the token for the given series .
a list of authorities for a given attribute .
newCipher ( ) { try { return Cipher . getInstance ( algorithm ) ; } catch ( NoSuchAlgorithmException e ) { throw new IllegalArgumentException ( " Not a valid encryption algorithm " , e ) ; } catch ( NoSuchPaddingException e ) { throw new IllegalStateException ( " Should not happen " , e ) ; } }
public void afterPropertiesSet ( ) { super . afterPropertiesSet ( ) ; }
the secure context token .
- authenticated principal has changed .
the pre - authenticated principal and credentials .
the content length of the response .
< GrantedAuthority , Set < GrantedAuthority > > mapAuthorities ( Collection < ? extends GrantedAuthority > authorities ) { HashSet < GrantedAuthority > mapped = new HashSet < > ( authorities . size ( ) ) ; for ( GrantedAuthority authority : authorities ) { mapped . add ( mapAuthority ( authority . getAuthority ( ) ) ) ; } if ( defaultAuthority != null ) { mapped . add ( defaultAuthority ) ; } return mapped ; }
loginProcessingUrl ( ) { return this . loginProcessingUrl ; }
authentication defaults .
( boolean permitAll ) { if ( permitAll ) { PermitAllSupport . permitAll ( http , loginPage , loginProcessingUrl , failureUrl ) ; } }
the password of the given password .
( HttpServletRequest request , String cookieName ) { Cookie [ ] cookies = request . getCookies ( ) ; if ( cookies == null ) { return null ; } for ( Cookie cookie : cookies ) { if ( cookieName . equals ( cookie . getName ( ) ) ) { return cookie . getValue ( ) ; } } return null ; }
cookie tokens .
the cookie .
the reactive security context .
the query string .
the port of the cas service .
the principal of the authentication object .
the current session .
a UsernamePasswordAuthenticationToken .
the LDAP server URL .
the context environment properties .
getRedirectUrl ( ) { return UrlUtils . buildFullRequestUrl ( scheme , serverName , serverPort , requestURI ) ; }
the UiSuffix of the current page .
a new user .
a UserDetailsService .
to the attributes .
true if the serviceTicketRequest or proxyReceptorRequest is true .
the service ticket request .
a proxy ticket request .
the authenticated authentication .
the proxyReceptorRequest for the given request .
a security expression root .
the JWKSet from the given URL .
the value to UTF - 8 .
the WebSphere groups for the current user .
the user details from the authentication token .
WebSphere principal .
a byte array into a byte array .
a byte array of the specified length .
a list of the given authorities .
( Map < ? , ? > orgMap ) { Map < String , Collection < GrantedAuthority > > result = new HashMap < String , Collection < GrantedAuthority > > ( orgMap . size ( ) ) ; for ( Map . Entry < ? , ? > entry : orgMap . entrySet ( ) ) { Assert . isInstanceOf ( String . class , entry . getKey ( ) , " attributes2grantedAuthoritiesMap contains non - String objects as keys " ) ; Assert . isInstanceOf ( String . class , entry . getValue ( ) , " attributes2grantedAuthoritiesMap contains non - String objects as values " ) ; result . put ( ( String ) entry . getKey ( ) , getGrantedAuthorityCollection ( entry . getValue ( ) ) ) ; } return result ; }
a Collection of GrantedAuthority objects .
a GrantedAuthorityCollection to the result .
J2EE principal .
( Class < C > sharedType ) { return getSharedObject ( sharedType ) ; }
to HTTPS .
the result of the method invocation .
the role from the given string .
a list of roles for a given user .
a persistent remember - me token .
a persistent login for the user .
the user to the given username .
the current user associated with the request .
( String exitUserUrl ) { Assert . isTrue ( UrlUtils . isValidRedirectUrl ( exitUserUrl ) , " exitUserUrl cannot be empty and must be a valid redirect URL " ) ; return this ; }
ModelAndView displayPublicIndex ( ) { Contact rnd = contactManager . getRandomContact ( ) ; if ( rnd == null ) { return new ModelAndView ( " hello " , " contact " , null ) ; } return new ModelAndView ( " hello " , " contact " , rnd ) ; }
springSecurityFilterChain ( ) throws Exception { return springSecurityFilterChain ( ) ; }
a JWT token .
( ) throws IOException { if ( SecurityContextHolder . getContext ( ) . getAuthentication ( ) == null ) { return false ; } SecurityExpressionHandler < FilterInvocation > handler = getExpressionHandler ( ) ; try { accessExpression = handler . getExpressionParser ( ) . parseExpression ( getAccess ( ) ) ; } catch ( ParseException e ) { IOException ioException = new IOException ( ) ; ioException . initCause ( e ) ; throw ioException ; } return true ; }
( ) throws IOException { String contextPath = ( ( HttpServletRequest ) getRequest ( ) ) . getContextPath ( ) ; Authentication currentUser = SecurityContextHolder . getContext ( ) . getAuthentication ( ) ; return getPrivilegeEvaluator ( ) . isAllowed ( contextPath ) ; }
a JWT to a GrantedAuthority .
CsrfToken ( HttpServletRequest request ) { return wrap ( request , this . delegate . generateToken ( request ) ) ; }
the admin permission page .
the add permission page .
a permission to a contact .
a permission from a contact .
the default role for a given role .
static UserDetailsResourceFactoryBean fromString ( String users ) { InMemoryResource resource = new InMemoryResource ( users ) ; return fromResource ( resource ) ; }
the attributes of the given name .
the first attribute value .
a string to a byte array .
a byte array .
the parameter names .
a new contact .
( Method method ) { return null ; }
a secure method .
all ConfigAttributes for a given method .
true if the mapped name matches the methodName .
anyRequest ( ) { this . anyRequestConfigured = false ; return this ; }
( String userDn , String username ) { handleBindException ( userDn , username , null ) ; }
a random contact .
( HttpServletRequest request ) { HttpSession session = request . getSession ( false ) ; if ( session == null ) { return ; } session . removeAttribute ( WebAttributes . AUTHENTICATION_EXCEPTION ) ; }
getField ( Class < ? > clazz , String fieldName ) throws IllegalStateException { Assert . notNull ( clazz , " Class required " ) ; Assert . hasText ( fieldName , " Field name required " ) ; return getField ( clazz , fieldName ) ; }
( final HttpServletRequest request , final HttpServletResponse response ) { return CommonUtils . constructServiceUrl ( null , response , this . serviceProperties . getService ( ) , null , this . encodeServiceUrlWithSessionId ) ; }
( final String serviceUrl ) { return new RedirectUrl ( serviceUrl ) ; }
prefix from encPass .
- authenticated entry point called . Rejecting access .
the filter stack .
the registered types .
the cause of the throwable .
the access manager .
< String > authorityListToSet ( Collection < ? extends GrantedAuthority > userAuthorities ) { Assert . notNull ( userAuthorities , " userAuthorities cannot be null " ) ; Set < String > set = new HashSet < > ( userAuthorities . size ( ) ) ; for ( GrantedAuthority authority : userAuthorities ) { set . add ( authority . getAuthority ( ) ) ; } return set ; }
whether a byte [ ] matches a byte [ ] .
the default failure url .
resolveHiddenInputs ( Map < String , String > resolveHiddenInputs ) { this . resolveHiddenInputs = resolveHiddenInputs ; return this ; }
the request url .
the absolute URL of the given url .
a list of OpenID attributes .
the identifier to a long .
entries for the given acl .
a new object identity .
acl to the given object identity .
the request to the session .
pathMatchers ( HttpMethod method ) { List < ServerWebExchangeMatcher > matchers = new ArrayList < > ( patterns . length ) ; for ( String pattern : patterns ) { matchers . add ( new PathPatternParserServerWebExchangeMatcher ( pattern , method ) ) ; } return new OrServerWebExchangeMatcher ( matchers ) ; }
a Mono < ServerWebExchangeMatcher . MatchResult > matches ( ServerWebExchange exchange ) { return Mono . just ( exchange ) ; }
delux ( CharSequence password , CharSequence salt ) { return new HexEncodingTextEncryptor ( stronger ( password , salt ) ) ; }
textEncryptor ( CharSequence password , CharSequence salt ) { return new HexEncodingTextEncryptor ( standard ( password , salt ) ) ; }
static TextEncryptor queryableText ( CharSequence password , CharSequence salt ) { return new HexEncodingTextEncryptor ( new AesBytesEncryptor ( password . toString ( ) , salt ) ) ; }
headers to the response .
the target url .
the target url from the request .
the target url parameter .
the parent directory from the given id .
buildDn ( String username ) { DistinguishedName dn = new DistinguishedName ( userDnBase ) ; dn . add ( usernameAttribute , username ) ; return dn ; }
a shared object .
the login config url .
the current date .
the date value .
the cache .
the authentication details .
Websphere security name for subject .
WebSphere groups for the given security name .
password for the current user .
a DistinguishedName for the given group .
the maximum sessions of a given principal .
the details of a given AuthenticationToken .
the filters for the given request .
all filters .
( ) { return SecurityWebApplicationContextUtils . findRequiredWebApplicationContext ( ) ; }
getFullDn ( DistinguishedName dn ) throws NamingException { DistinguishedName baseDn = new DistinguishedName ( baseCtx . getNameInNamespace ( ) ) ; if ( dn . contains ( baseDn ) ) { return dn ; } baseDn . append ( dn ) ; return baseDn ; }
the session attributes .
basic ( ) { final PreemptiveBasicAuthScheme preemptiveBasicAuthScheme = new PreemptiveBasicAuthScheme ( ) ; preemptiveBasicAuthScheme . setUserName ( userName ) ; preemptiveBasicAuthScheme . setPassword ( password ) ; return preemptiveBasicAuthScheme ; }
filters to the list of filters .
a filter to the list of filters .
basic ( String userName ) { final BasicAuthScheme scheme = new BasicAuthScheme ( ) ; scheme . setUserName ( userName ) ; scheme . setPassword ( password ) ; return scheme ; }
the authentication scheme .
form ( String userName , String password ) { return new FormAuthScheme ( ) ; }
a proxy for the given URI .
the response .
redirect ( RedirectConfig redirectConfig ) { notNull ( redirectConfig , " Redirect config " ) ; return redirectConfig ; }
defaultQueryParameterCharset ( ) { return new EncoderConfig ( defaultContentCharset , charset , shouldAppendDefaultContentCharsetToContentTypeIfUndefined , contentEncoders , contentTypeToDefaultCharset , true ) ; }
a new ObjectMapperConfig with the defaultObjectMapperType .
a new ObjectMapperConfig object .
a RestAssuredMockMvcConfig .
a new RestAssuredMockMvcConfig .
a RestAssuredMockMvcConfig .
a new RestAssuredMockMvcConfig .
a RestAssuredMockMvcConfig .
a new RestAssuredMockMvcConfig .
a new RestAssuredMockMvcConfig .
a new RestAssuredMockMvcConfig .
mockMvcConfig ( ) { return new MockMvcConfig ( ) ; }
a new RestAssuredMockMvcConfig .
a new RestAssuredMockMvcConfig .
the matcher config .
CertificateAuthSettings allowAllHostnames ( ) { return new CertificateAuthSettings ( keystoreType , trustStoreType , port , trustStore , keyStore , ALLOW_ALL_HOSTNAME_VERIFIER , sslSocketFactory ) ; }
( ) { return new XmlPathConfig ( jaxbObjectMapperFactory , defaultParserType , defaultDeserializer , charset ) ; }
the declared namespace .
a request to a given URI .
default request headers .
the proxy for the given host .
a MultiPartSpecBuilder with a control name .
a header to the MultiPartSpec .
the credentials for the given user .
the credentials for the NTLM client .
the headers of the given header .
the mockMvcFactory .
the value of the given header .
the restAssured response .
value ( Matcher < String > valueMatcher ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( " value " , valueMatcher ) ) ) ; }
a DetailedCookieMatcher for the comment .
the expiry date from the cookie .
domain ( Matcher < ? > domainMatcher ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( " domain " , domainMatcher ) ) ) ; }
path ( String pathMatcher ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( " path " , pathMatcher ) ) ) ; }
secured ( Matcher < ? super Boolean > securedMatcher ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( " secured " , securedMatcher ) ) ) ; }
httpOnly ( Matcher < ? super Boolean > httpOnlyMatcher ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( " httpOnly " , httpOnlyMatcher ) ) ) ; }
version ( Matcher < ? > versionMatcher ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( " version " , versionMatcher ) ) ) ; }
maxAge ( Matcher < ? super Integer > maxAgeMatcher ) { return new DetailedCookieMatcher ( maxAgeMatcher ) ; }
expectHeader ( String headerName , Matcher < String > expectedValueMatcher ) { spec . header ( headerName , expectedValueMatcher ) ; return this ; }
expectHeader ( String headerName , String expectedValue ) { spec . header ( headerName , expectedValue ) ; return this ; }
a cookie to the response spec .
ProxySpecification withHost ( String host ) { return new ProxySpecification ( host , port , scheme ) ; }
numberReturnType ( NumberReturnType numberReturnType ) { return new JsonPathConfig ( numberReturnType , defaultParserType , gsonObjectMapperFactory ) ; }
the default parser type .
public LogConfig defaultStream ( ) { return new LogConfig ( ) ; }
( ) { return new LogConfig ( defaultPrintStream , prettyPrintingEnabled , logDetail , urlEncodeRequestUri , true ) ; }
a new HttpRequest .
a new MultiPartConfig with a default boundary .
a new attribute to the request spec .
a header to the request spec .
a multi part to the request spec .
result handlers to the request spec .
the value of the parameter .
a new HttpClientConfig .
httpClientFactory ( ) { return new HttpClientConfig ( httpClientFactory , httpClientParams , httpMultipartMode ) ; }
httpMultipartMode ( ) { return new HttpClientConfig ( httpClientFactory , httpClientParams , httpMultipartMode , shouldReuseHttpClientInstance , httpClient ) ; }
a JSONAssertion .
the integer value of the given path .
the byte value of the given path .
getShort ( String path ) { if ( path == null || path . length ( ) == 0 ) { return null ; } if ( value instanceof Short ) { return ( Short ) value ; } else if ( value instanceof Long ) { return ( ( Long ) value ) . shortValue ( ) ; } else if ( value instanceof Integer ) { return ( ( Integer ) value ) . shortValue ( ) ; } else { return ObjectConverter . convertObjectTo ( value , Short . class ) ; } }
getFloat ( String path ) { final Object value = get ( path ) ; if ( value instanceof Double ) { return ( ( Double ) value ) . floatValue ( ) ; } else { return ObjectConverter . convertObjectTo ( value , Float . class ) ; } }
a double to a double .
the value of the given path .
< T > getList ( String path , Class < T > genericType ) { if ( genericType == null ) { throw new IllegalArgumentException ( " Generic type cannot be null " ) ; } final List < T > original = get ( path ) ; final List < T > newList = new LinkedList < T > ( ) ; if ( original != null ) { for ( T t : original ) { T e ; if ( t instanceof Map && ! genericType . isAssignableFrom ( Map . class ) ) { String str = objectToString ( t ) ; e = ( T ) jsonStringToObject ( str , genericType ) ; } else { e = ObjectConverter . convertObjectTo ( t , genericType ) ; } newList . add ( e ) ; } } return newList ; }
< K , V > getMap ( String path ) { return get ( path ) ; }
the object from the given path .
setBody ( Object object , ObjectMapper mapper ) { spec . body ( object , mapper ) ; return this ; }
a cookie to the request spec .
a parameter to the request spec .
a parameter to the request spec .
updateStrategy ( ) { return new MockMvcParamConfig ( queryParamsUpdateStrategy , updateStrategy , requestParameterUpdateStrategy , attributeUpdateStrategy , sessionUpdateStrategy ) ; }
logResponseToIfMatches ( PrintStream stream , Matcher < Integer > matcher ) { return new ResponseLoggingFilter ( stream , matcher ) ; }
cookies ( Cookie cookie ) { final List < Cookie > cookieList = new LinkedList < Cookie > ( ) ; cookieList . add ( cookie ) ; Collections . addAll ( cookieList , additionalCookies ) ; return new Cookies ( cookieList ) ; }
up the backingMap .
the bindings for the given type .
< T > getBindingOrThrow ( Key < T > key , Errors errors , JitLimitation jitType ) throws ErrorsException { BindingImpl < T > binding = state . getExplicitBinding ( key ) ; if ( binding != null ) { return binding ; } return getJustInTimeBinding ( key , errors ) ; }
< String > convertConstantStringBinding ( Key < String > key , Errors errors ) throws ErrorsException { return convertConstantStringBinding ( key , errors ) ; }
the binding .
( Binding < ? > binding , InjectionPoint ip ) { failedJitBindings . remove ( binding . getKey ( ) ) ; membersInjectorStore . remove ( binding . getKey ( ) . getTypeLiteral ( ) ) ; provisionListenerStore . remove ( binding ) ; }
the dependencies of the given binding .
a new binding for the given key .
all the parameters from the given context .
the injector to the given key .
a logger to the injector .
binding annotations .
whether a method overrides a method .
the delegate .
the provider of the given type .
all of the given types .
< T > canonicalizeForKey ( TypeLiteral < T > typeLiteral ) { Type type = typeLiteral . getType ( ) ; if ( ! isFullySpecified ( type ) ) { Errors errors = new Errors ( ) . keyNotFullySpecified ( typeLiteral ) ; throw new ConfigurationException ( errors . getMessages ( ) ) ; } if ( typeLiteral . getRawType ( ) == javax . inject . Provider . class ) { throw new ConfigurationException ( errors . getMessages ( ) ) ; } if ( typeLiteral . getRawType ( ) == javax . inject . Provider . class ) { throw new ConfigurationException ( errors . getMessages ( ) ) ; } return typeLiteral ; }
the value to a primitive type .
static ClassLoader canonicalize ( ClassLoader classLoader ) { return classLoader != null ? classLoader : SystemBridgeHolder . SYSTEM_BRIDGE . getParent ( ) ; }
the version of the FastClass .
static boolean isPubliclyCallable ( Member member ) { if ( ! Modifier . isPublic ( member . getModifiers ( ) ) ) { return false ; } Class < ? > [ ] parameterTypes ; if ( member instanceof Constructor ) { parameterTypes = ( ( Constructor ) member ) . getParameterTypes ( ) ; } else if ( member instanceof Method ) { parameterTypes = ( ( Method ) member ) . getParameterTypes ( ) ; } else if ( member instanceof Constructor ) { parameterTypes = ( ( Constructor ) member ) . getParameterTypes ( ) ; } else if ( member instanceof Method ) { parameterTypes = ( ( Method ) member ) . getParameterTypes ( ) ; } else { parameterTypes = member . getParameterTypes ( ) ; } for ( Class < ? > type : parameterTypes ) { if ( ! Modifier . isPublic ( type . getModifiers ( ) ) ) { return false ; } } return true ; }
( Key < ? > key ) { return key . getAnnotation ( ) == null ? key : Key . get ( key . getAnnotation ( ) . annotationType ( ) ) ; }
< T > requestInjection ( InjectorImpl injector , T instance , Binding < T > binding , Object source , Set < InjectionPoint > injectionPoints ) { checkNotNull ( source ) ; Preconditions . checkState ( ! validationStarted , " Member injection could not be requested after validation is started " ) ; ProvisionListenerStackCallback < T > provisionCallback = binding == null ? null : injector . provisionListenerStore . get ( binding ) ; if ( instance == null || ( injectionPoints . isEmpty ( ) && injector . membersInjectorStore . hasTypeListeners ( ) && provisionCallback == null ) ) { return Initializables . of ( instance ) ; } if ( injectionPoints . isEmpty ( ) && injector . membersInjectorStore . hasTypeListeners ( ) && provisionCallback == null ) { return Initializables . of ( instance ) ; } return Initializables . of ( instance ) ; }
( Errors errors ) { validationStarted = true ; initializablesCache . clear ( ) ; for ( InjectableReference < ? > reference : pendingInjections ) { try { reference . validate ( errors ) ; } catch ( ErrorsException e ) { errors . merge ( e . getErrors ( ) ) ; } } }
a new instance of the given class .
the request dispatcher .
< ? extends T > scope ( Key < T > key , InjectorImpl injector , InternalFactory < ? extends T > creator , Object source , Scoping scoping ) { if ( scoping . isNoScope ( ) ) { return creator ; } Scope scope = scoping . getScopeInstance ( ) ; Provider < T > scoped = scope . scope ( key , new ProviderToInternalFactoryAdapter < T > ( injector , creator ) ) ; return new InternalFactoryToProviderAdapter < T > ( scoped , source ) ; }
makeInjectable ( Scoping scoping , InjectorImpl injector , Errors errors ) { if ( scoping == null ) { return scoping ; } if ( scoping . getScopeAnnotation ( ) == null ) { return scoping ; } ScopeBinding scope = injector . state . getScopeBinding ( scopeAnnotation ) ; if ( scope != null ) { return forInstance ( scope . getScope ( ) ) ; } errors . scopeNotFound ( scopeAnnotation ) ; return scoping ; }
the path .
a default annotation .
isRetainedAtRuntime ( Class < ? extends Annotation > annotationType ) { Retention retention = annotationType . getAnnotation ( Retention . class ) ; return retention != null && retention . value ( ) == RetentionPolicy . RUNTIME ; }
the scope annotation .
the key for the given type .
the name of the annotation .
( Provider < T > delegate ) { checkState ( this . delegate == null , " delegate already initialized " ) ; this . delegate = delegate ; }
a direct type binding .
the constructor injector .
the scope of the interceptor .
newRealMapBinder ( Binder binder ) { return binder ; }
< V > getKeyForNewValue ( K key ) { checkNotNull ( key , " key " ) ; checkConfiguration ( ! bindingSelection . isInitialized ( ) , " MapBinder was already initialized " ) ; RealMultibinder < Map . Entry < K , Provider < V > > > entrySetBinder = bindingSelection . getEntrySetBinder ( ) ; Key < V > valueKey = Key . get ( bindingSelection . getValueType ( ) , new RealElement ( entrySetBinder . getSetName ( ) , MAPBINDER , bindingSelection . getKeyType ( ) . toString ( ) ) ) ; entrySetBinder . addBinding ( ) . toProvider ( new ProviderMapEntry < K , V > ( key , valueKey ) ) ; return valueKey ; }
a new instance of the given class .
replace message .
a new CheckedProviderMethodsModule .
( ) { return ( Collection < AssistedMethod > ) assistDataByMethod . values ( ) ; }
if the type is not specified .
if a constructor has a given parameter list .
< Dependency < ? > > getDependencies ( InjectionPoint ctorPoint , TypeLiteral < ? > implementation ) { ImmutableSet . Builder < Dependency < ? > > builder = ImmutableSet . builder ( ) ; builder . addAll ( ctorPoint . getDependencies ( ) ) ; if ( ! implementation . getRawType ( ) . isInterface ( ) ) { for ( InjectionPoint ip : InjectionPoint . forInstanceMethodsAndFields ( implementation ) ) { builder . addAll ( ip . getDependencies ( ) ) ; } } return builder . build ( ) ; }
Assisted dependencies .
if an Assisted Provider has assisted Provider dependencies or injects the Injector .
< ? > getBindingFromNewInjector ( final Method method , final Object [ ] args , final AssistData data ) { checkState ( injector != null , " Factories . create ( ) factories cannot be used until they ' re initialized by Guice . " ) ; final Key < ? > returnType = data . returnType ; final Key < ? > returnKey = Key . get ( returnType . getTypeLiteral ( ) , RETURN_ANNOTATION ) ; return injector . getBinding ( returnKey ) ; }
public Object invoke ( Object proxy , final Method method , final Object [ ] args ) throws Throwable { if ( methodHandleByMethod . containsKey ( method ) ) { return methodHandleByMethod . get ( method ) . invoke ( proxy , args ) ; } if ( methodHandleByMethod . containsKey ( method ) ) { return methodHandleByMethod . get ( method ) . invoke ( proxy , args ) ; } if ( method . getDeclaringClass ( ) . equals ( Object . class ) ) { if ( " equals " . equals ( method . getName ( ) ) ) { return proxy == args [ 0 ] ; } else if ( " hashCode " . equals ( method . getName ( ) ) ) { return System . identityHashCode ( proxy ) ; } else { return method . invoke ( this , args ) ; } } return null ; }
a list of possible matches for the given key .
newRealSetBinder ( Binder binder , Key < T > key ) { binder = binder . skipSources ( RealMultibinder . class ) ; RealMultibinder < T > result = new RealMultibinder < > ( binder , key ) ; binder . install ( result ) ; return result ; }
< T > getKeyForNewItem ( ) { checkConfiguration ( ! bindingSelection . isInitialized ( ) , " Multibinder was already initialized " ) ; return Key . get ( bindingSelection . getElementTypeLiteral ( ) , new RealElement ( bindingSelection . getSetName ( ) , MULTIBINDER , " " ) ) ; }
findNextFilter ( HttpServletRequest request ) { int index = 0 ; while ( index < filterDefinitions . length ) { Filter filter = filterDefinitions [ index ] . getFilterIfMatching ( request ) ; if ( filter != null ) { return filter ; } } return null ; }
if a constructor is annotated with @ Inject .
the constructor injection point .
< Dependency < ? > > getInternalDependencies ( ) { ImmutableSet . Builder < InjectionPoint > builder = ImmutableSet . builder ( ) ; if ( factory . constructorInjector == null ) { builder . add ( constructorInjectionPoint ) ; try { builder . addAll ( InjectionPoint . forInstanceMethodsAndFields ( constructorInjectionPoint . getDeclaringType ( ) ) ) ; } catch ( ConfigurationException ignored ) { } } else { builder . add ( getConstructor ( ) ) . addAll ( getInjectableMembers ( ) ) ; } return Dependency . forInjectionPoints ( builder . build ( ) ) ; }
static Module forModule ( Object module , ModuleAnnotatedMethodScanner scanner ) { return forObject ( module , false , scanner ) ; }
the annotation claimed by the method .
getLineNumber ( Member member ) { Preconditions . checkArgument ( type == member . getDeclaringClass ( ) , " Member % s belongs to % s , not % s " , member , member . getDeclaringClass ( ) , type ) ; return lines . get ( memberKey ( member ) ) ; }
initialize ( Injector injector ) { this . injector = injector ; return this ; }
< T > continueRequest ( Callable < T > callable , Map < Key < ? > , Object > seedMap ) { return wrap ( callable , continueRequest ( seedMap ) ) ; }
a Callable < T > to another callable .
( Key < ? > key , Object object ) { validateAndCanonicalizeValue ( key , object ) ; }
< T > get ( TypeLiteral < T > key , Errors errors ) throws ErrorsException { return ( MembersInjectorImpl < T > ) cache . get ( key , errors ) ; }
< T > createWithListeners ( TypeLiteral < T > type , Errors errors ) throws ErrorsException { errors . throwIfNewErrors ( errors . size ( ) ) ; Set < InjectionPoint > injectionPoints ; try { injectionPoints = InjectionPoint . forInstanceMethodsAndFields ( type ) ; } catch ( ConfigurationException e ) { errors . merge ( e . getErrorMessages ( ) ) ; injectionPoints = e . getPartialValue ( ) ; } errors . throwIfNewErrors ( errors . size ( ) ) ; return new MembersInjectorImpl < T > ( injector , type , errors ) ; }
< SingleMemberInjector > getInjectors ( Set < InjectionPoint > injectionPoints , Errors errors ) { List < SingleMemberInjector > injectors = Lists . newArrayList ( ) ; for ( InjectionPoint injectionPoint : injectionPoints ) { try { Errors errorsForMember = injectionPoint . isOptional ( ) ? new Errors ( injectionPoint ) : errors . withSource ( injectionPoint ) ; SingleMemberInjector injector = injectionPoint . getMember ( ) instanceof Field ? new SingleFieldInjector ( this . injector , injectionPoint , errorsForMember ) : new SingleMethodInjector ( this . injector , injectionPoint , errorsForMember ) ; injectors . add ( injector ) ; } catch ( ErrorsException ignoredForNow ) { } } return injectors ; }
the key for the given type .
the strategy for the annotation .
the strategy for the given annotationType .
a stack trace .
the StackTraceElement from the source .
the error messages .
static Message create ( String messageFormat ) { return create ( null , messageFormat , arguments ) ; }
a new message .
a new message .
an object to an ElementSource .
shouldBeSkipped ( String className ) { return ( parent != null && parent . shouldBeSkipped ( className ) ) || classNamesToSkip . contains ( className ) ; }
a StackTraceElement for the given module class .
the jmxremote module .
the dependency to the source .
( com . google . inject . Key < ? > key , Object source ) { this . key = key ; this . source = source ; }
< T > of ( final T instance ) { return new Initializable < T > ( ) { @ Override public T get ( ) { return instance ; } @ Override public String toString ( ) { return String . valueOf ( instance ) ; } } ; }
the given provider .
the event processors for the given type .
a connection event processor .
the result of the task .
( Throwable t ) { if ( t instanceof RuntimeException ) { throw ( RuntimeException ) t ; } else if ( t instanceof Error ) { throw ( Error ) t ; } else { throw new IllegalStateException ( " Not unchecked ! " , t ) ; } }
a processor for the given cmdCode .
a default processor .
the default RemotingProcessor .
the url .
( ByteBuf in ) { if ( in . readableBytes ( ) >= protocolCodeLength ) { byte [ ] protocolCodeBytes = new byte [ protocolCodeLength ] ; in . readBytes ( protocolCodeBytes ) ; return ProtocolCode . fromBytes ( protocolCodeBytes ) ; } return null ; }
all connections from the pool .
expired pool task .
a new connection pool .
a new connection .
the connection pool .
healIfNeed ( ConnectionPool pool ) throws RemotingException { this . healTasks . put ( poolKey , new HealConnectionCall ( url , pool ) ) ; }
a new connection .
the connection .
the connection .
the connection to the remote address .
< String > setAttributeIfAbsent ( String key , Object value ) { if ( attributes . containsKey ( key ) ) { return attributes . get ( key ) ; } return null ; }
a new user processor .
a MultiInterestUserProcessor .
a request to the RpcRequestProcessor .
RpcRequestCommand .
( RemotingContext ctx ) { if ( ctx . getInvokeContext ( ) . containsKey ( InvokeContext . BOLT_PROCESS_WAIT_TIME ) ) { return ctx . getInvokeContext ( ) . get ( InvokeContext . BOLT_PROCESS_WAIT_TIME ) ; } return ctx ; }
the current timestamp of the RpcRequestCommand .
the current timestamp of the Rpc request .
the message .
a response to the server .
a request to the server .
a BitSet to a byte .
the value to a BitSet .
a ReconnectTask to the list of tasks .
the connection .
the request to a RemotingCommand .
the list of connections .
the connection pools .
the last select connection .
getBool ( String key , boolean defaultValue ) { return Boolean . parseBoolean ( System . getProperty ( key , defaultValue ) ) ; }
the address of the logger .
the timeout of the request .
( String className ) { return null ; }
a random connection .
< T > T get ( String key ) { return this . context . get ( key ) != null ? ( T ) this . context . get ( key ) : defaultIfNotFound ; }
the properties of the given key .
the response object from the given address .
the response to a RpcResponseCommand .
the response to a Throwable .
the error message .
a RpcServerException .
connection trace log .
newEventLoopGroup ( int nThreads ) { return epollEnabled ? new EpollEventLoopGroup ( nThreads , threadFactory ) : new NioEventLoopGroup ( nThreads ) ; }
( final Channel channel ) { if ( null == channel ) { return StringUtils . EMPTY ; } final SocketAddress remote = channel . remoteAddress ( ) ; return doParse ( remote != null ? remote . toString ( ) . trim ( ) : StringUtils . EMPTY ) ; }
( final Channel channel ) { if ( null == channel ) { return StringUtils . EMPTY ; } final SocketAddress local = channel . localAddress ( ) ; return doParse ( local != null ? local . toString ( ) . trim ( ) : StringUtils . EMPTY ) ; }
the remote IP address from the channel .
the hostname of the remote channel .
the IP address of the channel .
the remote port from the channel .
the local port from the channel .
the hostname of the socket .
a new connection .
the connection .
the current connection .
a custom serializer .
the custom serializer for the given class .
a custom serializer .
the custom serializer for the given CommandCode .
the connection monitor thread .
to the remote address .
a write buffer water mark .
a Framedata frame .
a message to the server .
the code .
( ByteBuffer payload ) { try { payload . position ( payload . position ( ) + 2 ) ; reason = Charsetfunctions . stringUtf8 ( payload ) ; } catch ( IllegalArgumentException e ) { throw new InvalidDataException ( CloseFrame . NO_UTF8 ) ; } finally { payload . position ( mark ) ; } }
the payload .
the requested protocol .
( long length ) throws LimitExceededException { if ( length > Integer . MAX_VALUE ) { log . trace ( " Limit exedeed : Payloadsize is to big . . . " ) ; throw new LimitExceededException ( " Payloadsize is to big . . . " ) ; } if ( length > maxFrameSize ) { log . trace ( " Limit exedeed : Payload limit reached . Allowed : { } Current : { } " , maxFrameSize , length ) ; throw new LimitExceededException ( " Payload limit reached . " , maxFrameSize ) ; } if ( length < 0 ) { log . trace ( " Limit underflow : Payloadsize is to little . . . " ) ; throw new LimitExceededException ( " Payloadsize is to little . . . " ) ; } }
a single frame check packet size .
a key from a string .
a continuous frame .
the WebSocket message .
( WebSocketImpl webSocketImpl ) { if ( webSocketImpl . getWebSocketListener ( ) != null ) { webSocketImpl . getWebSocketListener ( ) . onWebsocketMessage ( webSocketImpl ) ; } }
the frame text .
continuous frame sequence .
previous continuous frame sequence .
the frame .
if the buffer limit is exceeded .
the size of the buffer .
( ) { long totalSize = 0 ; synchronized ( byteBufferList ) { for ( ByteBuffer buffer : byteBufferList ) { totalSize += buffer . limit ( ) ; } } return totalSize ; }
the HTTP / 1.1 handshake to the client .
( String [ ] firstLineTokens ) throws InvalidHandshakeException { if ( ! " HTTP / 1.1" . equalsIgnoreCase ( firstLineTokens [ 0 ] ) ) { throw new InvalidHandshakeException ( String . format ( " Invalid status line received : % s Status line : % s " , firstLineTokens [ 0 ] , line ) ) ; } if ( ! " HTTP / 1.1" . equalsIgnoreCase ( firstLineTokens [ 1 ] ) ) { throw new InvalidHandshakeException ( String . format ( " Invalid status line received : % s Status line : % s " , firstLineTokens [ 1 ] , line ) ) ; } if ( ! " HTTP / 1.1" . equalsIgnoreCase ( firstLineTokens [ 2 ] ) ) { throw new InvalidHandshakeException ( String . format ( " Invalid status line received : % s Status line : % s " , firstLineTokens [ 2 ] , line ) ) ; } HandshakeBuilder handshake = new HandshakeImpl1Server
the socket buffer .
( ) { write ( generateHttpResponseDueToError ( 404 ) ) ; }
( ) { }
( int errorCode ) { String errorCodeDescription ; switch ( errorCode ) { case 404 : errorCodeDescription = "404 WebSocket Upgrade Failure " ; break ; case 500 : default : errorCodeDescription = "500 Internal Server Error " ; } return ByteBuffer . wrap ( Charset . forName ( " UTF - 8" ) . getBytes ( ) ) ; }
a message to a WebSocketImpl .
the websocket connection .
to the WebSocketClient .
the port of the given URI .
a handshake to the server .
the connection lost timeout .
the connection lost timer .
the connection lost timer .
the connectionLost checker .
the connection to the other endpoint .
the connection lost timer .
ServerHandshakeBuilder onWebsocketHandshakeReceivedAsServer ( WebSocket conn , Draft draft , ClientHandshake request ) throws InvalidDataException { return new HandshakeImpl1Server ( ) ; }
void onPing ( WebSocket conn , Framedata f ) { if ( f instanceof PingFrame ) { conn . sendFrame ( new PongFrame ( ( PingFrame ) f ) ) ; } }
the WebSocket .
the port of the server .
more data from the server .
a WebSocket .
the buffer .
a WebSocket to the channel .
the selector and server thread .
the selector thread .
the server .
( WebSocket conn ) { if ( conn instanceof WebSocketImpl ) { return ( ( WebSocketImpl ) conn ) . socket ( ) ; } return null ; }
the data to the clients .
the given text .
a broadcast message to a WebSocket .
the frames of the draft .
( ByteBuffer source ) { if ( source == null ) { throw new IllegalArgumentException ( ) ; } if ( dest == null ) { throw new IllegalArgumentException ( ) ; } int fremain = source . remaining ( ) ; int toremain = dest . remaining ( ) ; if ( fremain > toremain ) { int limit = Math . min ( fremain , toremain ) ; source . limit ( limit ) ; dest . put ( source ) ; return limit ; } else { dest . put ( source ) ; return fremain ; } }
the JPA API .
an EntityManager for the given name .
withTransaction ( Consumer < EntityManager > block ) { block . accept ( em ) ; return null ; }
args toScalaBuffer ( final Object ... args ) { return scala . collection . JavaConverters . asScalaBufferConverter ( wrapArgsToListIfNeeded ( args ) ) . asScala ( ) ; }
< T > wrapArgsToListIfNeeded ( final T ... args ) { List < T > out ; if ( args != null && args . length == 1 && args [ 0 ] instanceof List ) { out = ( List < T > ) args [ 0 ] ; } else { out = Arrays . asList ( args ) ; } return out ; }
a message .
a message from a given language .
isDefinedAt ( play . api . i18n . Lang lang , String key ) { return messages . isDefinedAt ( key , lang ) ; }
preferred ( Collection < Lang > candidates ) { if ( candidates . size ( ) == 1 ) { return new MessagesImpl ( new Lang ( candidates . get ( 0 ) ) , this ) ; } else { return new MessagesImpl ( new Lang ( candidates . get ( 0 ) ) , this ) ; } }
the preferred message .
( Result result ) { return messages . setLang ( result . asScala ( ) , lang ) . asJava ( ) ; }
final Self bindings ( GuiceableModule ... modules ) { return newBuilder ( delegate . bindings ( Scala . varargs ( modules ) ) ) ; }
the bindings of the given modules .
the bindings of the given bindings .
final Self overrides ( GuiceableModule ... modules ) { return newBuilder ( delegate . overrides ( Scala . varargs ( modules ) ) ) ; }
overrides ( Module ... modules ) { return overrides ( Guiceable . modules ( modules ) ) ; }
overrides ( Iterable < ? extends Binding < ? > > bindings ) { return overrides ( Guiceable . bindings ( bindings ) ) ; }
module classes .
a CompletionStage < Result > .
the result of the call .
( String relativePath ) { return OptionConverters . toJava ( env . getExistingFile ( relativePath ) ) ; }
< T > in ( final Class < A > scope ) { return underlying . in ( scope ) . asJava ( ) ; }
< A , B > Tuple ( A a , B b ) { return Tuple . of ( a , b ) ; }
< A , B , C , D , E > Tuple5 < A , B , C , D , E > Tuple5 ( A a , B b , C c , D d , E e ) { return new Tuple5 < A , B , C , D , E > ( a , b , c , d , e ) ; }
the ExecutionContext to an Executor .
a new JPAConfig . PersistenceUnit .
a JPAConfig . PersistenceUnit instance .
JPAConfig to JPAConfig .
a Flow < String , ByteString , NotUsed > .
a Flow < JsonNode , ByteString , NotUsed > from the callback .
a constraint validator .
a new ConstraintValidator .
getMatchingAccessibleMethod ( final Class < ? > cls ) { return null ; }
public CompletionStage < Result > onClientError ( RequestHeader request , int statusCode , String message ) { if ( statusCode == 400 ) { return onBadRequest ( request , message ) ; } else if ( statusCode == 403 ) { return onForbidden ( request , message ) ; } else if ( statusCode == 404 ) { return onNotFound ( request , message ) ; } else if ( statusCode >= 400 && statusCode < 500 ) { return onClientError ( request , statusCode , message ) ; } else if ( statusCode >= 400 && statusCode < 500 ) { return onClientError ( request , statusCode , message ) ; } else { throw new IllegalArgumentException ( " onClientError invoked with non client error status code " + statusCode + " : " + message ) ; } }
a bad request .
( RequestHeader request ) { return CompletableFuture . completedFuture ( Results . forbidden ( views . html . defaultpages . unauthorized . render ( request . asScala ( ) ) ) ) ; }
the default page for the request .
( RequestHeader request , Throwable exception ) { try { UsefulException usefulException = throwableToUsefulException ( exception ) ; logServerError ( request , usefulException ) ; switch ( environment . mode ( ) ) { case PROD : return onProdServerError ( request , usefulException ) ; default : return onDevServerError ( request , usefulException ) ; } } catch ( Exception e ) { logger . error ( " Error while handling error " , e ) ; return CompletableFuture . completedFuture ( Results . internalServerError ( ) ) ; } }
the server error .
throwableToUsefulException ( final Throwable throwable ) { return HttpErrorHandlerExceptions . throwableToUsefulException ( sourceMapper . sourceMapper ( ) , environment , throwable ) ; }
onDevServerError ( RequestHeader request ) { return CompletableFuture . completedFuture ( Results . internalServerError ( views . html . defaultpages . devError . render ( playEditor , exception , request . asScala ( ) ) ) ) ; }
( RequestHeader request ) { }
fromResources ( File [ ] files , String [ ] baseDirs ) throws IOException { assert ( files . length == baseDirs . length ) ; FileRepository [ ] repositories = new FileRepository [ files . length ] ; List < JarFile > jarFiles = new ArrayList < > ( ) ; for ( int i = 0 ; i < files . length ; i ++ ) { File file = files [ i ] ; String baseDir = baseDirs [ i ] ; if ( file . isDirectory ( ) ) { repositories [ i ] = new FilesystemRepository ( file ) ; } else { JarFile jarFile = new JarFile ( file ) ; jarFiles . add ( jarFile ) ; repositories [ i ] = new JarRepository ( jarFile , Option . apply ( baseDir ) ) ; } } return new DocumentationHandler ( new AggregateFileRepository ( repositories ) , this ) ; }
fromDirectory ( File directory ) { FileRepository repo = new FilesystemRepository ( directory ) ; return new DocumentationHandler ( repo ) ; }
fromDirectoryAndJar ( File directory , JarFile jarFile , String base ) { return fromDirectoryAndJar ( directory , jarFile , base , false ) ; }
fromDirectoryAndJar ( File directory , JarFile jarFile , String base , boolean fallbackToJar ) { FileRepository fileRepo = new FilesystemRepository ( directory ) ; FileRepository jarRepo = new JarRepository ( jarFile , Option . apply ( base ) ) ; FileRepository manualRepo ; if ( fallbackToJar ) { manualRepo = new AggregateFileRepository ( new FileRepository [ ] { fileRepo , jarRepo } ) ; } else { manualRepo = fileRepo ; } return new DocumentationHandler ( manualRepo , jarRepo ) ; }
fromJar ( JarFile jarFile , String base ) { FileRepository repo = new JarRepository ( jarFile , Option . apply ( base ) ) ; return new DocumentationHandler ( repo ) ; }
( Materializer mat ) { return dataStream ( ) . runFold ( ByteString . empty ( ) , ByteString :: concat , mat ) ; }
the content to a string .
static final HttpEntity fromString ( String content , String charset ) { return new Strict ( ByteString . fromString ( content , charset ) , Optional . of ( " text / plain " ) ) ; }
a chunked HttpEntity .
static Result status ( int status ) { return status ( status , content , JsonEncoding . UTF8 ) ; }
the status of the given content .
the status of the request .
the status of the content .
static Result status ( int status ) { return status ( status , content , StaticFileMimeTypes . fileMimeTypes ( ) ) ; }
the user from the given id .
preferred ( Collection < Lang > candidates ) { return new Lang ( langs . preferred ( ( scala . collection . immutable . Seq ) Scala . asScala ( candidates ) ) ) ; }
unique ( ) { return new play . api . mvc . Call ( ) ; }
withFragment ( String fragment ) { return new Call ( method ( ) , url ( ) , fragment ) ; }
the absolute URL of the request .
webSocketURL ( Http . Request request ) { return webSocketURL ( request ) ; }
< Connection , BoxedUnit > connectionFunction ( final ConnectionRunnable block ) { return new AbstractFunction1 < Connection , BoxedUnit > ( ) { public BoxedUnit apply ( Connection connection ) { try { block . run ( connection ) ; return BoxedUnit . UNIT ; } catch ( java . sql . SQLException e ) { throw new RuntimeException ( " Connection runnable failed " , e ) ; } } } ; }
< Connection , A > connectionFunction ( final ConnectionCallable < A > block ) { return new AbstractFunction1 < Connection , A > ( ) { public A apply ( Connection connection ) { try { return block . call ( connection ) ; } catch ( java . sql . SQLException e ) { throw new RuntimeException ( " Connection callable failed " , e ) ; } } } ; }
forRouter ( Mode mode , int port , Function < BuiltInComponents , Router > block ) { return new Builder ( ) . mode ( mode ) . http ( port ) . build ( block ) ; }
toJson ( final Object data ) { try { return mapper ( ) . valueToTree ( data ) ; } catch ( Exception e ) { throw new RuntimeException ( e ) ; } }
a JsonNode to a JSON object .
( String src ) { try { return mapper ( ) . readTree ( src ) ; } catch ( Throwable t ) { throw new RuntimeException ( t ) ; } }
the input stream into a JsonNode .
the relative path of the current directory .
the canonical url .
displayableConstraint ( Set < ConstraintDescriptor < ? > > constraints ) { return constraints . parallelStream ( ) . filter ( c -> c . getAnnotation ( ) . annotationType ( ) . isAnnotationPresent ( Display . class ) ) . map ( c -> displayableConstraint ( c ) ) . toList ( ) ; }
displayableConstraint ( ConstraintDescriptor < ? > constraint ) { final Display displayAnnotation = constraint . getAnnotation ( ) . annotationType ( ) . getAnnotation ( Display . class ) ; return Tuple ( displayAnnotation . name ( ) , Collections . unmodifiableList ( Stream . of ( displayAnnotation . attributes ( ) ) . map ( attr -> constraint . getAttributes ( ) . get ( attr ) ) . collect ( Collectors . toList ( ) ) ) ) ; }
< A > timeout ( final CompletionStage < A > stage , final long amount , final TimeUnit unit ) { requireNonNull ( stage , " Null stage " ) ; requireNonNull ( unit , " Null unit " ) ; FiniteDuration duration = FiniteDuration . apply ( amount , unit ) ; return toJava ( delegate . timeout ( duration ) ) ; }
< ? > [ ] isAssignable ( Class < ? > [ ] classArray , Class < ? > [ ] toClassArray , boolean autoboxing ) { if ( arrayGetLength ( classArray ) != arrayGetLength ( toClassArray ) ) { return false ; } if ( classArray == null ) { classArray = EMPTY_CLASS_ARRAY ; } if ( toClassArray == null ) { toClassArray = EMPTY_CLASS_ARRAY ; } for ( int i = 0 ; i < classArray . length ; i ++ ) { if ( isAssignable ( classArray [ i ] , toClassArray [ i ] , autoboxing ) == false ) { return false ; } } return classArray ; }
( String cron ) { try { return new CronExpression ( cron ) . getNextValidTimeAfter ( new Date ( ) ) ; } catch ( Exception e ) { throw new IllegalArgumentException ( " Invalid CRON pattern : " + cron , e ) ; } }
the next interval of a cron expression .
a new AhcWSClient .
builder ( ) { return new GuiceApplicationBuilder ( ) ; }
( Request request ) { return status ( NOT_IMPLEMENTED , views . html . defaultpages . todo . render ( request ) ) ; }
public static void setSession ( String key , String value ) { session ( ) . put ( key , value ) ; }
static void flash ( String key , String value ) { flash ( ) . put ( key , value ) ; }
a BindingKey < T > qualified with the given instance .
< T > qualifiedWith ( final Class < A > annotation ) { return underlying . qualifiedWith ( annotation ) . asJava ( ) ; }
< T > to ( final Class < ? extends T > implementation ) { return underlying . to ( implementation ) . asJava ( ) ; }
< T > to ( final Provider < ? extends T > provider ) { return underlying . to ( provider ) . asJava ( ) ; }
< T > to ( final Supplier < A > instance ) { return underlying . to ( new FromJavaSupplier < > ( instance ) ) . asJava ( ) ; }
to ( final BindingKey < ? extends T > key ) { return underlying . to ( key ) . asJava ( ) ; }
< T > toProvider ( final Class < P > provider ) { return underlying . toProvider ( provider ) . asJava ( ) ; }
< Lang > availables ( Application app ) { play . api . i18n . Langs langs = app . injector ( ) . instanceOf ( play . api . i18n . Langs . class ) ; List < play . api . i18n . Lang > availableLangs = Scala . asJava ( langs . availables ( ) ) ; return availableLangs ; }
preferred ( Application app ) { return new Lang ( ) ; }
the evolutions from the database .
the evolutions from the database .
evolutions .
a config from the given environment .
the GuiceApplicationBuilder .
GuiceApplicationBuilder load ( GuiceableModule ... modules ) { return newBuilder ( delegate . load ( Scala . varargs ( modules ) ) ) ; }
the GuiceApplicationBuilder .
GuiceApplicationBuilder load ( Module ... modules ) { return load ( Guiceable . modules ( modules ) ) ; }
GuiceApplicationBuilder load ( ) { return new GuiceApplicationBuilder ( ) ; }
newBuilder ( ) { return new GuiceApplicationBuilder ( ) ; }
the cookie .
em ( ) { return this . emStack ( false ) . peekFirst ( ) ; }
a Deque < EntityManager > .
a new EntityManager onto the stack .
bypassWith ( Function < In , Out > splitter , Flow < FlowIn , Out > flow ) { return bypassWith ( splitter , flow ) ; }
the given flow .
a Flow < In , Out , ? > .
a list of arguments to a list of errors .
a form with a value .
< ValidationError > globalErrors ( ) { return Collections . unmodifiableList ( errors ) ; }
a list of all errors as json .
Optional < Object > value ( String key ) { return value ( key ) ; }
a dynamic form .
( String text , Class < T > clazz ) { return conversion . convert ( text , clazz ) ; }
( Field field , String text ) { return parse ( field , text , new TypeDescriptor ( field ) ) ; }
a string .
< T > print ( Field field , T t ) { return print ( new TypeDescriptor ( field ) , t ) ; }
a String to a String .
an Optional to a String .
register ( final Class < T > clazz , final SimpleFormatter < T > formatter ) { conversion . addFormatterForFieldType ( clazz , new org . springframework . format . Formatter < T > ( ) { public T parse ( String text , Locale locale ) throws java . text . ParseException { return formatter . parse ( text , locale ) ; } public String print ( T t , Locale locale ) { return formatter . print ( t , locale ) ; } public String toString ( ) { return formatter . toString ( ) ; } } ) ; return this ; }
register ( final Class < T > clazz , final AnnotationFormatter < A , T > formatter ) { final Class < ? extends Annotation > annotationType = ( Class < ? extends Annotation > ) GenericTypeResolver . resolveTypeArguments ( formatter . getClass ( ) , AnnotationFormatter . class ) [ 0 ] ; conversion . addConverter ( new ConditionalGenericConverter ( ) { Set < GenericConverter . ConvertiblePair > types = new HashSet < > ( ) ; types . add ( new GenericConverter . ConvertiblePair ( clazz , String . class ) ) ; return types ; } public boolean matches ( TypeDescriptor sourceType , TypeDescriptor targetType ) { return ( targetType . getAnnotation ( annotationType ) != null ) ; } }
a cookie .
static NodeList selectNodes ( String path , Object node ) { return selectNodes ( path , node , null ) ; }
a scala . collection . immutable . Seq to a scala . collection . immutable . Seq .
static < T > Seq toSeq ( T [ ] array ) { return toSeq ( java . util . Arrays . asList ( array ) ) ; }
static < T > Seq < T > varargs ( T ... array ) { return toSeq ( array ) ; }
< In , Out > json ( Class < In > in ) { return new MappedWebSocketAcceptor < > ( Scala . partialFunction ( message -> { try { if ( message instanceof Message . Binary ) { return F . Either . Left ( play . libs . Json . mapper ( ) . readValue ( ( ( Message . Binary ) message ) . data ( ) . iterator ( ) . next ( ) , in ) ) ; } else if ( message instanceof Message . Text ) { return F . Either . Right ( play . libs . Json . mapper ( ) . readValue ( ( ( Message . Text ) message ) . data ( ) . iterator ( ) . next ( ) , in ) ) ; } else if ( message instanceof Message . Close ) { return F . Either . Right ( play . libs . Json . mapper ( ) . readValue ( ( ( Message . Close ) message ) . data ( ) , in ) ) ; } else if ( message instanceof Message
acceptOrResult ( PartialFunction < Message , F . Either < In , Out , ? > > inMapper , Function < Http . RequestHeader , CompletionStage < F . Either < Result , Flow < In , Out , ? > > > > f , Function < Out , Message > outMapper ) { return new WebSocket ( ) { @ Override public CompletionStage < F . Either < Result , Flow < Message , Message , ? > > > apply ( Http . RequestHeader request ) { return f . apply ( request ) . thenApply ( resultOrFlow -> { if ( resultOrFlow . left . isPresent ( ) ) { return F . Either . Left ( resultOrFlow . left . get ( ) ) ; } else { Flow < Message , Message , ? > flow = AkkaStreams . bypassWith ( Flow . < Message > create ( ) . collect ( inMapper ) , play . api . libs . streams . AkkaStreams . onlyFirstCanFinishMerge
true if the object is accessible .
the primitive promotion cost .
the total transformation cost for a given executable .
the object transformation cost of the given class .
the message at the given key .
the message at the given keys .
a new Database .
a new ParallelSorter .
( int index ) { this . index = index ; }
( int index , int lo , int hi , Comparator cmp ) { chooseComparer ( index , cmp ) ; super . mergeSort ( lo , hi - 1 ) ; }
the Protected method .
a numeric type to a numeric type .
( int index ) { load_local ( state . argumentTypes [ index ] , state . localOffset ) ; }
( int opcode , Type ctype , String name , Type ftype ) { mv . visitFieldInsn ( opcode , ctype . getInternalName ( ) , name , ftype . getDescriptor ( ) ) ; }
( Type type ) { if ( TypeUtils . isPrimitive ( type ) ) { if ( type . getSort ( ) == Type . DOUBLE ) { push ( 0d ) ; } else if ( type . getSort ( ) == Type . LONG ) { push ( 0L ) ; } else if ( type . getSort ( ) == Type . FLOAT ) { push ( 0f ) ; } else if ( type . getSort ( ) == Type . DOUBLE ) { push ( 0d ) ; } else if ( type . getSort ( ) == Type . LONG ) { push ( 0L ) ; } else if ( type . getSort ( ) == Type . FLOAT ) { push ( 0f ) ; } else if ( type . getSort ( ) == Type . DOUBLE ) { push ( 0d ) ; } else if ( type . getSort ( ) == Type . LONG ) { push ( 0L ) ; } else { push ( 0L ) ; } } else
the given type .
an array .
the value of oneNull or bothNull .
all the bridges of the given class .
static void getMethods ( Class superclass , List methods ) { getMethods ( superclass , interfaces , methods , null , null ) ; }
all visible constructors .
the superclass of the object .
the field names .
a method to a list of exceptions .
the cardinality of the value .
the naming policy .
[ ] findMethods ( String [ ] namesAndDescriptors ) { Map map = new HashMap ( ) ; for ( int i = 0 ; i < methods . length ; i ++ ) { Method method = methods [ i ] ; map . put ( method . getName ( ) + Type . getMethodDescriptor ( method ) , method ) ; } return map . values ( ) ; }
the path of the given child .
a string from the given path .
the host of the HttpRequest .
a new HttpRequest ( ) { return new HttpRequest ( ) ; }
to the destination .
static HttpRequest get ( final String destination ) { return new HttpRequest ( ) . method ( HttpMethod . GET ) . set ( destination ) ; }
a POST request to the destination .
static HttpRequest put ( final String destination ) { return new HttpRequest ( ) . method ( HttpMethod . PUT ) ; }
static HttpRequest patch ( final String destination ) { return new HttpRequest ( ) . method ( HttpMethod . PATCH ) . set ( destination ) ; }
static HttpRequest delete ( final String destination ) { return new HttpRequest ( ) . method ( HttpMethod . DELETE ) . set ( destination ) ; }
static HttpRequest head ( final String destination ) { return new HttpRequest ( ) . method ( HttpMethod . HEAD ) . set ( destination ) ; }
static HttpRequest trace ( final String destination ) { return new HttpRequest ( ) . method ( HttpMethod . TRACE ) . set ( destination ) ; }
static HttpRequest options ( final String destination ) { return new HttpRequest ( ) . method ( HttpMethod . OPTIONS ) . set ( destination ) ; }
the path of the request .
the cookies of the given request .
the query for the given name .
a query to the queryMap .
the query string .
the query string .
the url of the specified host .
authentication .
( ) { String hostPort = this . host ; if ( port != Defaults . DEFAULT_PORT ) { hostPort += StringPool . COLON + port ; } headerOverwrite ( HEADER_HOST , hostPort ) ; return this ; }
a buffer of the given request .
a message to the server .
the first handler from the given range .
the length of the exception table .
the action interceptors .
all filters .
the action results .
all action runtimes .
( final BeanProperty bp , final boolean isSilent ) { if ( isSilent ) { return ; } throw new BeanException ( " Simple property not found : " + bp . name ) ; }
the index property of the bean .
( final String propertyName ) { int ndx = StringUtil . indexOfChars ( propertyName , INDEX_CHARS ) ; if ( ndx == - 1 ) { return propertyName ; } return propertyName . substring ( 0 , ndx ) ; }
the writer .
the object reference .
the object reference for the given name .
the object reference .
the table descriptor for the given tableRef .
( String columnRef ) { for ( Map . Entry < String , TableRefData > entry : tableRefs . entrySet ( ) ) { DbEntityDescriptor ded = entry . getValue ( ) . desc ; if ( ded . findByPropertyName ( columnRef ) != null ) { return ded ; } } return null ; }
the table alias .
a table reference .
the table descriptor from the given tableRef .
a hint .
a value .
the attributes to the target .
the parameters to the target .
the uploaded files to the target .
( final String propertyName , final boolean uppercase , final boolean splitCamelCase ) { final StringBuilder tableName = new StringBuilder ( propertyName . length ( ) * 2 ) ; if ( splitCamelCase ) { String convertedTableName = Format . fromCamelCase ( propertyName , separatorChar ) ; tableName . append ( convertedTableName ) ; } return tableName . toString ( ) ; }
the column name to a property name .
a column name to a property name .
the value to the database .
the value of the given type .
a set of all wrappers .
a wrapper for a given class .
a wrapper class .
the path separators to the system .
the path of the given filename .
the filename into a string .
the relative path of the target .
a madvoc component .
public < A extends ActionConfig > WebApp withActionConfig ( final Class < A > actionConfigType ) { withRegisteredComponent ( ActionConfigManager . class , acm -> acm . with ( actionConfigType , actionConfigConsumer ) ) ; return this ; }
the Madvoc WebApp .
the ActionConfigManager .
Madvoc WebApp components .
excludeJars ( final String ... excludedJars ) { for ( final String excludedJar : excludedJars ) { rulesJars . exclude ( excludedJar ) ; } return this ; }
ClassScanner includeJars ( final String ... includedJars ) { for ( final String includedJar : includedJars ) { rulesJars . include ( includedJar ) ; } return this ; }
ClassScanner includeEntries ( final String ... includedEntries ) { for ( final String includedEntry : includedEntries ) { rulesEntries . include ( includedEntry ) ; } return this ; }
ClassScanner excludeEntries ( final String ... excludedEntries ) { for ( final String excludedEntry : excludedEntries ) { rulesEntries . exclude ( excludedEntry ) ; } return this ; }
a zip file .
the class files from the root .
the bytecode signature of the given type .
scan ( final String ... paths ) { for ( final String path : paths ) { filesToScan . add ( new File ( path ) ) ; } return this ; }
a JAR file .
JtxTransaction createNewTransaction ( final JtxTransactionMode tm , final Object scope ) { return new DbJtxTransaction ( this , tm , scope , active ) ; }
( final Class < S > scopeClass ) { if ( scopeClass == null ) { return ( S ) getOrInitScope ( RequestScope . class ) ; } return ( S ) getOrInitScope ( scopeClass ) ; }
a new MadvocScope .
the MadvocScope for the given scope .
a string into a byte array .
( final HttpSession session , final int timeToLive ) { Set < Token > tokenSet = ( Set < Token > ) session . getAttribute ( CSRF_TOKEN_SET ) ; if ( tokenSet == null ) { tokenSet = new HashSet < > ( ) ; session . setAttribute ( CSRF_TOKEN_SET , tokenSet ) ; } return tokenSet ; }
the expired token from the set .
( final HttpSession session , final String tokenValue ) { Set < Token > tokenSet = ( Set < Token > ) session . getAttribute ( CSRF_TOKEN_SET ) ; if ( tokenSet == null && ( tokenValue == null ) ) { return false ; } if ( tokenSet . isEmpty ( ) && ( tokenValue == null ) ) { return false ; } if ( tokenSet . isEmpty ( ) && ( tokenValue == null ) ) { return false ; } if ( tokenSet . isEmpty ( ) && ( tokenValue == null ) ) { return false ; } if ( tokenSet . isEmpty ( ) && ( tokenValue == null ) ) { return false ; } if ( tokenSet . isEmpty ( ) && ( tokenValue == null ) ) { return false ; } if ( tokenSet . isEmpty ( ) && ( tokenValue == null ) ) { return false ; } if ( tokenSet . isEmpty ( ) && ( tokenValue == null )
a new BeanCopy from the source .
BeanUtil beanUtil = new BeanUtilBean ( ) ; return beanUtil ; }
the property value .
a table reference to the entity .
Petite scope .
a Petite bean .
a bean with the given name .
the bean from the registry .
the bean names of the given type .
a CtorInjectionPoint .
a property injection point .
a set injection point .
a method injection point .
( final String beanName , final InitMethodInvocationStrategy invocationStrategy , final String ... initMethodNames ) { BeanDefinition beanDefinition = lookupExistingBeanDefinition ( beanName ) ; ClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( beanDefinition . type ) ; if ( cd == null ) { throw new PetiteException ( " Init method not found : " + beanDefinition . type . getName ( ) + ' # ' + beanDefinition . type . getName ( ) ) ; } if ( initMethodNames == null ) { initMethodNames = StringPool . EMPTY_ARRAY ; } int total = initMethodNames . length ; InitMethodPoint [ ] initMethodPoints = new InitMethodPoint [ total ] ; int i ; for ( i = 0 ; i < initMethodNames . length ; i ++ ) { MethodDescriptor md = cd . getMethodDescriptor ( initMethodNames [ i ] , ClassUtil . EMPTY_CLASS_ARRAY , true ) ;
PetiteDestroyMethods .
a provider .
a Petite provider .
( final Class type ) { forEachBean ( bd -> { if ( ClassUtil . isTypeOf ( bd . type , type ) ) { beanNameConsumer . accept ( bd . name ) ; } } ) ; }
defineParameters ( final Map < ? , ? > properties ) { for ( Map . Entry < ? , ? > entry : properties . entrySet ( ) ) { defineParameter ( entry . getKey ( ) . toString ( ) , entry . getValue ( ) ) ; } }
the intercept method .
the Java version number .
an int to the stack .
if the argument index is valid .
adviceFieldName ( final String name ) { return ProxettaNames . adviceFieldName ( name ) ; }
adviceMethodName ( final String name , final int index ) { return ProxettaNames . adviceMethodName ( name , index ) ; }
( final MethodVisitor mv , final MethodInfo methodInfo ) { loadSpecialMethodArguments ( mv , methodInfo ) ; }
( final MethodVisitor mv , final MethodInfo methodInfo ) { loadStaticMethodArguments ( mv , methodInfo ) ; }
( final MethodVisitor mv ) { for ( int i = 1 ; i <= methodInfo . getArgumentsCount ( ) ; i ++ ) { loadMethodArgument ( mv , methodInfo , i ) ; } }
the method argument .
the argument of the method .
( final MethodVisitor mv ) { mv . visitInsn ( ACONST_NULL ) ; mv . visitInsn ( ACONST_NULL ) ; mv . visitInsn ( ACONST_NULL ) ; mv . visitInsn ( ACONST_NULL ) ; mv . visitInsn ( ACONST_NULL ) ; }
a key for the method signature .
a new array .
the array into an array .
the encoding of the given contentType .
the flags .
the token from the request .
authentication for the given realm .
the downloaded file .
the response .
all cookies from the request .
the request body .
the body of the request .
the context path of the current page .
the context path .
a query parameter .
the parameters for the request .
( final HttpServletRequest servletRequest , final boolean treatEmptyParamsAsNull , final boolean ignoreEmptyRequestParams ) { if ( treatEmptyParamsAsNull && ignoreEmptyRequestParams ) { return ; } if ( ! ( servletRequest instanceof MultipartRequestWrapper ) ) { return ; } MultipartRequestWrapper multipartRequest = ( MultipartRequestWrapper ) servletRequest ; if ( ! multipartRequest . isMultipart ( ) ) { return ; } if ( treatEmptyParamsAsNull && ignoreEmptyRequestParams ) { return ; } if ( ignoreEmptyRequestParams ) { return ; } if ( treatEmptyParamsAsNull && ignoreEmptyRequestParams ) { return ; } if ( treatEmptyParamsAsNull && ignoreEmptyRequestParams ) { return ; } if ( treatEmptyParamsAsNull && ignoreEmptyRequestParams ) { return ; } if ( treatEmptyParamsAsNull && ignoreEmptyRequestParams ) { return ; } if ( treatEmptyParamsAsNull && ignoreEmptyRequestParams ) {
the body of the tag .
( final JspFragment body ) throws JspException { FastCharArrayWriter writer = new FastCharArrayWriter ( ) ; invokeBody ( body , writer ) ; }
( final JspFragment body ) throws JspException { char [ ] result = renderBody ( body ) ; return new String ( result ) ; }
the init methods of the bean .
the destroy method .
a new bean instance .
the parameters to the bean .
String rewrite ( final HttpServletRequest servletRequest , final String actionPath , final String httpMethod ) { return rewrite ( servletRequest , actionPath , httpMethod , null ) ; }
a header to the response .
a new PropsEntry to the map .
a base property .
a profile property .
the profile property .
the value of the specified macro .
a map from a given profile .
the word from a byte array .
( String password , String salt ) { if ( salt . charAt ( 0 ) == ' $ ' ) { throw new IllegalArgumentException ( " Invalid salt version " ) ; } if ( salt . charAt ( 1 ) == ' $ ' ) { throw new IllegalArgumentException ( " Invalid salt revision " ) ; } if ( salt . charAt ( 2 ) == ' $ ' ) { throw new IllegalArgumentException ( " Invalid salt revision " ) ; } if ( salt . charAt ( 3 ) == ' $ ' ) { throw new IllegalArgumentException ( " Invalid salt revision " ) ; } if ( salt . charAt ( 4 ) == ' $ ' ) { throw new IllegalArgumentException ( " Invalid salt revision " ) ; } if ( salt . charAt ( 5 ) == ' $ ' ) { throw new IllegalArgumentException ( " Invalid salt revision " ) ; } if ( salt . charAt ( 6 ) == ' $ ' ) { throw new IllegalArgumentException ( " Invalid salt revision " ) ; }
if the hashed plaintext is equal to the hashed plaintext .
all bytes to the output stream .
max bytes to the output stream .
the action definition .
the action config for the given annotation .
an alias for a method .
a list of intercepted actions .
the action filters .
package action path .
the method action path .
the alias of the method .
a new ActionRuntime for the given action .
the last modified date .
advice to the target class .
the target into the proxy .
AnnotationVisitor visitAnnotation ( String descriptor , boolean visible ) { if ( fv != null ) { return fv . visitAnnotation ( descriptor , visible ) ; } return null ; }
the real name of the given json .
the name of the given object .
lookupTypeData ( final Class type ) { TypeData typeData = typeDataMap . get ( type ) ; if ( typeData == null ) { if ( serializationSubclassAware ) { typeData = findSubclassTypeData ( type ) ; } if ( typeData == null ) { typeData = scanClassForAnnotations ( type ) ; typeDataMap . put ( type , typeData ) ; } } return typeData ; }
lookupTypeData ( Class type ) { TypeData typeData = typeDataMap . get ( type ) ; if ( typeData == null ) { typeData = scanClassForAnnotations ( type ) ; typeDataMap . put ( type , typeData ) ; } return typeData ; }
the subclass of the given type .
the name of the given type .
the real name of the given type .
the file content .
bootstrap methods .
the major version of the class .
a constant pool .
bootstrap methods to the output .
a constant fieldref .
a constant methodref .
a constant member reference .
a constant member reference .
a new entry to the constant pool .
a constant integer or float to the index .
a new entry to the constant pool .
a constant long or double .
a constant name and type to the constant pool .
a constant nameAndType tag .
a constantUtf8 tag to the constant pool .
a constantUtf8 tag .
a constant method handle .
a constant method handle .
a constant dynamic reference to the bootstrap method .
a constant invoke dynamic method .
a new entry to the constant pool .
a constant dynamic reference to a bootstrap method .
a constantUtf8 reference .
a constantUtf8 reference .
a bootstrap method .
a merged type .
the hash of the given name .
( ) { for ( int i = 0 ; i < entries . length ; i ++ ) { entries [ i ] = null ; } }
all the values of the given name .
< Map . Entry < String , V > > iterator ( ) { final MapEntry < String , V > [ ] e = { head . after } ; return new Iterator < Map . Entry < String , V > > ( ) { @ Override public boolean hasNext ( ) { return e [ 0 ] != head ; } @ Override @ SuppressWarnings ( " unchecked " ) public Map . Entry < String , V > next ( ) { if ( ! hasNext ( ) ) { throw new NoSuchElementException ( " No next ( ) entry in the iteration " ) ; } MapEntry < V > next = e [ 0 ] ; e [ 0 ] = e [ 0 ] . after ; return next ; } @ Override public void remove ( ) { throw new UnsupportedOperationException ( ) ; } } ; }
< Map . Entry < String , V > > entries ( ) { List < Map . Entry < String , V > > all = new LinkedList < > ( ) ; MapEntry < V > e = head . after ; while ( e != head ) { all . add ( e ) ; e = e . after ; } return all ; }
the minimum capacity of the buffer .
( final CharSequence csq , final int start , final int end ) { for ( int i = start ; i < end ; i ++ ) { append ( csq . charAt ( i ) ) ; } return this ; }
public AnnotationVisitor visitAnnotation ( final String desc , final boolean visible ) { AnnotationVisitor destAnn = methodVisitor . visitAnnotation ( desc , visible ) ; return new AnnotationVisitorAdapter ( destAnn ) ; }
( Tmd tmd ) { createFirstChainDelegate_Continue ( tmd ) ; for ( int p = 0 ; p < tmd . proxyData . length ; p ++ ) { createProxyMethod ( tmd . proxyData [ p ] ) ; } }
a proxy for a given method .
( final TargetMethodData tmd ) { methodVisitor . visitMethodInsn ( INVOKESPECIAL , wd . thisReference , tmd . firstMethodName ( ) , tmd . msign . getDescription ( ) , false ) ; }
( final String path ) { if ( path == null ) { return new Path ( ) ; } return new Path ( path ) ; }
the field to the alt path .
decora and madvoc .
the value of the target method .
all field descriptors .
a ProxettaBeanDefinition for the given type .
a JtxTransactionMode to a DbTransactionMode .
a property from the source .
void putAll ( Map t ) { for ( Object o : t . entrySet ( ) ) { if ( o instanceof Map . Entry ) { Map . Entry e = ( Map . Entry ) o ; put ( e . getKey ( ) , e . getValue ( ) ) ; } } }
( final Buffer buffer ) { if ( buffer . list . isEmpty ( ) ) { return buffer ; } list . addAll ( buffer . list ) ; size += buffer . size ; return this ; }
the contents of the FastByteBuffer to a file .
a FastByteBuffer to the output stream .
the bytes to the stream .
the value of the given key .
the integer from the map .
the value of the given key .
the value of the given key .
the float value from the map .
the value of the given key .
JsonObject put ( final String key , final String value ) { Objects . requireNonNull ( key ) ; Objects . requireNonNull ( value ) ; map . put ( key , value ) ; return this ; }
the given folder name .
[ ] receiveMessages ( final EmailFilter filter , final Flags flagsToSet , final Flags flagsToUnset ) throws MailException { return receiveMessages ( filter , flagsToSet , flagsToUnset ) ; }
email flags .
( final Folder folder ) { if ( folder != null ) { try { folder . close ( true ) ; } catch ( final MessagingException ignore ) { } } }
( String name ) { DbQueryNamedParameter p = rootNP ; while ( p != null ) { if ( p . equalsName ( name ) ) { return p ; } p = p . next ; } return null ; }
public String alias ( final String target ) { return StringPool . LEFT_CHEV . concat ( target ) . concat ( StringPool . RIGHT_CHEV ) ; }
a Violation .
a Violation to a Violation object .
the raw data for the given mimeOrExtension .
a downloadable file .
the target class .
the target class name .
the target class .
the target class .
a new proxy .
a proxy class .
a new Proxetta instance .
proxetta class in debug folder .
T from ( final String personalName , final String from ) { return from ( new EmailAddress ( personalName , from ) ) ; }
a new EmailAddress to the given email address .
T to ( final String personalName , final String to ) { return to ( new EmailAddress ( personalName , to ) ) ; }
to the given email address .
the cc of the given email address .
the text message .
a HTML message .
the header of the given name .
the value of the specified property .
a boolean value .
the value of the given name .
the value of the given name .
the resolved parameters for the given method .
a value to a path .
the value of the given alias .
the alias of the given value .
resolveResultPath ( String path , String value ) { if ( path == null || path . length ( ) == 0 ) { return new ResultPath ( path , value ) ; } if ( value == null || path . length ( ) == 0 ) { return new ResultPath ( path , value ) ; } if ( path . length ( ) == 0 ) { return new ResultPath ( path , value ) ; } if ( path . length ( ) == 0 ) { return new ResultPath ( path , value ) ; } if ( path . length ( ) == 0 ) { return new ResultPath ( path , value ) ; } if ( path . length ( ) == 0 ) { return new ResultPath ( path , value ) ; } if ( path . length ( ) == 0 ) { return new ResultPath ( path , value ) ; } if ( path . length ( ) == 0 ) { return new ResultPath ( path , value ) ; } if (
the result path .
( final String str ) { int slashNdx = str . lastIndexOf ( ' / ' ) ; int dotNdx = StringUtil . lastIndexOf ( str , ' . ' , str . length ( ) , slashNdx ) ; if ( dotNdx == - 1 ) { if ( slashNdx == - 1 ) { return - 1 ; } slashNdx ++ ; if ( slashNdx < str . length ( ) - 1 ) { dotNdx = slashNdx ; } else { dotNdx = - 1 ; } } return dotNdx ; }
( final String str ) { int slashNdx = str . lastIndexOf ( ' / ' ) ; slashNdx ++ ; return StringUtil . lastIndexOf ( str , ' . ' , str . length ( ) , slashNdx ) ; }
( final String str ) { int slashNdx = str . lastIndexOf ( ' / ' ) ; if ( slashNdx == - 1 ) { slashNdx = 0 ; } return str . indexOf ( ' . ' , slashNdx ) ; }
the last Camel word from the name .
the schema name of the given type .
the column name for the given property .
a threefish key .
x and y .
( final int j , final int d ) { if ( d % DEPTH_OF_D_IN_R == 0 ) { return this ; } if ( d % DEPTH_OF_D_IN_R == 1 ) { return this ; } if ( d % DEPTH_OF_D_IN_R == 2 ) { return this ; } if ( d % DEPTH_OF_D_IN_R == 0 ) { return this ; } if ( d % DEPTH_OF_D_IN_R == 0 ) { return this ; } if ( d % DEPTH_OF_D_IN_R == 1 ) { return this ; } if ( d % DEPTH_OF_D_IN_R == 2 ) { return this ; } return this ; }
the value to the ksd array .
the key .
a byte [ ] to a long [ ] .
a long [ ] .
any bounding characters from the string .
the path of the method .
a zlib file .
the file .
the file .
< String > listZip ( final File zipFile ) throws IOException { List < String > entries = new ArrayList < > ( ) ; ZipFile zip = new ZipFile ( zipFile ) ; Enumeration zipEntries = zip . entries ( ) ; while ( zipEntries . hasMoreElements ( ) ) { ZipEntry entry = ( ZipEntry ) zipEntries . nextElement ( ) ; String entryName = entry . getName ( ) ; entries . add ( entryName ) ; } return entries ; }
( final String zipFile , final String destDir , final String ... patterns ) throws IOException { unzip ( new File ( zipFile ) , new File ( destDir ) , patterns ) ; }
a zip file to a directory .
a new entry to the ZipOutputStream .
the field descriptor for the given name .
the property descriptor for the given name .
the request bundle name .
( final HttpSession session ) { if ( log . isDebugEnabled ( ) ) { log . debug ( " Locale stored to session : " + localeCode ) ; } Locale locale = Locale . forLanguageTag ( localeCode ) ; session . setAttribute ( SESSION_LOCALE_ATTR , locale ) ; }
the locale of the session .
the parameters for the given beanName .
profile ( final String ... profiles ) { if ( profiles == null ) { return this ; } for ( String profile : profiles ) { addProfiles ( profile ) ; } return this ; }
getLongLittleEndian ( final byte [ ] buf , final int offset ) { return ( ( long ) buf [ offset + 7 ] << 56 ) | ( ( buf [ offset + 6 ] & 0xffL ) << 48 ) | ( ( buf [ offset + 5 ] & 0xffL ) << 40 ) | ( ( buf [ offset + 4 ] & 0xffL ) << 32 ) | ( ( buf [ offset + 3 ] & 0xffL ) << 24 ) | ( ( buf [ offset + 2 ] & 0xffL ) << 16 ) | ( ( buf [ offset + 1 ] & 0xffL ) << 8 ) | ( ( buf [ offset ] & 0xffL ) ) ; }
the input stream .
the label from the bytecode .
the type annotation offset .
the element values .
( final int verificationTypeInfoOffset , final char [ ] charBuffer , final Label [ ] labels ) { int currentOffset = verificationTypeInfoOffset ; int tag = b [ currentOffset ++ ] & 0xFF ; if ( tag == Opcodes . OBJECT ) { frame [ currentOffset ++ ] = Opcodes . OBJECT ; } else if ( tag == Opcodes . OBJECT ) { frame [ currentOffset ++ ] = Opcodes . OBJECT ; } else if ( tag == Opcodes . OBJECT ) { frame [ currentOffset ++ ] = Opcodes . OBJECT ; } else { frame [ currentOffset ++ ] = Opcodes . OBJECT ; } }
( final int maxStringLength ) { char [ ] charBuffer = new char [ maxStringLength ] ; int currentAttributeOffset = getFirstAttributeOffset ( ) ; int [ ] currentBootstrapMethodOffsets = null ; for ( int i = readUnsignedShort ( currentAttributeOffset - 2 ) ; i > 0 ; -- i ) { String attributeName = readUTF8 ( currentAttributeOffset , charBuffer ) ; int attributeLength = readInt ( currentAttributeOffset + 2 ) ; currentAttributeOffset += 6 ; if ( Constants . BOOTSTRAP_METHODS . equals ( attributeName ) ) { currentBootstrapMethodOffsets = new int [ readUnsignedShort ( currentAttributeOffset ) ] ; int currentBootstrapMethodOffset = currentAttributeOffset + 2 ; for ( int j = 0 ; j < currentBootstrapMethodOffsets . length ; ++ j ) { currentBootstrapMethodOffsets [ j ] = currentBootstrapMethodOffset ; currentBootstrapMethodOffset += 4 + readUnsignedShort ( currentBootstrapMethodOffset
[ ] inspectConstructors ( ) { Class type = classDescriptor . getType ( ) ; Constructor [ ] ctors = type . getDeclaredConstructors ( ) ; CtorDescriptor [ ] defaultCtor = new CtorDescriptor [ ctors . length ] ; for ( int i = 0 ; i < ctors . length ; i ++ ) { Constructor ctor = ctors [ i ] ; CtorDescriptor ctorDescriptor = createCtorDescriptor ( ctor ) ; allCtors [ i ] = ctorDescriptor ; if ( ctorDescriptor . isDefault ( ) ) { defaultCtor = ctorDescriptor ; } } return allCtors ; }
getCtorDescriptor ( final Class [ ] args ) { ctors : for ( CtorDescriptor ctorDescriptor : allCtors ) { if ( ctorDescriptor . getParameters ( ) . length != args . length ) { continue ctors ; } for ( int j = 0 ; j < arg . length ; j ++ ) { if ( arg [ j ] != args [ j ] ) { continue ctors ; } } return ctorDescriptor ; } return null ; }
a Map < String , TransientBeanData > .
a request map .
a long array to a long array .
the DecoraManager and DecoraParser .
onFile ( final Consumer < File > fileConsumer ) { if ( consumers == null ) { consumers = Consumers . of ( fileConsumer ) ; } else { consumers . add ( fileConsumer ) ; } return this ; }
searchPath ( final URI searchPath ) { try { file = new File ( searchPath ) ; } catch ( Exception ex ) { throw new FindFileException ( " URI error : " + searchPath , ex ) ; } addPath ( file ) ; return this ; }
searchPath ( final URL searchPath ) { if ( searchPath == null ) { throw new FindFileException ( " URL error : " + searchPath ) ; } File file = new File ( searchPath ) ; if ( ! file . exists ( ) ) { throw new FindFileException ( " File not found : " + searchPath ) ; } return searchPath ; }
include ( final String ... patterns ) { for ( String pattern : patterns ) { rules . include ( pattern ) ; } return this ; }
exclude ( final String ... patterns ) { for ( String pattern : patterns ) { rules . exclude ( pattern ) ; } return this ; }
the path to the list .
< File > findAll ( ) { List < File > allFiles = new ArrayList < File > ( ) ; while ( ( file = nextFile ( ) ) != null ) { allFiles . add ( file ) ; } return allFiles ; }
the list of files from the specified path .
< File > iterator ( ) { return new Iterator < File > ( ) { private File nextFile ; @ Override public boolean hasNext ( ) { nextFile = nextFile ( ) ; return nextFile != null ; } @ Override public File next ( ) { if ( nextFile == null ) { throw new NoSuchElementException ( ) ; } return nextFile ; } @ Override public void remove ( ) { throw new UnsupportedOperationException ( ) ; } } ; }
resolveBeanWiringMode ( final Class type ) { PetiteBean petiteBean = ( ( Class < ? > ) type ) . getAnnotation ( PetiteBean . class ) ; return petiteBean != null ? petiteBean . wiring ( ) : WiringMode . DEFAULT ; }
the name of the petite bean .
the output writer .
the ServletOutputStream .
the class name of the object .
the descriptor of the constructor .
the method descriptor of the given argument type .
the method descriptor .
the descriptor to the value buffer .
the size of the array .
the arguments sizes of the given method .
( ) { if ( ! isNoTransaction ( ) ) { if ( ( status != STATUS_MARKED_ROLLBACK ) && ( status != STATUS_ACTIVE ) ) { throw new JtxException ( " TNo active TX that can be marked as rollback only " ) ; } } rollbackCause = th ; status = STATUS_MARKED_ROLLBACK ; }
or Rollback JTX .
all TX resources .
a new transaction for the given resource .
a name to the stack .
writeString ( final String value , final boolean strictStringEncoding ) throws IOException { write ( value ) ; if ( strictStringEncoding ) { write ( StringPool . QUOTE ) ; } else { write ( StringPool . QUOTE ) ; } }
a unicode string .
a string to the output stream .
( String logLevel ) { this . logLevel = logLevel . trim ( ) . toUpperCase ( ) ; parsingErrorLogLevel = Logger . Level . valueOf ( logLevel ) ; return this ; }
the region .
true if the value is contained in the given include .
a pseudo function .
the pseudo function from the given pseudo function name .
the proxy aspects of the given class .
public AnnotationVisitor visitAnnotation ( final String desc , final boolean visible ) { AnnotationVisitor destAnn = wd . dest . visitAnnotation ( desc , visible ) ; return new AnnotationVisitorAdapter ( destAnn ) ; }
a static init block .
a proxy constructor .
( ) { for ( ClassReader cr : targetClassInfo . superClassReaders ) { cr . accept ( new EmptyClassVisitor ( ) { String declaredClassName ; @ Override public void visit ( final int version , final int access , final String name , final String signature , final String [ ] exceptions ) { } @ Override public void visitMethod ( final int access , final String name , final String desc , final String signature , final String [ ] exceptions ) { } @ Override public MethodVisitor visitMethod ( final int access , final String name , final String desc , final String signature , final String [ ] exceptions ) { if ( name . equals ( INIT ) || name . equals ( CLINIT ) ) { return null ; } MethodSignatureVisitor msign = targetClassInfo . lookupMethodSignatureVisitor ( access , name , desc , declaredClassName ) ; if ( msign == null ) { return null ; } return applyProxy ( msign ) ; } } ) ; } }
the last element in the list .
the string from the given string .
asmInstructions ( final byte [ ] classFile )
the attributePrototypes .
whether a given integer is stored in the database .
a new SqlType class .
the type of the given type .
the SQL type of the given type .
socks4Proxy ( final String proxyAddress ) { return new ProxyInfo ( ProxyType . SOCKS4 , proxyAddress , proxyPort , null ) ; }
socks5Proxy ( final String proxyAddress ) { return new ProxyInfo ( ProxyType . SOCKS5 , proxyAddress , proxyPort , proxyUser , proxyPassword ) ; }
a ProxyInfo .
the total thread transactions .
the total thread transaction count of the given status .
a transaction to a given transaction .
the isolation level of the given transaction .
the resource manager for the given resource type .
a proxy object .
the methodName to the path .
left and right text .
toPrettyString ( final Object value ) { if ( value == null ) { return StringPool . NULL ; } final Class < ? > type = value . getClass ( ) ; if ( type . isArray ( ) ) { final Class componentType = type . getComponentType ( ) ; if ( componentType . isPrimitive ( ) ) { final StringBuilder sb = new StringBuilder ( ) ; sb . append ( ' [ ' ) ; if ( componentType == int . class ) { sb . append ( ArraysUtil . toString ( ( int [ ] ) value ) ) ; } else if ( componentType == long . class ) { sb . append ( ArraysUtil . toString ( ( long [ ] ) value ) ) ; } else if ( componentType == double . class ) { sb . append ( ArraysUtil . toString ( ( double [ ] ) value ) ) ; } else if ( componentType == float . class ) { sb . append ( ArraysUtil . toString ( ( float [ ] ) value ) ) ; }
a string to a camel case .
a paragraph .
tabs to spaces .
escapeJava ( final String string ) { if ( string == null ) { return null ; } if ( string . length ( ) == 0 ) { return string ; } if ( string . length ( ) == 1 ) { return string . substring ( 0 , string . length ( ) - 1 ) ; } if ( string . length ( ) == 1 ) { return string . substring ( 0 , string . length ( ) - 1 ) ; } if ( string . length ( ) == 1 ) { return string . substring ( 0 , string . length ( ) - 1 ) ; } if ( string . length ( ) == 1 ) { return string . substring ( 0 , string . length ( ) - 1 ) ; } if ( string . length ( ) == 1 ) { return string . substring ( 0 , string . length ( ) - 1 ) ; } if ( string . length ( ) == 2 ) { return string . substring ( 0 , string . length ( ) -
unescapeJava ( final String str ) { if ( str == null || str . length ( ) == 0 ) { return str ; } StringBuilder sb = new StringBuilder ( str . length ( ) ) ; for ( int i = 0 ; i < chars . length ; i ++ ) { char c = chars [ i ] ; if ( c != ' \ \' ) { sb . append ( c ) ; continue ; } i ++ ; c = chars [ i ] ; if ( c != ' \ \ ' ) { sb . append ( c ) ; continue ; } i ++ ; c = chars [ i ] ; if ( c != ' \ ' ) { sb . append ( c ) ; continue ; } i ++ ; c = chars [ i ] ; if ( c != ' \ ' ) { sb . append ( c ) ; continue ; } i ++ ; c = chars [ i ] ; if ( c != ' \ ' ) { sb . append ( ' \
getBean ( final Class < T > type ) { return getBean ( type ) ; }
the bean of the given name .
the properties of the bean .
the provider method .
a bean with the given name .
the bean property .
the bean property from the given name .
( ) { scopes . forEach ( Scope :: shutdown ) ; externalsCache . clear ( ) ; beansAlt . clear ( ) ; scopes . clear ( ) ; providers . clear ( ) ; beanCollections . clear ( ) ; }
[ ] resolveParameters ( final AccessibleObject methodOrCtor ) { if ( methodOrCtor instanceof Constructor ) { Constructor constructor = ( Constructor ) methodOrCtor ; paramTypes = constructor . getParameterTypes ( ) ; declaringClass = constructor . getDeclaringClass ( ) ; } else if ( methodOrCtor instanceof Method ) { Method method = ( Method ) methodOrCtor ; paramTypes = method . getParameterTypes ( ) ; declaringClass = method . getDeclaringClass ( ) ; } else if ( methodOrCtor instanceof Constructor ) { Constructor constructor = ( Constructor ) methodOrCtor ; paramTypes = constructor . getParameterTypes ( ) ; declaringClass = constructor . getDeclaringClass ( ) ; name = CTOR_METHOD ; } if ( paramTypes . length == 0 ) { return MethodParameter . EMPTY_ARRAY ; } return resolveParameters ( methodOrCtor ) ; }
the body of the page .
the value of the macro .
the LagartoDom tree .
createElementNode ( final Element rootNode , final Tag tag ) { boolean hasVoidTags = htmlVoidRules != null ; boolean isVoid = false ; if ( hasVoidTags ) { isVoid = htmlVoidRules . isVoidTag ( tag . getName ( ) ) ; if ( isVoid ) { selfClosed = domBuilder . config . isSelfCloseVoidTags ( ) ; } } else { selfClosed = domBuilder . config . isSelfCloseVoidTags ( ) ; } return new Element ( rootNode , tag , isVoid , selfClosed ) ; }
a new tag to the document .
the last child node from the parent .
query string .
the name of the action .
to the specified size .
through the collection .
through the array .
a string with a string .
a string with a given character .
all occurrences of a character in a string .
the first occurrence of a substring in a string .
the first occurrence of a substring .
the last occurrence of a substring in a string .
the last character of the string .
a substring from a string .
the characters from the string .
static boolean isAllEmpty ( final String ... strings ) { for ( String string : strings ) { if ( ! isEmpty ( string ) ) { return false ; } } return true ; }
static boolean isAllBlank ( final String ... strings ) { for ( String string : strings ) { if ( ! isBlank ( string ) ) { return false ; } } return true ; }
[ ] toStringArray ( final Object value ) { if ( value == null ) { return null ; } if ( value . getClass ( ) . isArray ( ) ) { return ArraysUtil . toStringArray ( ( Object [ ] ) value ) ; } if ( value . getClass ( ) . getComponentType ( ) . isPrimitive ( ) ) { return ArraysUtil . toStringArray ( ( Object [ ] ) value ) ; } if ( value . getClass ( ) . isArray ( ) ) { if ( componentType == int . class ) { return ArraysUtil . toStringArray ( ( int [ ] ) value ) ; } else if ( componentType == long . class ) { return ArraysUtil . toStringArray ( ( long [ ] ) value ) ; } else if ( componentType == double . class ) { return ArraysUtil . toStringArray ( ( double [ ] ) value ) ; } else if ( componentType == float . class ) { return ArraysUtil . toStringArray ( ( float [ ] ) value )
the first character of the string .
the title of the given string .
a String to a String .
true if the substring matches the specified substring .
endsWithChar ( final String s , final char c ) { if ( s . length ( ) == 0 ) { return false ; } return s . charAt ( s . length ( ) - 1 ) == c ; }
the number of occurrences of a given substring .
true if a string is equal to a given string .
the index of the string .
( final String string ) { if ( string . length ( ) > 0 ) { if ( string . charAt ( 0 ) == c ) { return string . substring ( 1 ) ; } } return string ; }
( final String string ) { if ( string . length ( ) > 0 ) { if ( string . charAt ( string . length ( ) - 1 ) == c ) { return string . substring ( 0 , string . length ( ) - 1 ) ; } } return string ; }
( final String string , final char c ) { if ( string . length ( ) == 0 ) { return string ; } if ( string . length ( ) == 1 ) { if ( string . charAt ( 0 ) == c ) { return StringPool . EMPTY ; } return string . substring ( 0 , string . length ( ) - 1 ) ; } if ( string . charAt ( 0 ) == c ) { return string . substring ( 0 , string . length ( ) - 1 ) ; } return string . substring ( 0 , string . length ( ) - 1 ) ; }
stripToChar ( final String string ) { if ( string . length ( ) == 0 ) { return string ; } return string . substring ( 0 , string . length ( ) - 1 ) ; }
a string from a given character .
the given string .
the string .
the string .
the index of the substring in the given string .
the collection .
the array with a separator .
a string to a charset .
if a string is equal to a given character .
the string surrounded by the prefix and suffix .
the prefix of the string .
the suffix of the given string .
the index of the substring .
the substring from the given string .
the prefix of the string .
the suffix from the string .
the substring of the given string .
a string into the specified offset .
a StringBand from the source .
the reverse string .
the longest common prefix .
( final String ... strings ) { if ( strings . length == 0 ) { return StringPool . EMPTY ; } if ( strings . length == 1 ) { return StringPool . EMPTY ; } if ( strings . length == 2 ) { return StringPool . EMPTY ; } if ( strings . length == 3 ) { for ( int i = 0 ; i < strings . length ; i ++ ) { String s = strings [ i ] ; if ( index == s . length ( ) ) { break loop ; } if ( i == 0 ) { c = s . charAt ( index ) ; } else { if ( s . charAt ( index ) != c ) { break loop ; } } } } return prefix . length ( ) == 0 ? StringPool . EMPTY : prefix . toString ( ) ; }
a shortened string .
( final String s , Locale locale ) { if ( s == null ) { return null ; } StringBuilder sb = null ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { char c = s . charAt ( i ) ; if ( c > 127 ) { if ( locale == null ) { locale = Locale . getDefault ( ) ; } return s . toUpperCase ( locale ) ; } if ( ( c >= ' a ' ) && ( c <= ' z ' ) ) { if ( sb == null ) { sb = new StringBuilder ( s ) ; } sb . setCharAt ( i , ( char ) ( c - 32 ) ) ; } } if ( locale == null ) { locale = Locale . getDefault ( ) ; } return s . toUpperCase ( locale ) ; }
quotes from string .
a byte array to a hex string .
a byte array .
( final String str ) { if ( str . length ( ) < 2 ) { return 0 ; } final char c = str . charAt ( 0 ) ; if ( c != str . charAt ( str . length ( ) - 1 ) ) { return 0 ; } if ( c == ' \ ' ' || c == ' " ' || c == ' ` ' ) { return c ; } return 0 ; }
void visit ( final String name , final Object value ) { if ( av != null ) { av . visit ( name , value ) ; } }
the type of the enum .
AnnotationVisitor visitAnnotation ( final String name , final String descriptor ) { if ( av != null ) { return av . visitAnnotation ( name , descriptor ) ; } return null ; }
a DbEntityDescriptor for the given type .
a new DbEntityDescriptor for the given type .
a DbEntityDescriptor .
a new entity instance .
setTargetInterface ( final Class targetInterface ) { if ( targetInterface . isInterface ( ) ) { throw new ProxettaException ( " Not an interface : " + targetInterface . getName ( ) ) ; } this . targetInterface = targetInterface ; return this ; }
the target into the wrapper .
the annotated properties of the given type .
database and configure dbOom .
the output stream .
to a closed output stream .
the session id from the request .
( String name ) { if ( name == null ) { return null ; } try { return MimeUtility . encodeText ( name ) ; } catch ( final UnsupportedEncodingException ueex ) { throw new MailException ( ueex ) ; } }
a byte array of the given size .
a file to the destination .
the input stream to the output stream .
the argument to the given desc .
( final String desc , final String type ) { int ndx = desc . indexOf ( ' ( ' ) ; ndx ++ ; return desc . substring ( 0 , ndx ) + type + desc . substring ( ndx ) ; }
( final String desc , final String type ) { int ndx = desc . indexOf ( ' ) ' ) ; return desc . substring ( 0 , ndx + 1 ) + type ; }
( final CharSequence text ) { if ( text == null || text . length ( ) == 0 || text . length ( ) == 0 || text . length ( ) == 0 || text . length ( ) == 0 || text . length ( ) == 0 || text . length ( ) == 0 || text . length ( ) == 0 || text . length ( ) == 0 || text . length ( ) == 0 || text . length ( ) == 0 ) { return text ; } int strippedCharsCount = 0 ; for ( int i = 0 ; i < textLength ; i ++ ) { char c = text . charAt ( i ) ; if ( CharUtil . isWhitespace ( c ) ) { regularChar = false ; c = ' ' ; } else { continue ; } } else { regularChar = true ; } dest [ ndx ] = c ; ndx ++ ; }
a type converter .
< T > lookup ( final Class < T > type ) { return converters . get ( type ) ; }
a CSS selector .
a list of selectors .
( final Node rootNode , final List < CssSelector > selectors ) { List < Node > selectedNodes = select ( rootNode , selectors ) ; for ( Node selectedNode : selectedNodes ) { if ( ! results . contains ( selectedNode ) ) { results . add ( selectedNode ) ; } } }
the first node from the given query .
( final LinkedList < Node > nodes , final CssSelector cssSelector , final List < Node > result ) { while ( ! nodes . isEmpty ( ) ) { Node node = nodes . removeFirst ( ) ; selectAndAdd ( node , cssSelector , result ) ; int childCount = node . getChildNodesCount ( ) ; for ( int i = childCount - 1 ; i >= 0 ; i -- ) { nodes . addFirst ( node . getChild ( i ) ) ; } } }
( final Node rootNode , final CssSelector cssSelector , final List < Node > result ) { if ( rootNode == null ) { return result ; } if ( cssSelector == null ) { return result ; } if ( cssSelector . getPrevCssSelector ( ) == null ) { return result ; } if ( cssSelector . getPrevCssSelector ( ) == null ) { return result ; } if ( cssSelector . getPrevCssSelector ( ) == null ) { return result ; } if ( cssSelector . getPrevCssSelector ( ) == null ) { return result ; } if ( cssSelector . getPrevCssSelector ( ) == null ) { return result ; } if ( cssSelector . getPrevCssSelector ( ) == null ) { return result ; } return result ; }
the element and adds it to the result .
the css selector .
a CMap .
true if the buffer is empty .
< T > page ( String sql , final Map params , final int page , final int pageSize , final String sortColumnName , final boolean ascending , final Class [ ] target ) { if ( sortColumnName != null ) { sql = buildOrderSql ( sql , sortColumnName , ascending ) ; } int from = ( page - 1 ) * pageSize ; String pageSql = buildPageSql ( sql , from , pageSize ) ; DbSqlBuilder dbsql = sql ( pageSql ) ; query = query ( dbsql ) ; query . setMap ( params ) ; return new PageData < > ( page , pageSize , list ) ; }
the select from the database .
from the given sql .
the last order by .
html to a string .
the name of the entity .
the order sql for the given column .
the page sql .
column mappings in entity .
the column descriptor for the given columnName .
the column descriptor for the given propertyName .
the propertyName of the column .
the name of the column .
the id value of the object .
( final E object , final Object value ) { final String propertyName = getIdPropertyName ( ) ; BeanUtil . declared . setProperty ( object , propertyName , value ) ; }
the key value .
a string to the array .
the index of the array .
( ) { String [ ] newArray = new String [ array . length << 1 ] ; System . arraycopy ( array , 0 , newArray , 0 , index ) ; array = newArray ; return newArray ; }
the length of the array .
a Mixing message .
a scoped proxy bean .
the body .
a list of files .
a file .
whether the watch file exists or not .
the Watcher .
a new DirWatcherEvent for the given file .
a new enumeration .
( SymbolTable symbolTable ) { int size = 0 ; if ( constantValueIndex != 0 ) { symbolTable . addConstantUtf8 ( Constants . CONSTANT_VALUE ) ; size += 8 ; } if ( ( accessFlags & Opcodes . ACC_SYNTHETIC ) != 0 && symbolTable . getMajorVersion ( ) < Opcodes . V1_5 ) { symbolTable . addConstantUtf8 ( Constants . SYNTHETIC ) ; size += 6 ; } if ( signatureIndex != 0 ) { symbolTable . addConstantUtf8 ( Constants . SIGNATURE ) ; size += 8 ; } if ( ( accessFlags & Opcodes . ACC_DEPRECATED ) != 0 ) { symbolTable . addConstantUtf8 ( Constants . DEPRECATED ) ; size += 6 ; } if ( lastRuntimeVisibleAnnotation != null ) { size += lastRuntimeVisibleAnnotation . computeAnnotationsSize ( Constants . RUNTIME_VISIBLE_ANNOTATIONS ) ; }
the runtime visible annotations .
static Target ofValue ( final Object value , final ScopeData scopeData ) { return new Target ( value , null , scopeData , null , VALUE_INSTANCE_CREATOR ) ; }
a value to the injection point .
the decorated page .
the page content .
decora tags to the decorated page .
decora tags to the output stream .
the server .
the output of the process .
getStore ( final Authenticator authenticator ) { if ( authenticator instanceof SimpleAuthenticator ) { return new IMAPSSLStore ( ( SimpleAuthenticator ) authenticator ) ; } return null ; }
createOutputStream ( ) throws IOException { GzipResponseStream gzstream = new GzipResponseStream ( origResponse ) ; gzstream . setBuffer ( threshold ) ; return gzstream ; }
the template data .
the column alias to the query .
( final StringBuilder query , final DbEntityDescriptor ded , final DbEntityColumnDescriptor dec ) { query . append ( ded . getTableNameForQuery ( ) ) . append ( ' . ' ) . append ( dec . getColumnNameForQuery ( ) ) ; if ( templateData . getColumnAliasType ( ) != null ) { query . append ( templateData . getColumnAliasType ( ) ) ; } }
a rule to the list of rules .
a rule to a given value .
( final V value , boolean include ) { if ( includesCount > 0 ) { for ( Rule < R > rule : rules ) { if ( ! rule . include ) { continue ; } if ( inExRuleMatcher . accept ( value , rule . value , true ) ) { include = true ; break ; } } } return include ; }
( final V value , final boolean include ) { if ( excludesCount > 0 ) { for ( Rule < R > rule : rules ) { if ( rule . include ) { continue ; } if ( inExRuleMatcher . accept ( value , rule . value , false ) ) { include = false ; break ; } } } return include ; }
the name of the class .
a new element to the collection .
( final E o ) { int low = 0 ; while ( low <= high ) { int mid = ( low + high ) >>> 1 ; int delta = compare ( get ( mid ) , o ) ; if ( delta > 0 ) { high = mid - 1 ; } else { low = mid + 1 ; } } return low ; }
a new ActionConfig to the given annotationType .
a new ActionConfig .
the action configuration for the given actionTypeOrAnnotationType .
a new ActionConfig with the specified actionConfigType .
the mail mime encodefilename and mail mime decodefilename properties .
( final ValidationContext vctx , final Object value , final String name ) { if ( value != null ) { validateWithin ( vctx , value , name ) ; } else { validateWithin ( vctx , null ) ; } }
the last table element .
the last table element .
session beans .
the session map .
the name of the target class .
( final String name ) { if ( adviceInits == null ) { adviceInits = new ArrayList < > ( ) ; } adviceInits . add ( name ) ; }
a new bundle .
a new profile to the specified section .
profiles from the given key .
a new profile property .
the name of the class .
the name of the type .
a string to a typedesc signature .
the type to a Typeref .
< T > addAll ( final Consumer < T > ... consumers ) { Collections . addAll ( consumerList , consumers ) ; return this ; }
a new collection .
a collection to a single element .
the value to a collection .
a collection to a collection .
a primitive array to a collection .
a new line number .
the line number of the method .
a forward reference to the sourceInsnBytecodeOffset .
a forward reference to the sourceInsnBytecode .
the code .
a subroutine .
( final Label subroutineCaller ) { addSubroutineRetSuccessors ( subroutineCaller ) ; }
the digits of the given str1 and str2 .
the accent character from the given string .
a byte at the end of the array .
a byte value into a ByteVector .
putShort ( final int shortValue ) { int currentLength = length ; if ( currentLength + 2 > data . length ) { enlarge ( 2 ) ; } byte [ ] currentData = data ; currentData [ currentLength ++ ] = ( byte ) ( shortValue >>> 8 ) ; currentData [ currentLength ++ ] = ( byte ) shortValue ; length = currentLength ; return this ; }
a byte value into a ByteVector .
a byte value in a ByteVector .
ByteVector putInt ( final int intValue ) { int currentLength = length ; if ( currentLength + 4 > data . length ) { enlarge ( 4 ) ; } byte [ ] currentData = data ; currentData [ currentLength ++ ] = ( byte ) ( intValue >>> 24 ) ; currentData [ currentLength ++ ] = ( byte ) ( intValue >>> 16 ) ; currentData [ currentLength ++ ] = ( byte ) ( intValue >>> 8 ) ; currentData [ currentLength ++ ] = ( byte ) ( intValue >>> 16 ) ; currentData [ currentLength ++ ] = ( byte ) ( intValue >>> 8 ) ; currentData [ currentLength ++ ] = ( byte ) intValue ; length = currentLength ; return this ; }
a byte value into a ByteVector .
putLong ( final byte [ ] data ) { if ( data == null || data . length == 0 ) { return new Long ( longValue ) ; } if ( data . length == 1 ) { return new Long ( longValue ) ; } if ( data . length == 2 ) { return new Long ( longValue ) ; } if ( data . length == 3 ) { return new Long ( longValue ) ; } return new Long ( longValue ) ; }
( final byte [ ] byteArrayValue , final int byteOffset , final int byteLength ) { if ( length + byteLength > data . length ) { enlarge ( byteLength ) ; } if ( byteArrayValue != null ) { System . arraycopy ( byteArrayValue , byteOffset , data , length , byteLength ) ; } }
the data .
the user .
a user via token .
the user .
the default message for the given key .
( final String bundleName , final Locale locale , final ClassLoader classLoader ) { return ResourceBundle . getBundle ( bundleName , locale , classLoader ) ; }
the index of the array .
setEntityId ( final DbEntityDescriptor < E > ded , final E entity , final ID newIdValue ) { ded . setIdValue ( entity , newIdValue ) ; }
the entity to the database .
the entity .
the property of the entity .
a property .
the id of the entity .
the properties of the given entity .
the entity from the given criteria .
( final Class entityType , final ID id ) { deleteById ( entityType , id ) ; }
the entity from the database .
the count of the given entityType .
( final Class entityType , final ID id , final String name , final Number delta ) { query ( dbOom . entities ( ) . increaseColumn ( entityType , id , name , delta , true ) ) . autoClose ( ) . executeUpdate ( ) ; }
( final Class entityType , final ID id , final String name , final Number delta ) { query ( dbOom . entities ( ) . increaseColumn ( entityType , id , name , delta , false ) ) . autoClose ( ) . executeUpdate ( ) ; }
( Class < E > target , Object source ) { return query ( dbOom . entities ( ) . findForeign ( target , source ) ) . autoClose ( ) . list ( target ) ; }
< E > listAll ( final Class < E > target ) { return query ( dbOom . entities ( ) . from ( target ) ) . autoClose ( ) . list ( target ) ; }
the attributes .
< Entry < String , Object > > entrySet ( ) { if ( entries == null ) { entries = new HashSet < > ( ) ; Iterator < String > iterator = getAttributeNames ( ) ; while ( iterator . hasNext ( ) ) { final String key = iterator . next ( ) ; final Object value = getAttribute ( key ) ; entries . add ( new Entry < String , Object > ( ) { @ Override public boolean equals ( final Object obj ) { if ( obj == null ) { return false ; } if ( this . getClass ( ) != obj . getClass ( ) ) { return false ; } if ( this . getClass ( ) != obj . getClass ( ) ) { return false ; } if ( this . getClass ( ) != obj . getClass ( ) ) { return false ; } if ( this . getClass ( ) != obj . getClass ( ) ) { return false ; } if ( this . getClass ( ) != obj . getClass ( ) ) { return false ; }
a new entry .
the key from the list .
the current stack trace .
the StackTraceElement [ ] of the Throwable .
StackTraceElement [ ] [ ] getStackTraceChain ( Throwable t , String [ ] allow , String [ ] deny ) { ArrayList < StackTraceElement [ ] > result = new ArrayList < > ( ) ; while ( t != null ) { StackTraceElement [ ] stack = getStackTraceChain ( t , allow , deny ) ; result . add ( stack ) ; t = t . getCause ( ) ; } return result ; }
the exception chain .
the stack trace of the exception .
the exception chain .
the message of the cause .
( final Throwable wrappedThrowable ) { if ( wrappedThrowable instanceof InvocationTargetException ) { unwrapped = ( ( InvocationTargetException ) unwrapped ) . getTargetException ( ) ; } else if ( wrappedThrowable instanceof UndeclaredThrowableException ) { unwrapped = ( ( UndeclaredThrowableException ) wrappedThrowable ) . getUndeclaredThrowable ( ) ; } else if ( wrappedThrowable instanceof InvocationTargetException ) { unwrapped = ( ( InvocationTargetException ) wrappedThrowable ) . getTargetException ( ) ; } else if ( wrappedThrowable instanceof UndeclaredThrowableException ) { unwrapped = ( ( UndeclaredThrowableException ) wrappedThrowable ) . getUndeclaredThrowable ( ) ; } else { return wrappedThrowable ; } }
the Madvoc component .
a Madvoc component class .
the ClassLoader .
( final String resourceName ) throws IOException { URL url = getResourceUrl ( resourceName , callingClass ) ; if ( url != null ) { return url . openStream ( ) ; } return null ; }
( final String resourceName , final ClassLoader callingClass ) throws IOException { URL url = getResourceUrl ( resourceName , callingClass ) ; if ( url != null ) { URLConnection urlConnection = url . openConnection ( ) ; urlConnection . setUseCaches ( useCache ) ; return urlConnection . getInputStream ( ) ; } return null ; }
the class from the classpath .
( final String className , final ClassLoader classLoader ) throws IOException { return getResourceAsStream ( ClassUtil . convertClassNameToFileName ( className ) , classLoader ) ; }
a RouteChunk to a RouteChunk .
( final String value ) { if ( children != null ) { for ( RouteChunk child : children ) { if ( child . get ( ) . equals ( value ) ) { return child ; } } } return null ; }
the request .
the value to a collection .
the value to a collection .
the value of the array .
a new bean property .
the type of a BeanProperty .
the session .
a cookie to the request .
toDate ( final LocalDate localDate ) { return Date . from ( localDate . atStartOfDay ( ZoneId . systemDefault ( ) ) . toInstant ( ) ) ; }
static Calendar toCalendar ( final LocalDateTime localDateTime ) { return GregorianCalendar . from ( ZonedDateTime . of ( localDateTime , ZoneId . systemDefault ( ) ) ) ; }
defineProxy ( final Class target ) { ProxyProxettaFactory builder = proxetta . proxy ( ) ; builder . setTarget ( target ) ; return builder . define ( ) ; }
a check to the map .
the ValidationContext for the given class .
< Check > addClassChecks ( final Class target ) { final List < Check > list = cache . get ( target , ( ) -> { final List < Check > newList = new ArrayList < > ( ) ; final ClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( target ) ; final PropertyDescriptor [ ] allProperties = cd . getAllPropertyDescriptors ( ) ; for ( PropertyDescriptor propertyDescriptor : allProperties ) { collectPropertyAnnotationChecks ( newList , propertyDescriptor ) ; } return newList ; } ) ; return list ; }
the annotations of the property .
a list of checks for a given annotation .
default check properties .
( final String source , final String encoding ) { if ( source == null ) { return null ; } byte [ ] bytes = encodeBytes ( StringUtil . getBytes ( source , encoding ) , uriPart ) ; char [ ] chars = new char [ bytes . length ] ; for ( int i = 0 ; i < bytes . length ; i ++ ) { chars [ i ] = ( char ) bytes [ i ] ; } return new String ( chars ) ; }
( final String string , final String encoding ) { return encodeUriComponent ( string , encoding , URIPart . UNRESERVED ) ; }
the scheme to a string .
( final String host , final String encoding ) { return encodeUriComponent ( host , encoding , URIPart . HOST ) ; }
( final String port , final String encoding ) { if ( port == null ) { throw new IllegalArgumentException ( " Port cannot be null . " ) ; } if ( encoding == null ) { throw new IllegalArgumentException ( " Port cannot be null . " ) ; } if ( encoding . equals ( " " ) ) { throw new IllegalArgumentException ( " Port cannot be null . " ) ; } if ( encoding . equals ( " " ) ) { throw new IllegalArgumentException ( " Port cannot be null . " ) ; } }
( final String path , final String encoding ) { return encodeUriComponent ( path , encoding , URIPart . PATH ) ; }
( final String query , final String encoding ) { return encodeUriComponent ( query , encoding , URIPart . QUERY ) ; }
the query param .
( final String fragment , final String encoding ) { return encodeUriComponent ( fragment , encoding , URIPart . FRAGMENT ) ; }
< String , PropertyDescriptor > inspectProperties ( ClassDescriptor classDescriptor ) { Map < String , PropertyDescriptor > map = new HashMap < > ( ) ; if ( classDescriptor . isIncludeFieldsAsProperties ( ) ) { map . put ( classDescriptor . getPropertyFieldPrefix ( ) , createPropertyDescriptor ( classDescriptor . getPropertyFieldSuffix ( ) , classDescriptor ) ) ; } if ( classDescriptor . isIncludeFieldsAsProperties ( ) ) { map . put ( classDescriptor . getPropertyFieldPrefix ( ) , createPropertyDescriptor ( classDescriptor . getPropertyFieldSuffix ( ) , classDescriptor ) ) ; } if ( classDescriptor . isIncludeFieldsAsProperties ( ) ) { map . put ( classDescriptor . getPropertyFieldPrefix ( ) , createPropertyDescriptor ( classDescriptor . getPropertyFieldSuffix ( ) , classDescriptor ) ) ; } }
all properties from all property descriptors .
a list of cookies .
( String body ) throws HttpException { if ( contentEncoding ( ) != null && contentEncoding ( ) . equals ( " gzip " ) ) { if ( body != null && body . length ( ) > 0 ) { headerRemove ( HEADER_CONTENT_ENCODING ) ; try { ByteArrayInputStream in = new ByteArrayInputStream ( body . getBytes ( StringPool . ISO_8859_1 ) ) ; GZIPInputStream gzipInputStream = new GZIPInputStream ( in ) ; ByteArrayOutputStream out = new ByteArrayOutputStream ( ) ; StreamUtil . copy ( gzipInputStream , out ) ; body ( out . toString ( StringPool . ISO_8859_1 ) ) ; } catch ( IOException ioex ) { throw new HttpException ( ioex ) ; } } } return this ; }
the connection .
a ProtoScope and a SingletonScope .
a list of all actions .
the content .
the encrypted content .
map2bean ( final Map map , final String classMetadataName ) throws JsonException { if ( classMetadataName == null ) { return map ; } if ( map . containsKey ( classMetadataName ) ) { return map . get ( classMetadataName ) ; } return map . get ( classMetadataName ) ; }
a list of elements .
the value of the specified property .
< K , V > generifyMap ( final Map < Object , Object > map , final Class < K > keyType , final Class < V > valueType ) { if ( keyType == String . class ) { for ( Map . Entry < Object , Object > entry : map . entrySet ( ) ) { Object value = entry . getValue ( ) ; Object newValue = convert ( value , valueType ) ; if ( value != newValue ) { entry . setValue ( newValue ) ; } } return map ; } if ( valueType == V . class ) { for ( Map . Entry < Object , Object > entry : map . entrySet ( ) ) { entry . setValue ( convert ( entry . getValue ( ) , valueType ) ) ; } return map ; } return map ; }
int compareTo ( final Object o ) { DbEntityColumnDescriptor that = ( DbEntityColumnDescriptor ) o ; if ( this . isId != that . isId ) { return this . isId ? - 1 : 1 ; } return this . columnName . compareTo ( that . columnName ) ; }
( final String name , final String value ) { defaultHeaders . addHeader ( name , value ) ; return this ; }
a request to the server .
a request to the server .
a default header to the HttpRequest .
the cookies from the HttpResponse .
cookies to the HttpRequest .
a message to the specified email .
the subject of the email .
the sent date .
the headers of the email .
the people from the given email .
the recipients of the email .
a body to the email .
the content of the email .
a new MimeBodyPart for the attachment .
the content type of the given data header .
( final ResultSet rs ) { if ( resultSets == null ) { resultSets = new HashSet < > ( ) ; } resultSets . add ( rs ) ; }
all result sets .
the query .
the query .
the fetch size .
max rows .
update query .
count query .
the generated columns from the database .
the query string .
a new instance of aspect class .
< T > collectionOf ( final Iterator < ? extends T > iterator ) { final List < T > list = new ArrayList < > ( ) ; while ( iterator . hasNext ( ) ) { list . add ( iterator . next ( ) ) ; } return list ; }
< T > streamOf ( final Iterator < T > iterator ) { return StreamSupport . stream ( ( ( Iterable < T > ) iterator ) . spliterator ( ) , false ) ; }
comparators .
default wiring mode .
the log message .
the caller class .
the name of the class .
types ( final Class ... excludedTypes ) { if ( excludedTypes == null ) { excludedTypes = types ; } else { excludedTypes = ArraysUtil . join ( excludedTypes , types ) ; } return this ; }
the source to the target .
the source to a FastCharBuffer .
a serializable object .
the object to the specified file .
the source file .
the object to a byte array .
a byte array to an object .
( final Class [ ] types ) { if ( types == null || types . length == 0 ) { return null ; } if ( names == null ) { names = new String [ types . length ] [ ] ; for ( int i = 0 ; i < types . length ; i ++ ) { Class type = types [ i ] ; if ( type != null ) { DbEntityDescriptor ded = cachedDbEntityDescriptors [ i ] ; if ( ded != null ) { Class [ ] mappedTypes = ded . getMappedTypes ( ) ; if ( mappedTypes != null ) { names [ i ] = createTypesTableNames ( mappedTypes ) ; } } } } cachedMappedNames = names ; } return names ; }
the table names for the given types .
the column value .
the result set of the query .
a list of providers for a given type .
( String tableName ) { String entityName = convertTableNameToEntityName ( tableName ) ; return convertEntityNameToTableName ( entityName ) ; }
if the connection is valid .
a view .
the target for the given path .
the response to the server .
the output stream .
content to the response .
the content type of the given type .
the given string .
successful .
the token from the given authToken .
via Basic Auth .
the user .
a URL to a file .
a new directory .
a new directory .
the file to the destination .
a directory to another directory .
( final File srcFile , final File destDir ) throws IOException { checkExistsAndDirectory ( destDir ) ; return moveFile ( srcFile , file ( destDir , srcFile . getName ( ) ) ) ; }
directory to dest directory .
the directory .
from a file .
the contents of the given file .
( final File dest , final char [ ] data , final String encoding ) throws IOException { outChars ( dest , data , encoding , false ) ; }
static void writeString ( final File dest , final String data , final String encoding ) throws IOException { outString ( dest , data , encoding , false ) ; }
a string to a file .
the contents of the file into a byte array .
( final File dest , final byte [ ] data , final int off , final int len ) throws IOException { outBytes ( dest , data , off , len , false ) ; }
( final File dest ) throws IOException { outBytes ( dest ) ; }
a file to a directory .
a file from a directory .
a new directory .
if the file is a binary file .
the source directory to the destination directory .
the contents of the file to the destination directory .
the usage of the command .
the action method .
a new action .
a path alias .
the value of the last iteration .
a new CharArraySequence from the given value .
the result of the target method .
uppercase target .
a CharArraySequence .
the URLs of the given class .
the bcc of a given email address .
an instance of the given type .
the serializer for the given type .
a multipart request stream .
the value of the request parameter .
the request parameters .
the uploaded file .
the uploaded files .
the encoding of the filter .
a string from the template .
the end of the template .
the number of escapes in the template .
a query string .
( final String query ) { return parseQuery ( query , false ) ; }
the name of the header .
the content type from the given string .
the node to a html string .
the inner html of the node .
the madvoc configurator .
the path .
a JsonParser with a lazy value .
withMappedTypeForPath ( final Path path ) { if ( mappings == null ) { return target ; } Class newType ; Path altPath = path . getAltPath ( ) ; if ( altPath != null ) { if ( ! altPath . equals ( path ) ) { newType = mappings . get ( altPath ) ; if ( newType != null ) { return newType ; } } } newType = mappings . get ( path ) ; if ( newType != null ) { return newType ; } return target ; }
( final String string , final Class < T > componentType ) { return new JsonParser ( ) . map ( JsonParser . VALUES , componentType ) . parse ( string ) ; }
( final String string , final Class < K > keyType , final Class < V > valueType ) { return new JsonParser ( ) . map ( JsonParser . KEYS , keyType ) . map ( JsonParser . VALUES , valueType ) . parse ( string ) ; }
resolveLazyValue ( Object value ) { if ( value instanceof Supplier ) { value = ( ( Supplier ) value ) . get ( ) ; } return value ; }
the object if it is a string .
the string content .
parseStringContent ( final char quote ) { return new String ( input , startNdx , ndx - 1 - startNdx ) ; }
( ) { return parseUnicode ( ) ; }
( ) { final int startNdx = ndx ; while ( true ) { final char c = input [ ndx ] ; if ( c <= ' ' || CharUtil . equalsOne ( c , UNQUOTED_DELIMETERS ) ) { final int currentNdx = ndx ; skipWhiteSpaces ( ) ; return new String ( input , startNdx , currentNdx - startNdx ) ; } ndx ++ ; } }
( String input ) { int ndx = 0 ; while ( ndx < input . length ( ) ) { if ( input [ ndx ] . length ( ) == 0 ) { break ; } if ( input [ ndx ] . length ( ) == 0 ) { break ; } if ( input [ ndx ] . length ( ) == 0 ) { break ; } if ( input [ ndx ] . length ( ) == 0 ) { break ; } if ( input [ ndx ] . length ( ) == 0 ) { break ; } if ( input [ ndx ] . length ( ) == 0 ) { break ; } if ( input [ ndx ] . length ( ) == 0 ) { break ; } if ( input [ ndx ] . length ( ) == 0 ) { break ; } if ( input [ ndx ] . length ( ) == 0 ) { break ; } if ( input [ ndx ] . length ( ) ==
( Class targetType ) { if ( targetType == Object . class ) { targetType = List . class ; } if ( targetType == List . class ) { targetType = List . class ; } if ( targetType == List . class ) { targetType = List . class ; } return parseArrayContent ( targetType ) ; }
a new Ctor .
a simple method wrapper .
the rawTypeName of the given type .
a BeanReference from a propertyDescriptor .
a reference to a method .
all references from PetiteInject .
a BeanReferences for the given method .
the default reference for the given property .
all duplicate names from all beanReferences .
BeanReferences to BeanReferences .
a String to a BeanReferences .
a JoddJoy .
( final Class c , final String methodName ) { return findDeclaredMethod ( c , methodName , true ) ; }
the constructor for the given class .
all interfaces .
the parameters .
the access to the AccessibleObject .
a new instance of the given class .
the superclass of the given type .
the child class of the parent class .
jarFileOf ( final Class < ? > klass ) { URL url = klass . getResource ( " / " + klass . getName ( ) . replace ( ' . ' , ' / ' ) + " . class " ) ; if ( url == null ) { return null ; } return jarFileOf ( klass ) ; }
the given time .
the current time .
for the object to be available .
a new ThreadFactory for the given name .
the value of the supplier .
void visitParameter ( final String name , final int access ) { if ( api < Opcodes . ASM5 ) { throw new UnsupportedOperationException ( REQUIRES_ASM5 ) ; } if ( mv != null ) { mv . visitParameter ( name , access ) ; } }
AnnotationVisitor visitAnnotation ( final String descriptor , final boolean visible ) { if ( mv != null ) { return mv . visitAnnotation ( descriptor , visible ) ; } return null ; }
visitTypeAnnotation ( final int typeRef , final TypePath typePath , final String descriptor , final boolean visible ) { if ( api < Opcodes . ASM5 ) { throw new UnsupportedOperationException ( REQUIRES_ASM5 ) ; } if ( mv != null ) { return mv . visitTypeAnnotation ( typeRef , typePath , descriptor , visible ) ; } return null ; }
AnnotationVisitor visitParameterAnnotation ( final int parameter , final String descriptor ) { if ( mv != null ) { return mv . visitParameterAnnotation ( parameter , descriptor , visible ) ; } return null ; }
the opcode of the field .
void visitMethodInsn ( final int opcode , final String owner , final String name , final String descriptor , final boolean isInterface ) { if ( api < Opcodes . ASM5 ) { if ( isInterface != ( opcode == Opcodes . INVOKEINTERFACE ) ) { throw new IllegalArgumentException ( " INVOKESPECIAL / STATIC on interfaces requires ASM5" ) ; } visitMethodInsn ( opcode , owner , name , descriptor , isInterface ) ; return ; } visitMethodInsn ( opcode , owner , name , descriptor , isInterface ) ; }
of the bootstrap method .
void visitJumpInsn ( final int opcode , final Label label ) { if ( mv != null ) { mv . visitJumpInsn ( opcode , label ) ; } }
a new array for the given descriptor .
a try catch block .
AnnotationVisitor visitLocalVariableAnnotation ( final int typeRef , final TypePath typePath , final Label [ ] start , final Label [ ] end , final int [ ] index , final String descriptor , final boolean visible ) { if ( api < Opcodes . ASM5 ) { throw new UnsupportedOperationException ( REQUIRES_ASM5 ) ; } if ( mv != null ) { return mv . visitLocalVariableAnnotation ( typeRef , typePath , start , end , index , descriptor , visible ) ; } return null ; }
the profile properties to a BufferedWriter .
the input stream .
< T > iterator ( ) { return iterator ; }
the cursor to the end of the query .
the arrays .
the arrays .
the buffer .
a new element to the array .
a single element from the array .
static int indexOf ( char [ ] array , char value ) { for ( int i = 0 ; i < array . length ; i ++ ) { if ( array [ i ] == value ) { return i ; } } return - 1 ; }
static int indexOf ( Object [ ] array , Object value ) { for ( int i = 0 ; i < array . length ; i ++ ) { if ( array [ i ] == value ) { return i ; } } return - 1 ; }
static int indexOf ( byte [ ] array , byte [ ] sub , int startIndex ) { return indexOf ( array , sub , startIndex , array . length ) ; }
( ) { return this ; }
( final char [ ] content ) { LagartoParser lagartoParser = new LagartoParser ( content ) ; return doParse ( lagartoParser ) ; }
a LagartoDOMBuilder tag .
the maximum stack of a handler .
the current BasicBlock .
( final Attribute . Set attributePrototypes ) { attributePrototypes . addAttributes ( firstAttribute ) ; attributePrototypes . addAttributes ( firstCodeAttribute ) ; return attributePrototypes ; }
the target object into the scope resolver .
a pseudo class .
the pseudo class from the given pseudoClassName .
async action path .
all bean property names .
the properties from the source .
public boolean accept ( final String propertyName , final String rule , final boolean include ) { return propertyName . equals ( rule ) ; }
[ ] resolve ( final Class type ) { ClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( type ) ; List < MethodInjectionPoint > list = new ArrayList < > ( ) ; MethodDescriptor [ ] allMethods = cd . getAllMethodDescriptors ( ) ; for ( MethodDescriptor methodDescriptor : allMethods ) { Method method = methodDescriptor . getMethod ( ) ; if ( ClassUtil . isBeanPropertyGetter ( method ) ) { continue ; } if ( ClassUtil . isBeanPropertySetter ( method ) ) { continue ; } if ( method . getParameterTypes ( ) . length == 0 ) { continue ; } BeanReferences [ ] references = referencesResolver . readAllReferencesFromAnnotation ( method ) ; if ( references != null ) { MethodInjectionPoint methodInjectionPoint = new MethodInjectionPoint ( method , references ) ; list . add ( methodInjectionPoint ) ; } } return list . toArray ( new MethodInjectionPoint [ 0 ] ) ; }
filter config parameters .
a bundle file to the server .
the bundle file for the given bundleId .
the gzip file from the given path .
a new bundle .
a digest for the given source .
a new bundle .
all bundle files .
the relative URL of the given CSS file .
the column value .
createTableRefName ( final Object entity ) { Class type = entity . getClass ( ) ; type = ( type == Class . class ? ( Class ) entity : type ) ; return type . getSimpleName ( ) + ' _ ' ; }
db TX manager session .
a single element array to a single element array .
a Map < String , String > .
[ ] resolve ( final Class type ) { if ( type == null ) { return SetInjectionPoint . EMPTY ; } if ( type . isPrimitive ( ) ) { return SetInjectionPoint . EMPTY ; } if ( type . isPrimitive ( ) ) { return SetInjectionPoint . EMPTY ; } if ( type . isPrimitive ( ) ) { return SetInjectionPoint . EMPTY ; } if ( type . isPrimitive ( ) ) { return SetInjectionPoint . EMPTY ; } if ( type . isPrimitive ( ) ) { return SetInjectionPoint . EMPTY ; } return SetInjectionPoint . EMPTY ; }
( final Class propertyType , final boolean excludeMaps , final boolean include ) { if ( ! include ) { return false ; } if ( jsonSerializer . excludedTypes != null ) { for ( Class excludedType : jsonSerializer . excludedTypes ) { if ( ClassUtil . isTypeOf ( propertyType , excludedType ) ) { return false ; } } } if ( jsonSerializer . excludedTypes != null ) { for ( Class excludedType : jsonSerializer . excludedTypes ) { if ( ClassUtil . isTypeOf ( propertyType , excludedType ) ) { return false ; } } } return true ; }
a new connection .
TX .
the transaction .
transaction .
the transaction .
a new Properties from a file .
a new Properties from a string .
( final Properties p , final String data ) throws IOException { try ( ByteArrayInputStream is = new ByteArrayInputStream ( data . getBytes ( StringPool . ISO_8859_1 ) ) ) { p . load ( is ) ; } }
a subset of the specified properties .
( final String ... rootTemplate ) { Properties p = new Properties ( ) ; return loadFromClasspath ( p , rootTemplate ) ; }
the value of the given key .
all variables from a properties file .
the value of the property .
the scope of the given type .
the JtxTransactionMode for the given method .
a transaction annotation parser .
a transaction annotation .
a selector .
( final Node node ) { if ( node . getNodeType ( ) != Node . NodeType . ELEMENT ) { return false ; } String element = getElement ( ) ; String nodeName = node . getNodeName ( ) ; return element . equals ( StringPool . STAR ) || element . equals ( nodeName ) ; }
the results of the given selector .
the value to a string .
a list of packages for the given java version number .
the specified node .
( ) { }
a child node to the parent .
a child of the given node .
a new child .
a new ref child .
a new child .
a new child .
all child elements from the list .
the node with the given name .
a list of all nodes in the given list .
if a sibling element is present .
( ) { if ( childElementNodes == null ) { childElementNodes = new Element [ childElementNodesCount ] ; int childCount = getChildNodesCount ( ) ; for ( int i = 0 ; i < childCount ; i ++ ) { Node child = getChild ( i ) ; if ( child . siblingElementIndex >= 0 ) { childElementNodes [ child . siblingElementIndex ] = ( Element ) child ; } } } }
sibling names .
( ) { if ( childNodes == null ) { childNodes = new ArrayList < > ( ) ; } if ( ownerDocument != null ) { if ( newNode . ownerDocument != ownerDocument ) { changeOwnerDocument ( newNode , ownerDocument ) ; } } }
the owner document .
( Node parentNode , String nodeName ) { if ( parentNode == null ) { return null ; } if ( nodeName == null ) { return null ; } int siblingIndex = parentNode . childNodes . indexOf ( nodeName ) ; if ( siblingIndex >= 0 ) { Node sibling = parentNode . childNodes . get ( siblingIndex ) ; if ( ( index == sibling . siblingNameIndex ) && nodeName . equals ( sibling . getNodeName ( ) ) ) { return sibling ; } } return null ; }
the text content .
a HTML string .
the inner html of the given element .
the children of the given node .
the path of the node .
a decorora tag .
the id attribute of the tag .
defineDecoraTag ( ) { DecoraTag decoraTag = decoraTagDefaultValueStart == 0 ? new DecoraTag ( decoraTagName , decoraIdName , decoraTagStart , decoraTagEnd ) : new DecoraTag ( decoraTagName , decoraIdName , decoraTagStart , decoraTagDefaultValueStart , decoraTagDefaultValueEnd - decoraTagDefaultValueStart ) ; decoraTags . add ( decoraTag ) ; return decoraTag ; }
JoyProxetta addProxyAspect ( final ProxyAspect proxyAspect ) { requireNotStarted ( proxetta ) ; this . proxyAspects . add ( proxyAspect ) ; return this ; }
a root package to the list of packages .
the root package of the action class .
the root package for a given action path .
the validation message .
duplicate names .
a name pattern to the props file .
forEachTarget ( final Consumer < Target > targetConsumer ) { for ( final Target target : targets ) { targetConsumer . accept ( target ) ; } }
< Target , InjectionPoint > forEachTargetAndIn ( final List < Target > targets ) { for ( final Target target : targets ) { final ScopeData scopeData = target . scopeData ( ) ; if ( scopeData . in ( ) == null ) { continue ; } for ( final InjectionPoint in : scopeData . in ( ) ) { if ( in . scope ( ) != scope ) { continue ; } biConsumer . accept ( target , in ) ; } } }
< Target , InjectionPoint > forEachTargetAndOut ( final List < Target > targets , final BiConsumer < InjectionPoint , InjectionPoint > biConsumer ) { for ( final Target target : targets ) { final ScopeData scopeData = target . scopeData ( ) ; if ( scopeData . out ( ) == null ) { continue ; } for ( final InjectionPoint out : scopeData . out ( ) ) { if ( out . scope ( ) != scope ) { continue ; } biConsumer . accept ( target , out ) ; } } }
the parameters values .
a target for the given method .
a new action method argument for the given type .
a new session .
the session .
a value to a JsonArray .
JsonArray addAll ( final JsonArray array ) { Objects . requireNonNull ( array ) ; list . addAll ( array ) ; return this ; }
the element from the list .
the target for the given action .
the result of a given action .
valueToString ( final String name , final Object valueObject ) { if ( ! valueObject . getClass ( ) . isArray ( ) ) { return valueObject . toString ( ) ; } String [ ] array = ( String [ ] ) valueObject ; if ( valueNameIndexes == null ) { valueNameIndexes = new HashMap < > ( ) ; } MutableInteger index = valueNameIndexes . get ( name ) ; if ( index == null ) { index = new MutableInteger ( 0 ) ; valueNameIndexes . put ( name , index ) ; } if ( index . value >= array . length ) { return null ; } return array [ index . value ] ; }
filter ( final Class < T > actionFilterClass ) { filtersManager . resolve ( actionFilterClass ) ; return this ; }
the pseudo function name .
a list of all properties of the given type .
a SOCKS4 proxy socket .
( ) { return getAttributeCount ( ) ; }
all action results .
true if the match is equal to the given string .
the index of the match .
( final char [ ] source , final int index ) { for ( int i = index ; i < source . length ; i ++ ) { if ( source [ i ] == match ) { return i ; } } return null ; }
arguments to the command line .
the env value .
the command line .
a listener for the given listener .
the input locals to the output stack .
the abstract type from the symbol table .
the type from the buffer .
the input frame from the symbol table .
the abstract type of the local index .
the local index of the abstract type .
the output stack .
an abstract type to the symbol table .
( final int elements ) { if ( outputStackTop >= elements ) { outputStackTop -= elements ; } else { outputStackStart -= elements - outputStackTop ; outputStackTop = 0 ; } }
the given descriptor .
a new initialized type .
the initialized type of the abstract type .
an abstract type into the symbol table .
to prune the cache .
prune ( ) { if ( pruneTimer != null ) { pruneTimer . cancel ( ) ; } pruneTimer = new Timer ( ) ; pruneTimer . schedule ( new TimerTask ( ) { @ Override public void run ( ) { prune ( ) ; } } , delay , delay ) ; }
visitModule ( final String name , final int access , final String version ) { if ( api < Opcodes . ASM6 ) { throw new UnsupportedOperationException ( " This feature requires ASM6" ) ; } if ( cv != null ) { return cv . visitModule ( name , access , version ) ; } return null ; }
the nest host .
the outer class .
AnnotationVisitor visitAnnotation ( final String descriptor , final boolean visible ) { if ( cv != null ) { return cv . visitAnnotation ( descriptor , visible ) ; } return null ; }
void visitNestMember ( final String nestMember ) { if ( api < Opcodes . ASM7 ) { throw new UnsupportedOperationException ( " This feature requires ASM7" ) ; } if ( cv != null ) { cv . visitNestMember ( nestMember ) ; } }
the inner class for the given name .
the value of the field .
the current thread session .
the thread session .
a new execution array .
the action method .
( ) { if ( requestBody == null ) { try { requestBody = ServletUtil . readRequestBodyFromStream ( getHttpServletRequest ( ) ) ; } catch ( IOException ioex ) { requestBody = StringPool . EMPTY ; } } return requestBody ; }
( final int page , final int pageSize ) { if ( page < 1 ) { page = 1 ; } if ( pageSize < 1 ) { pageSize = 1 ; } return page ; }
( final PageRequest pageRequest ) { return calcFirstItemIndexOfPage ( pageRequest . getPage ( ) , pageRequest . getSize ( ) , total ) ; }
true if the given value is greater than the given value .
a char array to a byte array .
( final char [ ] source , final int index , final char [ ] match ) { for ( int i = index ; i < source . length ; i ++ ) { if ( ! equalsOne ( source [ i ] , match ) ) { return i ; } } return 0 ; }
the name of the node .
the name of the attribute .
the value of the attribute .
Props from file .
( final File file ) throws IOException { parse ( FileUtil . readString ( file , encoding ) ) ; return this ; }
Props from InputStream .
Props from a Map .
the Props file .
the properties file from the classpath .
the value of the given key .
the value of the profile .
( final Map target ) { initialize ( ) ; data . extract ( target , activeProfiles , null , null ) ; }
properties from a Map .
( final Map target , final Map activeProfiles , final String ... wildcardPatterns ) { initialize ( ) ; data . extract ( target , activeProfiles , wildcardPatterns , null ) ; }
the inner map .
an inner map to the profile .
active profiles .
a list of all profiles .
the profiles for a given propKeyName .
a PropertyInjectionPoint to the list of properties .
a set injection point .
a method injection point .
init method points .
a destroy method point .
the target class from the proxy .
the target into the wrapper .
the target wrapper type .
the field descriptor for the given class .
the type of the field .
the type of the key component .
resolveComponentType ( final boolean declared ) { Class componentType = null ; Getter getter = getGetter ( declared ) ; if ( getter != null ) { componentType = getter . getGetterRawComponentType ( ) ; } if ( componentType == null ) { FieldDescriptor fieldDescriptor = getFieldDescriptor ( ) ; if ( fieldDescriptor != null ) { componentType = fieldDescriptor . getRawComponentType ( ) ; } } return componentType ; }
a JsonResult of the given object .
a JsonResult of the exception .
the HTTP method from the given name .
true if the pattern matches the given string .
resolveLoading ( final boolean parentFirstStrategy , final String className , final String loaderOnlyRules ) { if ( parentFirstStrategy ) { if ( isMatchingRules ( className , loaderOnlyRules ) ) { withParent = true ; } else if ( isMatchingRules ( className , loaderOnlyRules ) ) { withParent = false ; } } else { if ( isMatchingRules ( className , loaderOnlyRules ) ) { withParent = true ; } else if ( isMatchingRules ( className , loaderOnlyRules ) ) { withParent = false ; } else if ( isMatchingRules ( className , loaderOnlyRules ) ) { withParent = true ; } else if ( isMatchingRules ( className , loaderOnlyRules ) ) { withParent = false ; } else if ( isMatchingRules ( className , loaderOnlyRules ) ) { withParent = false ; } } return new Loading ( withParent , withLoader ) ; }
resolveResourceLoading ( boolean parentFirstStrategy , String resourceName ) { if ( matchResourcesAsPackages ) { resourceName = StringUtil . replaceChar ( resourceName , ' / ' , ' . ' ) ; } return resolveLoading ( parentFirstStrategy , resourceName ) ; }
< ? > loadClass ( final String className , final boolean resolve ) throws ClassNotFoundException { Class < ? > c = loadClass ( className , resolve ) ; if ( c != null ) { return c ; } return loadClass ( className , resolve ) ; }
the resource from the parent ClassLoader .
for the lock to be released .
the type of the annotation .
InjectionPoint for annotation value .
whether a property is a getter .
the URLs of the given class .
the bean property .
the bean .
( PropertyDescriptor cd ) { if ( cd == null ) { propertyDescriptor = null ; } else { propertyDescriptor = cd . getPropertyDescriptor ( name , true ) ; } updateProperty = false ; }
getGetter ( final boolean declared ) { loadPropertyDescriptor ( ) ; return propertyDescriptor != null ? propertyDescriptor . getGetter ( declared ) : null ; }
getSetter ( boolean declared ) { loadPropertyDescriptor ( ) ; return propertyDescriptor != null ? propertyDescriptor . getSetter ( declared ) : null ; }
to the database .
iterator to all iterators .
( ) { printLogo ( ) ; }
the Joy .
a new socket .
a SSLSocket from the given host and port .
the default SSLSocketFactory .
a socket factory for the given proxy .
a random string .
a random string .
a random string from the given ranges .
a new Collection < Object > .
the value into the object .
the value to the specified type .
whether a provider is provided or not .
< A > createDefault ( ) { return ( TypeCache < A > ) Defaults . implementation . get ( ) ; }
< T > T put ( final Class < T > type , final T value ) { return map . put ( type , value ) ; }
all methods of the given class .
the IP address of the given hostname .
( final String ipAddress ) { int ipIntValue = 0 ; String [ ] tokens = StringUtil . splitc ( ipAddress , ' . ' ) ; for ( String token : tokens ) { if ( ipIntValue > 0 ) { ipIntValue <<= 8 ; } ipIntValue += Integer . parseInt ( token ) ; } return ipIntValue ; }
( final String input ) { if ( input == null ) { return false ; } int hitDots = 0 ; char [ ] data = input . toCharArray ( ) ; for ( int i = 0 ; i < data . length ; i ++ ) { char c = data [ i ] ; int b = 0 ; do { if ( c < '0' || c > '9' ) { return false ; } b = ( b * 10 + c ) - 48 ; if ( ++ i >= data . length ) { break ; } c = data [ i ] ; } while ( c != ' . ' ) ; if ( b > 255 ) { return false ; } } return true ; }
the hostname of the given ip .
a byte array from a URL .
a string from a URL .
the file .
a madvoc scope .
the given action .
to the given hostname and port .
to the given hostname and port .
the index of the primitive class name .
( final String className , final ClassLoader classLoader ) throws ClassNotFoundException { if ( classLoader == null ) { classLoader = ClassLoader . getSystemClassLoader ( ) ; } if ( classLoader == null ) { classLoader = ClassLoader . getSystemClassLoader ( ) ; } if ( classLoader == null ) { classLoader = ClassLoader . getSystemClassLoader ( ) ; } return loadClass ( className , classLoader ) ; }
the array class .
( ) { for ( final BeanData beanData : instances . values ( ) ) { beanData . callDestroyMethods ( ) ; } }
< T > forArray ( final T [ ] array ) { return new BinarySearch < T > ( ) { @ Override @ SuppressWarnings ( { " unchecked " } ) protected int compare ( final int index , final T element ) { return array [ index ] . compareTo ( element ) ; } @ Override protected int getLastIndex ( ) { return array . length - 1 ; } } ; }
< T > forArray ( final T [ ] array , final Comparator < T > comparator ) { return new BinarySearch < T > ( ) { @ Override @ SuppressWarnings ( { " unchecked " } ) protected int compare ( final int index , final T element ) { return comparator . compare ( array [ index ] , element ) ; } @ Override protected int getLastIndex ( ) { return array . length - 1 ; } } ; }
a rule from a given string .
T include ( final String ... includes ) { for ( String in : includes ) { rules . include ( in ) ; } return _this ( ) ; }
T include ( final Class template ) { blacklist = false ; String [ ] properties = getAllBeanPropertyNames ( template , false ) ; include ( properties ) ; return this ; }
the tag .
a new Madvoc WebApp component .
the SQL type of the column .
sql string .
a ResultSetMapper .
( final Class < T > type ) { return find ( new Class [ ] { type } , false , getGeneratedColumns ( ) ) ; }
the generated keys for the entity .
< R extends ActionInterceptor > R createWrapper ( final Class < R > wrapperClass ) { return petiteContainer . createBean ( wrapperClass ) ; }
the bean to the specified name .
setMap ( final Map parameters ) { if ( parameters == null ) { return _this ( ) ; } init ( ) ; query . forEachNamedParameter ( p -> { final String paramName = p . name ; setObject ( paramName , parameters . get ( paramName ) ) ; } ) ; return _this ( ) ; }
the current object .
a new chunk after the previous one .
the type of the entity .
table descriptor by column ref .
the table alias for the given table .
the type of the object .
missing spaces to the output .
the file parameter names .
the requested page .
the URL of the request .
the request uri .
the names of the method parameters .
the petite container .
the PETITE container .
subject ( final String subject ) { final SearchTerm subjectTerm = new SubjectTerm ( subject ) ; concat ( subjectTerm ) ; return this ; }
messageId ( final String messageId ) { final SearchTerm msgIdTerm = new MessageIDTerm ( messageId ) ; concat ( msgIdTerm ) ; return this ; }
from ( final String fromAddress ) { final SearchTerm fromTerm = new FromStringTerm ( fromAddress ) ; concat ( fromTerm ) ; return this ; }
to ( final String toAddress ) { final SearchTerm toTerm = new RecipientStringTerm ( RecipientType . TO , toAddress ) ; concat ( toTerm ) ; return this ; }
cc ( final String ccAddress ) { final SearchTerm toTerm = new RecipientStringTerm ( RecipientType . CC , ccAddress ) ; concat ( toTerm ) ; return this ; }
bcc ( final String bccAddress ) { final SearchTerm toTerm = new RecipientStringTerm ( RecipientType . BCC , bccAddress ) ; concat ( toTerm ) ; return this ; }
flags ( final Flags flags , final boolean value ) { final SearchTerm flagTerm = new FlagTerm ( flags , value ) ; concat ( flagTerm ) ; return this ; }
the flags of the given flag .
receivedDate ( final Operator operator ) { final SearchTerm term = new ReceivedDateTerm ( operator . value , new Date ( milliseconds ) ) ; concat ( term ) ; return this ; }
sentDate ( final Operator operator ) { final SearchTerm term = new SentDateTerm ( operator . value , new Date ( milliseconds ) ) ; concat ( term ) ; return this ; }
size ( final Operator comparison , final int size ) { final SearchTerm term = new SizeTerm ( comparison . value , size ) ; concat ( term ) ; return this ; }
and ( final EmailFilter ... emailFilters ) { final SearchTerm [ ] searchTerms = new SearchTerm [ emailFilters . length ] ; for ( int i = 0 ; i < emailFilters . length ; i ++ ) { searchTerms [ i ] = emailFilters [ i ] . searchTerm ; } concat ( new AndTerm ( searchTerms ) ) ; return this ; }
or ( final EmailFilter ... emailFilters ) { final SearchTerm [ ] searchTerms = new SearchTerm [ emailFilters . length ] ; for ( int i = 0 ; i < emailFilters . length ; i ++ ) { searchTerms [ i ] = emailFilters [ i ] . searchTerm ; } concat ( new OrTerm ( searchTerms ) ) ; return this ; }
not ( final EmailFilter emailFilter ) { final SearchTerm searchTerm = new NotTerm ( emailFilter . searchTerm ) ; concat ( searchTerm ) ; return this ; }
search terms .
the base32 string .
the value to a byte array .
the Gzip file from the request .
List < Violation > validate ( final Object target ) { return validate ( ValidationContext . resolveFor ( target . getClass ( ) ) , target ) ; }
a Violation .
a list of enabled profiles .
the enabled profiles .
a list of enabled profiles .
( final String body ) { if ( body == null ) { return null ; } if ( body . length ( ) == 0 ) { return null ; } if ( body . length ( ) == 0 ) { return null ; } if ( body . length ( ) == 0 ) { return null ; } if ( body . length ( ) == 0 ) { return null ; } if ( body . length ( ) == 0 ) { return null ; } if ( body . length ( ) == 0 ) { return null ; } if ( body . length ( ) == 0 ) { return null ; } if ( body . length ( ) == 0 ) { return null ; } if ( body . length ( ) == 0 ) { return null ; } if ( body . length ( ) == 0 ) { return null ; } if ( body . length ( ) == 0 ) { return null ; } if ( body . length ( ) == 0 ) { return null ; }
the date to milliseconds .
a JulianDate to a JulianDate .
a JulianDate from a JulianDate .
the fraction of the integer .
a ParsedDoctype object .
a comment .
the position of the message .
a hash of the password .
a PBKDF2 encoded password .
the hex string to a byte array .
( final Class type , final String name ) { return providerResolver . resolveProviderDefinitions ( type , name ) ; }
name ( final String name ) { this . name = name ; return this ; }
setContentId ( String contentId ) { if ( contentId == null ) { if ( name != null ) { contentId ( FileNameUtil . getName ( name ) ) ; } else { contentId ( NO_NAME ) ; } } return this ; }
the content type from the given name .
the type of the signature .
( ) { symbolTable . addConstantUtf8 ( Constants . MODULE ) ; int size = 22 + requires . length + exports . length + opens . length + usesIndex . length + provides . length ; if ( packageCount > 0 ) { symbolTable . addConstantUtf8 ( Constants . MODULE_PACKAGES ) ; size += 8 + packageIndex . length ; } if ( mainClassIndex > 0 ) { symbolTable . addConstantUtf8 ( Constants . MODULE_MAIN_CLASS ) ; size += 8 + mainClassIndex . length ; } return size ; }
the module attributes into a ByteVector .
( final String source , final String encoding ) { return decode ( source , encoding , false ) ; }
decode ( final String source , final String encoding ) { return decode ( source , encoding , true ) ; }
the DB .
the connection provider .
a method signature .
all interfaces of the given class .
a method signature .
a String to a CSV string .
a list of fields from a line .
resolve ( final Class < ? > type ) { if ( type == null ) { return CtorInjectionPoint . EMPTY ; } return new CtorInjectionPoint ( type , referencesResolver . readAllReferencesFromAnnotation ( type ) ) ; }
a ClassReader for the ProxyAdvice .
the class reader for the given advice .
a string .
the decrypted string .
the logger for the given name .
the cookie name .
a new ActionRequest ( ) { return new ActionRequest ( this ) ; }
< R extends ActionFilter > R createWrapper ( final Class < R > wrapperClass ) { return petiteContainer . createBean ( wrapperClass ) ; }
( final BeanData beanData ) { this . beanData = beanData ; }
all destroyable beans .
the messages from the given folder .
ClusteredServiceContainer .
a report .
error message .
rate of messages .
mapExistingFileReadOnly ( final File location ) { if ( ! location . exists ( ) ) { final String msg = " file not found : " + location . getAbsolutePath ( ) ; throw new IllegalStateException ( msg ) ; } MappedByteBuffer mappedByteBuffer = null ; try ( RandomAccessFile file = new RandomAccessFile ( location , " r " ) ; FileChannel channel = file . getChannel ( ) ) { mappedByteBuffer = channel . map ( READ_ONLY , 0 , channel . size ( ) ) ; } }
the replay session .
the work count of the current recording .
the position of the raw tail .
a new position to the buffer .
padding to the current position .
the session .
for error response .
replay request .
a new image to the subscription .
image .
channel status .
channel status .
the buffer .
to the specified buffer .
the subscription .
mapLossReport ( final String aeronDirectoryName , final int reportFileLength ) { return mapNewFile ( file ( aeronDirectoryName ) , reportFileLength , false ) ; }
< StreamCompositeKey , List < StreamPosition > > snapshot ( ) { final Map < StreamCompositeKey , List < StreamPosition > > streams = new HashMap < > ( ) ; counters . forEach ( ( counterId , typeId , keyBuffer , label ) -> { if ( ( typeId >= PUBLISHER_LIMIT_TYPE_ID && typeId <= RECEIVER_POS_TYPE_ID ) || typeId == SENDER_LIMIT_TYPE_ID || typeId == PER_IMAGE_TYPE_ID || typeId == PUBLISHER_POS_TYPE_ID ) { final StreamCompositeKey key = new StreamCompositeKey ( keyBuffer . getInt ( SESSION_ID_OFFSET ) , keyBuffer . getInt ( STREAM_ID_OFFSET ) , keyBuffer . getStringAscii ( CHANNEL_OFFSET ) ) ; final StreamPosition position = new StreamPosition ( keyBuffer . getLong ( REGISTRATION_ID_OFFSET ) , counters . getCounterValue ( counterId ) , typeId )
a new header .
the key buffer .
the label buffer .
the response channel .
request to the response channel .
the session request .
startRecordingRequestEncoder = new StartRecordingRequestEncoder ( ) ; return this ; }
recording .
a replay request .
stopReplayRequestEncoder = new StopReplayRequestEncoder ( ) ; return this ; }
a list of recordings .
list recordings for uri .
a list recording request .
the recording request .
the recording position .
the stop position .
a list of recording subscriptions .
the tag of the given udp channel .
the destination address of the given channel .
the description of the UdpChannel .
an image connection to the specified transport .
a new packet .
( final Counters counters ) { final AtomicBuffer buffer = counters . metaDataBuffer ( ) ; for ( int i = 0 , size = counters . maxCounterId ( ) ; i < size ; i ++ ) { final int recordOffset = CountersReader . metaDataOffset ( i ) ; if ( counters . getCounterState ( i ) == RECORD_ALLOCATED && buffer . getInt ( recordOffset + TYPE_ID_OFFSET ) == CONTROL_TOGGLE_TYPE_ID ) { return new AtomicCounter ( counters . valuesBuffer ( ) , i , null ) ; } } return null ; }
String put ( final String key , final String value ) { return params . put ( key , value ) ; }
the channel tag .
the entity tag .
a sessionId to the channel .
the tag from the given string .
padding to the term buffer .
the publisher limit .
new UnsafeBufferPosition ( final MutableDirectBuffer tempBuffer ) { return allocate ( tempBuffer ) ; }
the name of the PublisherLimit type .
the length of the term buffer .
the channel uri .
UDP media .
the prefix of the channel .
a ChannelUriStringBuilder with the given media .
the specified control mode .
the length of the term .
the term offset .
a ChannelUriStringBuilder with the lingerNs .
( DatagramChannel udpChannel ) { DatagramChannel sendDatagramChannel = null ; DatagramChannel receiveDatagramChannel = null ; try { sendDatagramChannel = DatagramChannel . open ( udpChannel . protocolFamily ( ) ) ; receiveDatagramChannel = DatagramChannel . open ( udpChannel . protocolFamily ( ) ) ; if ( udpChannel . isMulticast ( ) ) { if ( null != connectAddress ) { receiveDatagramChannel = DatagramChannel . open ( udpChannel . protocolFamily ( ) ) ; } receiveDatagramChannel . setOption ( StandardSocketOptions . SO_REUSEADDR , true ) ; receiveDatagramChannel . bind ( new InetSocketAddress ( endPointAddress . getPort ( ) ) ) ; receiveDatagramChannel . join ( endPointAddress . getAddress ( ) , udpChannel . localInterface ( ) ) ; sendDatagramChannel . setOption ( StandardSocketOptions . IP_MULTICAST_IF , udpChannel . localInterface ( )
the connection .
if a frame is valid .
a InetSocketAddress from a DatagramChannel .
onNak ( final int termId , final int termOffset , final int length , final RetransmitSender retransmitSender ) { if ( ! isInvalid ( termOffset , termLength ) ) { if ( null == activeRetransmitsMap . get ( termId , termOffset ) && activeRetransmitsMap . size ( ) < MAX_RETRANSMITS_DEFAULT ) { final RetransmitAction action = assignRetransmitAction ( ) ; action . termId = termId ; action . termOffset = termOffset ; action . length = Math . min ( length , termLength - termOffset ) ; final long delay = delayGenerator . generateDelay ( ) ; if ( 0 == delay ) { retransmitSender . resend ( termId , termOffset , action . length ) ; action . linger ( lingerTimeoutGenerator . generateDelay ( ) , nanoClock . nanoTime ( ) ) ; }
( final long nowNs , final RetransmitActionPool < RetransmitAction > retransmitActionPool ) { if ( retransmitActionPool != null && retransmitActionPool . size ( ) > 0 ) { for ( final RetransmitAction action : retransmitActionPool ) { if ( DELAYED == action . state && ( action . expireNs - nowNs < 0 ) ) { retransmitSender . resend ( action . termId , action . termOffset , action . length ) ; action . linger ( lingerTimeoutGenerator . generateDelay ( ) , nanoClock . nanoTime ( ) ) ; } else if ( LINGERING == action . state && ( action . expireNs - nowNs < 0 ) ) { action . cancel ( ) ; activeRetransmitsMap . remove ( action . termId , action . termOffset ) ; } } } }
the status of the application .
a new counter .
the buffer .
a new DirectBufferVector from the buffer .
the length of a DirectBufferVector .
the default term window length .
( final MediaDriver . Context ctx ) throws ConfigurationException { try ( DatagramChannel probe = DatagramChannel . open ( ) ) { final int defaultSoSndBuf = probe . getOption ( StandardSocketOptions . SO_SNDBUF ) ; probe . setOption ( StandardSocketOptions . SO_SNDBUF , Integer . MAX_VALUE ) ; final int maxSoSndBuf = probe . getOption ( StandardSocketOptions . SO_SNDBUF ) ; if ( maxSoSndBuf < ctx . socketSndbufLength ( ) ) { System . err . format ( " WARNING : Could not get desired SO _ SNDBUF , adjust OS to allow % s : attempted = % d , actual = % d % n " , SOCKET_SNDBUF_LENGTH_PROP_NAME , ctx . socketSndbufLength ( ) , maxSoSndBuf ) ; } probe . setOption ( StandardSocketOptions .
page size .
a session id range .
( final long publicationUnblockTimeoutNs , final long clientLivenessTimeoutNs , final long timerIntervalNs ) { validateUnblockTimeout ( publicationUnblockTimeoutNs , clientLivenessTimeoutNs , timerIntervalNs ) ; }
errorCode ( final ErrorCode code ) { buffer . putInt ( offset + ERROR_CODE_OFFSET , code . value ( ) ) ; return this ; }
whether the ballot is sent or not .
the cluster members to a string .
a member status publication to the channel .
the member publication .
the active quorum .
the quorum position .
log position .
true if the vote has been reached .
the number of votes for a given cluster member .
the majority of the cluster members .
the cluster member .
( final ClusterMember member ) { final ClusterMember endpointMember = ClusterMember . parseEndpoints ( Aeron . NULL_VALUE , memberEndpoints ) ; if ( ! areSameEndpoints ( member , endpointMember ) ) { throw new ClusterException ( " clusterMembers and memberEndpoints differ : " + member . endpointsDetail ( ) + " ! = " + memberEndpoints ) ; } }
if the two endpoints are the same .
( final ClusterMember [ ] clusterMembers ) { for ( final ClusterMember member : clusterMembers ) { if ( NULL_POSITION == member . logPosition || compareLog ( candidate , member ) < 0 ) { return false ; } } return true ; }
whether a cluster member is a quorum candidate .
if the endpoint is already in the cluster .
the index of the cluster member .
a member from the cluster .
the high id of the cluster member .
a new CnC file .
if driver is active .
whether the driver is active .
whether the driver is active .
( final File directory , final DirectBuffer tokenBuffer , final int tokenOffset , final int tokenLength ) { final File cncFile = new File ( directory , CncFileDescriptor . CNC_FILE ) ; if ( cncFile . exists ( ) && cncFile . length ( ) > 0 ) { final MappedByteBuffer cncByteBuffer = IoUtil . mapExistingFile ( cncFile , " CnC file " ) ; try { final UnsafeBuffer cncMetaDataBuffer = CncFileDescriptor . createMetaDataBuffer ( cncByteBuffer ) ; final int cncVersion = cncMetaDataBuffer . getIntVolatile ( cncVersionOffset ( 0 ) ) ; if ( CncFileDescriptor . CNC_VERSION != cncVersion ) { throw new AeronException ( " Aeron CnC version does not match : required = " + CncFileDescriptor . CNC_VERSION + " version = " + cncVersion ) ; }
the frame length of the term .
the length of the frame .
the type of the frame .
( final UnsafeBuffer buffer , final int termOffset , final byte flags ) { buffer . putByte ( flagsOffset ( termOffset ) , flags ) ; }
( final UnsafeBuffer buffer , final int termOffset ) { buffer . putInt ( termOffsetOffset ( termOffset ) , termOffset , LITTLE_ENDIAN ) ; }
( final UnsafeBuffer buffer , final int termOffset , final int termId ) { buffer . putInt ( termIdOffset ( termOffset ) , termId , LITTLE_ENDIAN ) ; }
( final CountersReader countersReader , final long recordingId ) { final DirectBuffer buffer = countersReader . metaDataBuffer ( ) ; for ( int i = 0 , size = countersReader . maxCounterId ( ) ; i < size ; i ++ ) { if ( countersReader . getCounterState ( i ) == RECORD_ALLOCATED ) { final int recordOffset = CountersReader . metaDataOffset ( i ) ; if ( buffer . getLong ( recordOffset + KEY_OFFSET + RECORDING_ID_OFFSET ) == recordingId ) { return i ; } } else if ( buffer . getLong ( recordOffset + KEY_OFFSET + RECORDING_ID_OFFSET ) == recordingId ) { return i ; } } }
( final CountersReader countersReader , final int sessionId ) { final DirectBuffer buffer = countersReader . metaDataBuffer ( ) ; for ( int i = 0 , size = countersReader . maxCounterId ( ) ; i < size ; i ++ ) { if ( countersReader . getCounterState ( i ) == RECORD_ALLOCATED ) { final int recordOffset = countersReader . metaDataOffset ( i ) ; if ( buffer . getInt ( recordOffset + KEY_OFFSET + SESSION_ID_OFFSET ) == sessionId && buffer . getInt ( recordOffset + KEY_OFFSET + SESSION_ID_OFFSET ) == sessionId ) { return i ; } } } return NULL_COUNTER_ID ; }
the recording id from the counters reader .
( final CountersReader countersReader , final int counterId , final long recordingId ) { final DirectBuffer buffer = countersReader . metaDataBuffer ( ) ; if ( countersReader . getCounterState ( counterId ) == RECORD_ALLOCATED ) { final int recordOffset = CountersReader . metaDataOffset ( counterId ) ; return buffer . getInt ( recordOffset + TYPE_ID_OFFSET ) == RECORDING_POSITION_TYPE_ID && buffer . getLong ( recordOffset + KEY_OFFSET + RECORDING_ID_OFFSET ) == recordingId ; } return false ; }
applicationSpecificFeedback ( final byte [ ] source , final int offset , final int length ) { frameLength ( HEADER_LENGTH ) ; putBytes ( APP_SPECIFIC_FEEDBACK_FIELD_OFFSET , source , offset , length ) ; return this ; }
the entries from the file .
the last term in the list .
a recovery plan .
a recovery plan .
the leadership term to the next entry .
a snapshot of a given record .
the log position .
tombstoneEntry .
the publication .
( final DirectBufferVector headerVector ) { if ( headerVector != vectors [ 0 ] ) { vectors [ 0 ] = headerVector ; } return publication . offer ( vectors , null ) ; }
unblock ( final UnsafeBuffer logMetaDataBuffer ) { return TermUnblocker . unblock ( logMetaDataBuffer ) ; }
the length of the channel .
channel ( final String channel ) { lengthOfChannel = buffer . putString ( offset + CHANNEL_OFFSET , channel ) ; return this ; }
the length of the term .
whether the page size is a power of two .
the active term count .
the position of the active term .
the length of the log meta data .
default frame header .
default header to the term buffer .
the log .
( final UnsafeBuffer metadataBuffer , final int partitionIndex , final int termId ) { metadataBuffer . putLong ( TERM_TAIL_COUNTERS_OFFSET + ( partitionIndex * SIZE_OF_LONG ) , packTail ( termId , 0 ) ) ; }
the offset of the raw tail .
rawTailVolatile ( final UnsafeBuffer metadataBuffer ) { final int partitionIndex = indexByTermCount ( activeTermCount ( metadataBuffer ) ) ; return metadataBuffer . getLongVolatile ( TERM_TAIL_COUNTERS_OFFSET ) ; }
( final UnsafeBuffer metadataBuffer , final int partitionIndex , final long expectedRawTail , final long updateRawTail ) { final int index = TERM_TAIL_COUNTERS_OFFSET + ( SIZE_OF_LONG * partitionIndex ) ; return metadataBuffer . compareAndSetLong ( index , expectedRawTail , updateRawTail ) ; }
tokenBuffer ( final DirectBuffer tokenBuffer ) { this . tokenBuffer = tokenBuffer ; return this ; }
a counter .
the counter id .
the Replay state from the counters .
the snapshot recording id of the counter .
the flags to a char array .
PublicationMessageFlyweight channel ( final String channel ) { lengthOfChannel = buffer . putStringAscii ( offset + CHANNEL_OFFSET , channel ) ; return this ; }
( final DirectBuffer buffer , final int offset ) { return cluster . offer ( id , responsePublication , buffer , offset , length ) ; }
the buffer .
the frame length .
the frame length .
the driver .
the shared runner .
the position of the frame .
a counter .
the counter id of the service .
a new StreamBacklog instance .
new AtomicCounter ( final MutableDirectBuffer tempBuffer ) { return allocate ( tempBuffer ) ; }
the cncByteBuffer .
( final RecordingDescriptorDecoder decoder , final RecordingDescriptorConsumer consumer ) { consumer . onRecordingDescriptor ( decoder ) ; }
a new slab .
the byte value to the given index .
a null value to the page .
the row ranges for the given filter .
an array element to a GroupType .
a StructType to a GroupType .
the message .
( ) { if ( bitPackedRunHeaderPointer == - 1 ) { return ; } byte bitPackHeader = ( byte ) ( ( bitPackedGroupCount << 1 ) | 1 ) ; baos . setByte ( bitPackedRunHeaderPointer , bitPackHeader ) ; bitPackedGroupCount = 0 ; }
public void readOne ( TProtocol in , TProtocol out ) throws TException { readOneStruct ( in , out ) ; }
a list of Footers .
the summary file .
readFooter ( InputFile file , MetadataFilter filter ) throws IOException { try ( SeekableInputStream in = file . newStream ( ) ) { return readFooter ( file , options , in ) ; } }
next row group .
( ) throws IOException { if ( currentBlock == blocks . size ( ) ) { return readNextFilteredRowGroup ( ) ; } }
readDictionaryPage ( File f ) throws IOException { if ( ! meta . getEncodings ( ) . contains ( Encoding . PLAIN_DICTIONARY ) && ! meta . getEncodings ( ) . contains ( Encoding . RLE_DICTIONARY ) ) { return null ; } if ( f . getPos ( ) != meta . getStartingPos ( ) ) { f . seek ( meta . getStartingPos ( ) ) ; } return readDictionary ( f ) ; }
a new instance of InternalParquetRecordWriter .
( InternalParquetRecordWriter writer ) { if ( writer != null ) { writerList . remove ( writer ) ; } }
row group sizes to the minimum allocation size of the writer .
a scale call back .
the state .
the block .
the column .
dictionary page .
( int valueCount , int uncompressedPageSize , BytesInput bytes , Statistics statistics , Encoding rlEncoding , Encoding dlEncoding , Encoding valuesEncoding ) throws IOException { long beforeHeader = out . getPos ( ) ; innerWriteDataPage ( valueCount , uncompressedPageSize , bytes , statistics , rlEncoding , dlEncoding , valuesEncoding ) ; }
columnChunk ( ColumnDescriptor descriptor , long valueCount , CompressionCodecName compressionCodecName , DictionaryPage dictionaryPage , BytesInput bytes , long uncompressedTotalPageSize , long compressedTotalPageSize , Statistics < ? > totalStats , ColumnIndexBuilder columnIndexBuilder , OffsetIndexBuilder offsetIndexBuilder ) throws IOException { writeColumnChunk ( descriptor , valueCount , compressionCodecName , bytes , uncompressedTotalPageSize , compressedTotalPageSize , totalStats , columnIndexBuilder , offsetIndexBuilder ) ; }
the block .
the contents of the input file to a new position .
the Parquet metadata .
metadata files .
merged metadata file .
( Configuration configuration , Path outputPath ) throws IOException { writeMetadataFile ( configuration , outputPath , JobSummaryLevel . ALL ) ; }
( FileMetaData toMerge , GlobalMetaData mergedMetadata ) { if ( mergedMetadata == null ) { mergedMetadata = new GlobalMetaData ( ) ; } else { mergedMetadata . putAll ( mergedMetadata ) ; } return mergedMetadata ; }
the value in the column .
true if the schema is NULL .
null if the object is not null .
the value of the given string .
ThriftMetaData from extraMetaData .
a ThriftMetaData from the given thrift class .
a Map < String , String > toExtraMetaData ( ) { return null ; }
( int repetitionLevel ) { if ( DEBUG ) log ( null , repetitionLevel , definitionLevel ) ; }
page .
a new block .
values buffer .
the type of the enum .
( int deltaValuesToFlush ) { for ( int miniBlockIndex = 0 ; miniBlockIndex < miniBlocksToFlush ; miniBlockIndex ++ ) { int mask = 0 ; int miniStart = miniBlockIndex * config . miniBlockSizeInValues ; int miniEnd = Math . min ( ( miniBlockIndex + 1 ) * config . miniBlockSizeInValues , deltaValuesToFlush ) ; for ( int i = miniStart ; i < miniEnd ; i ++ ) { mask |= deltaBlockBuffer [ i ] ; } bitWidths [ miniBlockIndex ] = 32 - Integer . numberOfLeadingZeros ( mask ) ; } }
( Throwable t ) { throw t ; }
( PrimitiveTypeName type ) { switch ( type ) { case INT32 : return new IntStatistics ( ) ; case INT64 : return new LongStatistics ( ) ; case FLOAT : return new FloatStatistics ( ) ; case DOUBLE : return new DoubleStatistics ( ) ; case BOOLEAN : return new BooleanStatistics ( ) ; case BINARY : return new BinaryStatistics ( ) ; case INT96 : return new BinaryStatistics ( ) ; case FIXED_LEN_BYTE_ARRAY : return new BinaryStatistics ( ) ; default : throw new UnknownColumnTypeException ( type ) ; } }
getBuilderForReading ( PrimitiveType type ) { switch ( type . getPrimitiveTypeName ( ) ) { case FLOAT : return new FloatBuilder ( type ) ; case DOUBLE : return new DoubleBuilder ( type ) ; default : return new Builder ( type ) ; } }
the statistics of the given type .
a nullable schema .
a new TaskAttemptContext .
the given method .
the members of the given type .
the fields of the GroupType .
the counter loader .
getFilter ( Configuration conf ) { return FilterCompat . get ( getFilterPredicate ( conf ) , getUnboundRecordFilterInstance ( conf ) ) ; }
< Footer > getFooters ( Configuration configuration ) throws IOException { LOG . debug ( " reading { } files " , statuses . size ( ) ) ; boolean taskSideMetaData = isTaskSideMetaData ( configuration ) ; return ParquetFileReader . readAllFootersInParallelUsingSummaryFiles ( configuration , statuses , taskSideMetaData ) ; }
( List < BlockMetaData > rowGroupBlocks , BlockLocation [ ] hdfsBlocksArray , String requestedSchema , Map < String , String > readSupportMetadata , long minSplitSize , long maxSplitSize ) throws IOException { List < SplitInfo > splitRowGroups = generateSplitInfo ( rowGroupBlocks , hdfsBlocksArray , minSplitSize , maxSplitSize ) ; List < ParquetInputSplit > resultSplits = new ArrayList < ParquetInputSplit > ( ) ; for ( SplitInfo splitInfo : splitRowGroups ) { ParquetInputSplit split = splitInfo . getParquetInputSplit ( fileStatus , requestedSchema , readSupportMetadata ) ; resultSplits . add ( split ) ; } return resultSplits ; }
a message .
mapping of fields to parquet schema .
the message descriptor .
a DirectCodecFactory ( ) { return new DirectCodecFactory ( ) ; }
( StructType recordThriftType ) throws TException { Iterator < TProtocol > protocolIter = rootEvents . iterator ( ) ; checkStruct ( protocolIter , recordThriftType ) ; return fixedEvents ; }
if the field is set .
the fileMetaData .
the record writer .
the schema of the job .
a class to the parquet type .
the type of the given column .
the value to an int .
a SchemaMapping from the arrow schema .
a new SchemaMapping from the parquet schema .
< Schema , TypeMapping > map ( Schema arrowSchema , MessageType parquetSchema ) { List < Schema > children = map ( arrowSchema . getFields ( ) , parquetSchema . getFields ( ) ) ; return new SchemaMapping ( arrowSchema , parquetSchema , children ) ; }
( int uncompressedSize , int compressedSize , int valueCount , int nullCount , int rowCount , org . apache . parquet . column . Encoding dataEncoding , int rlByteLength , int dlByteLength ) throws IOException { writePageHeader ( newDataPageV2Header ( uncompressedSize , compressedSize , valueCount , nullCount , rowCount , dataEncoding , rlByteLength , dlByteLength ) , to ) ; }
the next record .
the object to a base64 string .
cache entry .
a new cache entry for the given key .
the current value of the given key .
a value to a non null Avro schema .
a record to the avro schema .
a wildcard character class .
the content to a file .
a file .
column ( final String columnPath , final ColumnPredicates . Predicate predicate ) { checkNotNull ( columnPath , " columnPath " ) ; checkNotNull ( predicate , " predicate " ) ; checkNotNull ( predicate , " predicate " ) ; return new UnboundRecordFilter ( ) { final String [ ] filterPath = columnPath . split ( " \\ . " ) ; @ Override public RecordFilter bind ( Iterable < ColumnReader > readers ) { for ( ColumnReader reader : readers ) { if ( Arrays . equals ( reader . getDescriptor ( ) . getPath ( ) , filterPath ) ) { return new ColumnRecordFilter ( reader , predicate ) ; } } throw new IllegalArgumentException ( " Column " + columnPath + " does not exist . " ) ; } } ; }
the struct to a MessageType .
listWrapper ( Repetition repetition , String alias , LogicalTypeAnnotation logicalTypeAnnotation , Type nested ) { if ( nested . isRepetition ( Repetition . REPEATED ) ) { throw new IllegalArgumentException ( " Nested type should be repeated : " + nested ) ; } return new GroupType ( repetition , alias , logicalTypeAnnotation , nested ) ; }
a list of elements .
merged key values from mergedKeyValueMetadata .
getSplit ( final InputSplit oldSplit , final JobConf conf ) throws IOException { if ( oldSplit instanceof FileSplit ) { FileSplit fileSplit = ( FileSplit ) oldSplit ; final long splitStart = fileSplit . getStart ( ) ; final long splitLength = fileSplit . getLength ( ) ; final Path finalPath = fileSplit . getPath ( ) ; final JobConf cloneJob = hiveBinding . cloneJob ( conf ) ; if ( cloneJob == null ) { return new ParquetInputSplit ( finalPath , splitStart , splitLength , fileSplit . getLocations ( ) , null ) ; } return new ParquetInputSplit ( finalPath , splitStart , splitLength , fileSplit . getLocations ( ) , null ) ; } return null ; }
< String , Class < ? > > getFieldsByName ( Class < ? > recordClass , boolean excludeJava ) { return getFieldsByName ( recordClass , excludeJava ) ; }
the requested schema .
input files from the specified directory .
Parquet files .
< Path > getInputFilesFromDirectory ( Path partitionDir ) throws IOException { FileSystem fs = partitionDir . getPath ( ) . getFileSystem ( conf ) ; FileStatus [ ] inputFiles = fs . listStatus ( partitionDir . getPath ( ) , HiddenFileFilter . INSTANCE ) ; List < Path > input = new ArrayList < Path > ( ) ; for ( FileStatus f : inputFiles ) { input . add ( f . getPath ( ) ) ; } return input ; }
page ( final long startPos , final long pageSize ) { return new UnboundRecordFilter ( ) { @ Override public RecordFilter bind ( Iterable < ColumnReader > readers ) { return new PagedRecordFilter ( startPos , pageSize ) ; } } ; }
< List < T > > listOf ( Class < T > c , Consumer < List < T > > consumer ) { class ListConsumer implements Consumer < T > { List < T > list ; @ Override public void consume ( T t ) { list . add ( t ) ; consumer . consume ( list ) ; } } return consumer ; }
the mapred work .
TupleSummaryData ( Tuple t ) throws IOException { TupleSummaryData summaryData = new TupleSummaryData ( ) ; DataBag bag = t . get ( 0 ) ; for ( Tuple tuple : bag ) { summaryData . merge ( getData ( tuple ) ) ; } return summaryData ; }
( Schema schema ) throws IOException { TupleSummaryData summaryData = new TupleSummaryData ( ) ; DataBag bag = ( DataBag ) t . get ( 0 ) ; for ( Tuple tuple : bag ) { summaryData . addTuple ( schema , tuple ) ; } return summaryData ; }
( FieldConsumer c ) throws TException { protocol . readStructBegin ( ) ; readStructContent ( c ) ; protocol . readStructEnd ( ) ; }
a map entry .
the value to the packed slab .
( ByteBuffer in , int offset ) throws IOException { int ch4 = in . get ( offset ) & 0xff ; int ch3 = in . get ( offset + 1 ) & 0xff ; int ch2 = in . get ( offset + 2 ) & 0xff ; int ch1 = in . get ( offset + 3 ) & 0xff ; return ( ( ch1 << 24 ) + ( ch2 << 16 ) + ( ch3 << 8 ) + ( ch4 << 0 ) ) ; }
the schema of the job .
a new topic .
PipelineStageBeans .
a StageBean .
for the stage library .
interceptor .
the schema .
the number of days in the local time zone .
the json schema from the header .
v1 to v2 .
the length of the text file .
blobstore resources to the staging blobstore directory .
columns ( ) { this . columns . clear ( ) ; this . columnsExpected = null ; columnNames = null ; table = null ; schema = null ; insideStatement = false ; }
the thread health report .
a thread health report gauge .
the control hub configuration file .
whether the user is authenticated .
the pipeline configuration .
a StageLibraryTask to a StageConfiguration .
the StageConfiguration to the latest version .
the service to the given version .
stage instance from version to version .
the fields to null .
whether a class is a system class .
a new element to the list .
( E e ) { checkNotNull ( e ) ; if ( maxSize == 0 ) { return null ; } E evicted = null ; if ( size ( ) == maxSize ) { evicted = delegate . remove ( ) ; } delegate . add ( e ) ; return evicted ; }
< Value > valueOrDefault ( Key key , Optional < Value > defaultValue ) { if ( value . isPresent ( ) ) { return value ; } if ( ! cacheMissingValues ) { delegate . invalidate ( key ) ; } return defaultValue ; }
< StageOutput > addReportedErrorsIfNeeded ( List < StageOutput > snapshotsOfAllStagesOutput ) { synchronized ( this . reportedErrors ) { if ( reportedErrors . isEmpty ( ) ) { return snapshotsOfAllStagesOutput ; } try { return snapshotsOfAllStagesOutput . stream ( ) . map ( so -> new StageOutput ( so . getInstanceName ( ) , so . getOutput ( ) , so . getErrorRecords ( ) , reportedErrors . get ( so . getInstanceName ( ) ) , so . getEventRecords ( ) ) ) . collect ( Collectors . toList ( ) ) ; } finally { reportedErrors . clear ( ) ; } } }
. Descriptor getDescriptor ( ProtoConfigurableEntity . Context context , String protoDescriptorFile , String messageType , Map < String , Set < Descriptors . FieldDescriptor > > messageTypeToExtensionMap , Map < String , Object > defaultValueMap ) throws StageException { File descriptorFileHandle = new File ( context . getResourcesDirectory ( ) , protoDescriptorFile ) ; try ( FileInputStream fin = new FileInputStream ( descriptorFileHandle ) ; ) { DescriptorProtos . FileDescriptorSet set = DescriptorProtos . FileDescriptorSet . parseFrom ( fin ) ; return set ; } }
all file descriptors for a given descriptor .
( Map < String , Descriptors . FileDescriptor > fileDescriptorMap , Map < String , Set < Descriptors . FieldDescriptor > > typeToExtensionMap , Map < String , Object > defaultValueMap ) { for ( Descriptors . FileDescriptor f : fileDescriptorMap . values ( ) ) { for ( Descriptors . FieldDescriptor fieldDescriptor : f . getExtensions ( ) ) { String containingType = fieldDescriptor . getContainingType ( ) ; Set < Descriptors . FieldDescriptor > fieldDescriptors = typeToExtensionMap . get ( containingType ) ; if ( fieldDescriptors == null ) { fieldDescriptors = new LinkedHashSet < > ( ) ; typeToExtensionMap . put ( containingType , fieldDescriptors ) ; } fieldDescriptors . add ( fieldDescriptor ) ; if ( fieldDescriptor . hasDefaultValue ( ) ) { defaultValueMap . put ( containingType + " . " + fieldDescriptor . getName ( ) , fieldDescriptor . getDefaultValue ( ) ) ; } } } }
the descriptor for the given message type .
a protobuf message to a sdc field .
the message to a dynamic message .
a protobuf message to a dynamic message .
to JerseyConfigBean .
a connection to the KuduClient .
the kudu type to a byte array .
a field for the given type .
the records .
the line from the buffer .
missing configurations to stage .
the response .
a response header to the response .
the response header to a Field .
( Response response ) { for ( Map . Entry < String , List < String > > entry : response . getStringHeaders ( ) . entrySet ( ) ) { if ( ! entry . getValue ( ) . isEmpty ( ) ) { String firstValue = entry . getValue ( ) . get ( 0 ) ; header . setAttribute ( conf . headerAttributePrefix + entry . getKey ( ) , firstValue ) ; } } }
metadata to the new metadata file .
the client .
( BatchMaker batchMaker ) throws StageException { HttpSourceOffset sourceOffset = new HttpSourceOffset ( getResolvedUrl ( ) , currentParameterHash , System . currentTimeMillis ( ) , getCurrentPage ( ) ) ; Record record = getContext ( ) . createRecord ( sourceOffset + " : :0" ) ; addResponseHeaders ( record . getHeader ( ) ) ; record . set ( Field . create ( new HashMap ( ) ) ) ; record . set ( Field . create ( new HashMap ( ) ) ) ; batchMaker . addRecord ( record ) ; recordCount ++ ; incrementSourceOffset ( sourceOffset , 1 ) ; lastRequestCompletedTime = System . currentTimeMillis ( ) ; return sourceOffset . toString ( ) ; }
the source offset .
( BatchMaker batchMaker , String sourceOffset , Record record ) throws StageException { int numSubRecords = 0 ; if ( ! record . has ( conf . pagination . resultFieldPath ) ) { final StageException stageException = new StageException ( Errors . HTTP_12 , conf . pagination . resultFieldPath ) ; LOG . error ( stageException . getMessage ( ) ) ; throw stageException ; } addResponseHeaders ( record . getHeader ( ) ) ; batchMaker . addRecord ( record ) ; return numSubRecords ; }
a header to the response .
a MultivaluedMap < String , Object > .
the response from the server .
propertyDefined ( Configuration conf , String propertyName ) { String prop = conf . get ( propertyName ) ; return prop != null && ! prop . isEmpty ( ) && ! prop . equals ( " - 1" ) ; }
a RecoverableDataParserException to a DataParserException .
a DataGeneratorException to a DataGeneratorException .
the credentials from the given path .
previewWithOverride ( String pipelineId , List < StageOutputJson > stageOutputsToOverrideJson ) { if ( pipelineId == null ) { throw new ApiException ( 400 , " Missing the required parameter ' pipelineId ' when calling previewWithOverride " ) ; } if ( stageOutputsToOverrideJson == null ) { throw new ApiException ( 400 , " Missing the required parameter ' stageOutputsToOverrideJson ' when calling previewWithOverride " ) ; } return previewWithOverride ( pipelineId , stageOutputsToOverrideJson ) ; }
( char [ ] cb , int startChar , int currentChar ) { if ( cb == null ) { cb = " " ; } if ( startChar == currentChar ) { cb = " " ; } if ( cb == " " ) { cb = " " ; } if ( cb == " " ) { cb = " " ; } if ( cb == " " ) { cb = " " ; } if ( cb == " " ) { cb = " " ; } if ( cb == " " ) { cb = " " ; } if ( cb == " " ) { cb = " " ; } if ( cb == " " ) { cb = " " ; } if ( cb == " " ) { cb = " " ; } if ( cb == " " ) { cb = " " ; } if ( cb == " " ) { cb = " " ; } return cb ; }
logical duplicates .
the current writer .
( LiveFileChunk chunk , Pattern pattern ) { if ( pattern == null ) { pattern = Pattern . compile ( " . * " ) ; } if ( pattern == null ) { pattern = Pattern . compile ( " . * " ) ; } if ( pattern == null ) { pattern = Pattern . compile ( " . * " ) ; } if ( pattern . matcher ( lines . get ( 0 ) . getText ( ) . trim ( ) ) . matches ( ) ) { found = - 1 ; } else if ( pattern . matcher ( lines . get ( 0 ) . getText ( ) . trim ( ) ) . matches ( ) ) { found = - 1 ; } else { found = - 1 ; } return found ; }
a live file chunk .
the connection .
.
getFlowControlSettings ( ) { return FlowControlSettings . newBuilder ( ) . setLimitExceededBehavior ( FlowController . LimitExceededBehavior . Block ) . setMaxOutstandingElementCount ( ( long ) conf . basic . maxBatchSize * conf . maxThreads ) . build ( ) ; }
( ) { return SubscriptionAdminSettings . defaultGrpcTransportProviderBuilder ( ) . setMaxInboundMessageSize ( MAX_INBOUND_MESSAGE_SIZE ) . setEndpoint ( SubscriptionAdminSettings . getDefaultEndpoint ( ) ) . build ( ) ; }
the offset of the data channel .
expression into a Grok .
a digest expression from the original expression .
a dictionary to a file .
a dictionary to a file .
aggregators .
a new data window .
the object to a string .
a String body .
the file .
the exception detail message .
( ELEval elEval , ELVars variables , String val ) throws ELEvalException { return elEval . eval ( variables , val , String . class ) ; }
( LinkedHashMap < String , T > original , String innerPairFirstFieldName , String innerPairSecondFieldName , boolean isSecondFieldHiveType ) throws HiveStageCheckedException { List < Field > columnList = new LinkedList < > ( ) ; for ( Map . Entry < String , T > pair : original . entrySet ( ) ) { LinkedHashMap < String , Field > entry = new LinkedHashMap < > ( ) ; entry . put ( innerPairFirstFieldName , Field . create ( pair . getKey ( ) ) ) ; if ( isSecondFieldHiveType ) { HiveTypeInfo hiveTypeInfo = ( HiveTypeInfo ) pair . getValue ( ) ; entry . put ( innerPairSecondFieldName , hiveTypeInfo . getHiveType ( ) . getSupport ( ) . generateHiveTypeInfoFieldForMetadataRecord ( hiveTypeInfo ) ) ; } else { entry . put ( innerPairSecondFieldName , Field . create ( pair . getValue ( ) . toString ( ) ) ) ; } columnList .
the table name from the metadata record .
the database name from the metadata record .
the internal field from the metadata record .
the location of the metadata record .
the custom location from the metadata record .
the AVRO schema from the metadata record .
the data format from the metadata record .
a new SchemaMetadataFieldBuilder for the given database .
partition information .
the partition path .
Avro Schema to HDFS .
the parameters to the statement .
the configuration of the system .
( String ts , String rfc3164Format ) throws OnRecordErrorException { if ( ts . length ( ) == 0 ) { throw new OnRecordErrorException ( Errors . SYSLOG_10 , ts ) ; } if ( ts . length ( ) == 0 ) { throw new OnRecordErrorException ( Errors . SYSLOG_10 , ts ) ; } if ( ts . length ( ) == 0 ) { throw new OnRecordErrorException ( Errors . SYSLOG_10 , ts ) ; } if ( ts . length ( ) == 0 ) { throw new OnRecordErrorException ( Errors . SYSLOG_10 , ts ) ; } if ( ts . length ( ) == 0 ) { throw new OnRecordErrorException ( Errors . SYSLOG_10 , ts ) ; } if ( ts . length ( ) == 0 ) { throw new OnRecordErrorException ( Errors . SYSLOG_10 , ts ) ; } if ( ts
the template .
the batch .
if record contains solr fields .
autogenerated field names .
onRecordErrorExceptionToHandler ( OnRecordErrorException errorRecordHandler ) { if ( errorRecordHandler != null ) { errorRecordHandler . onError ( new OnRecordErrorException ( record , error ) ) ; } }
the jar name .
( URL url ) { return parseJarName ( url . toString ( ) , Paths . get ( url . getPath ( ) ) . getFileName ( ) ) ; }
new instance of CouchbaseConnector .
the Couchbase bucket .
a Couchbase config .
the label from the given code .
dependency exists .
the value of the given key .
getOperationFromHeader ( Record record ) { return config . operationType ; }
a new document .
a DocumentFragment < Mutation > .
a column to a table .
the kerberos login context .
a batch of data .
the last committed offset .
the consumer error .
the stage to the InjectorContext .
the definitions of the hide stage .
getDefinition ( String name ) { String defConfig = LineagePublisherConstants . configDef ( name ) ; String publisherDefinition = configuration . get ( defConfig , null ) ; if ( StringUtils . isEmpty ( publisherDefinition ) ) { throw new IllegalArgumentException ( Utils . format ( " Missing publisher definition ' { } ' " , defConfig ) ) ; } String [ ] lineagePluginDefs = publisherDefinition . split ( " : : " ) ; if ( lineagePluginDefs . length != 2 ) { throw new IllegalStateException ( Utils . format ( " Invalid publisher definition ' { } ' , expected $ libraryName : : $ publisherName " , publisherDefinition ) ) ; } LineagePublisherDefinition def = stageLibraryTask . getLineagePublisherDefinition ( lineagePluginDefs [ 0 ] , lineagePluginDefs [ 1 ] ) ; return def ; }
the name of the column .
the value to a string .
the pipeline info from the given pipelineId .
a draft pipeline fragment .
< PipelineInfoJson > getPipelines ( String filterText , String label , int offset , int len , PipelineOrderByFields orderBy , Order order ) throws ApiException { Object postBody = null ; byte [ ] postBinaryBody = null ; String path = " / v1 / pipelines " . replaceAll ( " \\ { format \\ } " , " json " ) ; queryParams = new ArrayList < Pair > ( ) ; queryParams . addAll ( apiClient . parameterToPairs ( " " , " filterText " , filterText ) ) ; queryParams . addAll ( apiClient . parameterToPairs ( " " , " label " , label ) ) ; queryParams . addAll ( apiClient . parameterToPairs ( " " , " offset " , offset ) ) ; queryParams . addAll ( apiClient . parameterToPairs ( " " , " len " , len ) ) ; queryParams . addAll ( apiClient . parameterToPairs ( " " , " orderBy " , orderBy ) ) ; queryParams .
( String fragmentId , boolean draft , boolean includeLibraryDefinitions , PipelineFragmentEnvelopeJson fragmentEnvelope ) throws ApiException { Object postBody = fragmentEnvelope ; byte [ ] postBinaryBody = null ; if ( fragmentId == null ) { throw new ApiException ( 400 , " Missing the required parameter ' fragmentId ' when calling importPipelineFragment " ) ; } if ( fragmentEnvelope == null ) { throw new ApiException ( 400 , " Missing the required parameter ' fragmentEnvelope ' when calling importPipelineFragment " ) ; } return importPipelineFragment ( fragmentId , draft , includeLibraryDefinitions , fragmentEnvelope ) ; }
the file path from the given dirPathTemplate .
the operation code from the record .
( String columnName , Map < String , String > columnsToField , int op ) { if ( columnsToField . containsKey ( columnName ) ) { return columnsToField . get ( columnName ) ; } return new GetFieldPath ( columnName , columnsToField , op ) ; }
poll ( ) throws StageException { try { return queue . poll ( ) ; } catch ( InterruptedException e ) { LOG . error ( Errors . MYSQL_001 . getMessage ( ) , e . toString ( ) , e ) ; Thread . currentThread ( ) . interrupt ( ) ; throw new StageException ( Errors . MYSQL_001 , e . toString ( ) , e ) ; } }
the runner from the queue .
the idle runner from the queue .
a runner from the queue .
the container .
( ) { if ( destroyed . get ( ) ) { throw new PipelineRuntimeException ( ContainerError . CONTAINER_0803 , queue . size ( ) ) ; } }
if the stream exists .
the lastShardId of the stream .
a query for a single record .
the exception .
the column hash of the record .
files .
the PID value from the PID field .
the fields to hash .
a proxy user for the given user .
the active stats .
the active stats .
a directory .
a schema table to a JdbcRecordWriter .
the records to the database .
the record to the database .
no more data event .
a new partition .
the record for the given location .
the value of the group .
the version of the given Stage .
the BootstrapClusterStreaming class .
a new authenticated client .
the headers of the given record .
the httpMethod of the given method .
( Bindings bindings ) { bindings . put ( " NULL _ BOOLEAN " , NULL_BOOLEAN ) ; bindings . put ( " NULL _ CHAR " , NULL_CHAR ) ; bindings . put ( " NULL _ BYTE " , NULL_BYTE ) ; bindings . put ( " NULL _ SHORT " , NULL_SHORT ) ; bindings . put ( " NULL _ BYTE _ ARRAY " , NULL_BYTE_ARRAY ) ; bindings . put ( " NULL _ STRING " , NULL_STRING ) ; bindings . put ( " NULL _ LIST " , NULL_LIST ) ; bindings . put ( " NULL _ MAP " , NULL_MAP ) ; }
the value of the field .
the schema from the registry .
a schema to the registry .
the schema from the registry .
the schema id from the subject .
the schema from the registry .
the schema id .
the schema id .
default values from the given schema .
all the records into a single record .
whether the artifacts are valid or not .
the bad records from the error sink .
the schema generator .
outward edge vertices for the given vertex .
the inward edge vertices .
offset map .
offset map .
the Omniture report .
the report from the given URL .
if the file exists .
the offsets to the main offset file .
the BlobId .
the error handling option .
the destination path for the given blob .
the current file .
the reader .
( String dpmBaseURL ) { this . dpmBaseURL = dpmBaseURL ; }
a default header .
( String str ) { try { return dateFormat . parse ( str ) ; } catch ( java . text . ParseException e ) { throw new RuntimeException ( e ) ; } }
a string .
the client for the given basePath .
a GPUDB connection .
the table metadata .
a bulk inserter .
static EventBuilder create ( Stage . Context context , ToEventContext toEvent ) { return new EventBuilder ( context , toEvent ) ; }
the schema .
Operation code to SDC code .
jars to the job .
jars to job .
fieldOrderByList ( SOQLParser . FieldOrderByListContext fieldOrderByList , String fieldName ) { return fieldOrderByList . fieldOrderByElement ( 0 ) . fieldElement ( ) . getText ( ) . equalsIgnoreCase ( fieldName ) ; }
the condition expressions for a given field .
the offset of the live file .
premain ( String args , Instrumentation instrumentation ) { if ( BootstrapMain . instrumentation == null ) { BootstrapMain . instrumentation = instrumentation ; } else { throw new IllegalStateException ( " Premain method cannot be called twice ( " + BootstrapMain . instrumentation + " ) " ) ; } }
the parallelism of the kafka consumer .
BigQuery query .
< String , Field > fieldsToMap ( List < com . google . cloud . bigquery . Field > schema , List < FieldValue > values ) { checkState ( schema . size ( ) == values . size ( ) , " Schema ' { } ' and Values ' { } ' sizes do not match . " , schema . size ( ) , values . size ( ) ) ; LinkedHashMap < String , Field > root = new LinkedHashMap < > ( ) ; for ( int i = 0 ; i < values . size ( ) ; i ++ ) { FieldValue value = values . get ( i ) ; root . put ( field . getName ( ) , Field . create ( fieldsToMap ( field . getSubFields ( ) , value . getFieldValue ( ) ) ) ) ; } return root ; }
the table description .
the table name .
column type for field .
if the type is nullable .
the schema for the table .
column properties for table .
the class of the given type .
aerospike client .
the topic for the given record .
v5 to v6 .
the InputStream from the file .
a file to a temporary file .
whether the file exists or does not .
( String permissions ) throws IllegalArgumentException { try { return FsPermission . valueOf ( permissions ) ; } catch ( IllegalArgumentException e ) { if ( permissions . length ( ) == 9 ) { permissions = " - " + permissions ; } return FsPermission . valueOf ( permissions ) ; } }
all services available .
a simple aggregator .
the aggregator unit .
a new aggregator data .
< A , N > createGroupBy ( String name , Class < ? extends Aggregator > aKlass ) { return createGroupBy ( name , aKlass ) ; }
the dataProvider .
the dataProvider .
a Map < Aggregator , AggregatorData > .
( LoginType loginType ) throws IOException { synchronized ( LoginManager . class ) { LoginManager loginManager = CACHED_INSTANCES . get ( loginType ) ; if ( loginManager == null ) { loginManager = new LoginManager ( loginType , configs ) ; CACHED_INSTANCES . put ( loginType , loginManager ) ; } return loginManager ; } }
the LoginManager .
glob to regex .
< S3ObjectSummary > listObjectsLexicographically ( AmazonS3 s3Client , S3ConfigBean s3ConfigBean , AntPathMatcher pathMatcher , S3Offset s3Offset , int fetchSize ) { List < S3ObjectSummary > list = new ArrayList < > ( fetchSize ) ; ListObjectsRequest listObjectsRequest = new ListObjectsRequest ( ) ; listObjectsRequest . setBucketName ( s3ConfigBean . s3Config . bucket ) ; listObjectsRequest . setPrefix ( s3ConfigBean . s3Config . commonPrefix ) ; listObjectsRequest . setMaxKeys ( BATCH_SIZE ) ; if ( s3Offset . getKey ( ) != null ) { listObjectsRequest . setMarker ( s3Offset . getKey ( ) ) ; } s3Client . listObjects ( listObjectsRequest ) ; return list ; }
the snapshot .
empty batches for any active runner .
a failure snapshot .
recordToBoundStatement ( Record record ) throws StageException { Map < String , String > columnMappings = record . getColumnMappings ( ) ; if ( columnMappings == null || columnMappings . isEmpty ( ) ) { throw new StageException ( Errors . CASSANDRA_06 , record . getHeader ( ) . getSourceId ( ) , record . getHeader ( ) . getSourceId ( ) ) ; } if ( columnMappings . isEmpty ( ) ) { throw new StageException ( Errors . CASSANDRA_06 , record . getHeader ( ) . getSourceId ( ) , record . getHeader ( ) . getSourceId ( ) ) ; } if ( columnMappings . isEmpty ( ) ) { throw new StageException ( Errors . CASSANDRA_06 , record . getHeader ( ) . getSourceId ( ) , record . getHeader ( ) . getSourceId ( ) ) ; } return recordToBoundStatement ( record ) ; }
a new configuration .
a lookup key .
whether the partitioning is turned off or on .
the maximum length of the object .
the multiplier of the timer .
.
.
( String url ) { if ( url . endsWith ( " / " ) ) { url = url . substring ( 0 , url . length ( ) - 1 ) ; } return url ; }
the user token .
the user auth token .
the app auth token file .
dpm . properties file .
the schema for the given field .
a complex schema for the given field .
( Record record , Field field , String attributeName ) throws OnRecordErrorException { int finalValue = - 1 ; String stringValue = field . getAttribute ( attributeName ) ; if ( ! StringUtils . isEmpty ( stringValue ) ) { finalValue = Integer . valueOf ( stringValue ) ; } if ( finalValue < minAllowed ) { throw new OnRecordErrorException ( record , Errors . SCHEMA_GEN_0004 , finalValue , field ) ; } return finalValue ; }
the default value for the given schema .
( ProtoConfigurableEntity . Context context ) { Gauge < Map < String , Object > > gauge = context . getGauge ( fileStatisticGaugeName ( context ) ) ; if ( gauge == null ) { gauge = context . createGauge ( fileStatisticGaugeName ( context ) , Comparator . comparing ( GAUGE_MAP_ORDERING :: get ) ) ; } if ( gauge == null ) { gauge = context . createGauge ( fileStatisticGaugeName ( context ) , Comparator . comparing ( GAUGE_MAP_ORDERING :: get ) ) ; } if ( gauge == null ) { gauge = context . createGauge ( fileStatisticGaugeName ( context ) , Comparator . comparing ( GAUGE_MAP_ORDERING :: get ) ) ; } if ( gauge == null ) { gauge = context . createGauge ( fileStatisticGaugeName ( context ) , Comparator . comparing ( GAUGE_MAP_ORDERING :: get ) ) ; gauge .
the contents of the given file .
the index of the specified group .
< String > groupNames ( ) { return groupNames ; }
isEscapedChar ( String s , int pos ) { return isSlashEscapedChar ( s , pos ) || isQuoteEscapedChar ( s , pos ) ; }
( String s ) { int numSlashes = 0 ; while ( pos > 0 && s . charAt ( pos - 1 ) == ' \ \ ' ) { pos -- ; numSlashes ++ ; } return numSlashes % 2 != 0 ; }
if the given string contains a closing bracket .
the number of open parens in the given string .
group info from named pattern .
a string with a replacement .
a list of objects from a given request .
the schema of the given table .
if the current transaction is expired .
the offset of the LiveFileReder .
forward to the end of the buffer .
detached stage envelope .
a string to a number .
( int startOffset , ByteBuf buf , Map < String , Field > fields ) throws OnRecordErrorException { int offset = startOffset ; while ( offset < buf . getUnsignedShort ( offset ) ) { if ( fields . containsKey ( PART_TYPES . get ( PART_TYPES . get ( PART_TYPES . get ( PART_TYPES . get ( PART_TYPES . get ( PART_TYPES . get ( PART_TYPES . get ( PART_TYPES . get ( PART_TYPES . get ( PART_TYPES . get ( PART_TYPE ) ) ) ) ) ) ) ) ) ) ) { return offset ; } } return offset ; }
the number of values .
the primary keys from the database .
custom field mappings .
the type of the field .
the name of the table .
the primary keys of the record .
the exception .
the report error delegate .
( BatchContextImpl batchContext ) { if ( batchContext . isBatchMaker ( ) ) { return batchContext ; } if ( batchContext . isBatchMaker ( ) ) { return batchContext ; } return batchContext ; }
the current batch .
( Field rootField ) { Map < String , Field > ret = new LinkedHashMap < > ( ) ; switch ( rootField . getType ( ) ) { case MAP : case LIST_MAP : flattenMap ( " " , rootField . getValueAsMap ( ) , ret ) ; break ; case LIST : flattenList ( " " , rootField . getValueAsList ( ) , ret ) ; break ; case MAP : flattenMap ( " " , rootField . getValueAsMap ( ) , ret ) ; break ; case LIST_LIST : flattenList ( " " , rootField . getValueAsList ( ) , ret ) ; break ; default : break ; } return ret ; }
< T > create ( StageBean bean , Stage . Info info , Stage . Context context ) { return new DetachedStageRuntime < T > ( bean , info , context ) ; }
the exception detail message .
columns to parameters .
the condition for the partition column .
offsets for the given table .
< BundleContentGeneratorDefinition > getRequestedDefinitions ( List < String > definitions ) { Stream < BundleContentGeneratorDefinition > stream = definitions . stream ( ) ; if ( generators == null || generators . isEmpty ( ) ) { stream = stream . filter ( BundleContentGeneratorDefinition :: isEnabledByDefault ) ; } else { stream = stream . filter ( BundleContentGeneratorDefinition :: isEnabledByDefault ) ; } return stream ; }
a list of non empty values .
a new operation for the given table .
( double bytes ) { DecimalFormat df = new DecimalFormat ( " # . # " ) ; int unitIdx = 0 ; while ( unitIdx < UNITS . length && Math . floor ( unitChangedBytes / 1024 ) > 0 ) { unitChangedBytes = unitChangedBytes / 1024 ; unitIdx ++ ; } return df . format ( bytes ) ; }
a LiveFile .
( LiveFile current ) throws IOException { if ( rollMode . isCurrentAcceptable ( current . getPath ( ) . getFileName ( ) . toString ( ) ) ) { return findToBeProcessedMatchingFiles ( current != null ? current . refresh ( ) : null ) . size ( ) ; } return 0 ; }
whether the Whitelist rule is whitelisted .
the versions of the given version .
BootstrapClusterStreaming . main ( String [ ] args ) throws Exception { SparkStreamingBinding binding = null ; try { binding = SparkStreamingBindingFactory . build ( BootstrapCluster . getProperties ( ) ) ; binding . init ( ) ; BootstrapCluster . createTransformers ( binding . getStreamingContext ( ) , binding . getSparkSession ( ) ) ; binding . startContext ( ) ; binding . awaitTermination ( ) ; } catch ( Exception e ) { throw new Exception ( e ) ; } }
( PipelineBean pipelineBean ) { return ; }
( ) { if ( ! jsonMapper . isValidJson ( this . reportDescription ) ) { issues . add ( getContext ( ) . createConfigIssue ( Groups . REPORT . name ( ) , " reportDescription " , Errors . OMNITURE_03 ) ) ; } }
createJdbcRecordWriter ( String connectionString , HikariDataSource dataSource , String schema , String tableName , List < JdbcFieldColumnParamMapping > customMappings , boolean rollbackOnError , boolean useMultiRowOp , int maxPrepStmtParameters , int defaultOpCode , UnsupportedOperationAction unsupportedAction , DuplicateKeyAction duplicateKeyAction , JdbcRecordReader recordReader , boolean caseSensitive , List < String > customDataSqlStateCodes ) throws StageException { if ( defaultOpCode == OperationType . LOAD_CODE ) { return new JdbcLoadRecordWriter ( connectionString , dataSource , schema , tableName , customMappings , duplicateKeyAction , recordReader , caseSensitive , customDataSqlStateCodes ) ; } else { return createJdbcRecordWriter ( connectionString , dataSource , schema , tableName , customMappings , null , rollbackOnError , useMultiRowOp , maxPrepStmtParameters , defaultOpCode , unsupportedAction , recordReader , caseSensitive , customDataSqlStateCodes ) ; } }
createJdbcRecordWriter ( String connectionString , HikariDataSource dataSource , String schema , String tableName , List < JdbcFieldColumnParamMapping > customMappings , List < JdbcFieldColumnMapping > generatedColumnMappings , boolean rollbackOnError , boolean useMultiRowOp , int defaultOpCode , UnsupportedOperationAction unsupportedAction , JdbcRecordReader recordReader , boolean caseSensitive , List < String > customDataSqlStateCodes ) throws StageException { JdbcRecordWriter recordWriter ; if ( useMultiRowOp ) { recordWriter = new JdbcMultiRowRecordWriter ( connectionString , dataSource , schema , tableName , rollbackOnError , customMappings , maxPrepStmtParameters , defaultOpCode , unsupportedAction , generatedColumnMappings ) ; } else { recordWriter = new JdbcGenericRecordWriter ( connectionString , dataSource , schema , tableName , rollbackOnError , customMappings , defaultOpCode , unsupportedAction , generatedColumnMappings ) ; } return recordWriter ; }
V1 to V2 .
the named groups from the compiled pattern .
offsets to the consumer .
a new EmbeddedSDC .
the fields in the record .
a list of PipelineAndValidationStatuses for a given pipeline .
new RemoteDataCollectorResult ( AckEvent futureResult ) { return new RemoteDataCollectorResult ( futureResult , null , false , null ) ; }
a gauge .
columns to parameters .
a record header from a file .
( Record record ) throws TransformerStageCheckedException { try { FileRefUtil . validateWholeFileRecord ( record ) ; } catch ( IllegalArgumentException e ) { throw new TransformerStageCheckedException ( Errors . CONVERT_01 , e . toString ( ) , e ) ; } }
the temporary parquet file .
( ) throws TransformerStageCheckedException { try { FileRef fileRef = record . get ( FileRefUtil . FILE_REF_FIELD_PATH ) . getValueAsFileRef ( ) ; final boolean includeChecksumInTheEvents = false ; InputStream is = FileRefUtil . getReadableStream ( getContext ( ) , fileRef , InputStream . class , includeChecksumInTheEvents , null , null ) ; return is ; } catch ( IOException ex ) { throw new TransformerStageCheckedException ( Errors . CONVERT_07 , ex . toString ( ) , ex ) ; } }
the file reader from the given source file .
records to parquet file .
the inputEncrypt method .
if the field is encrypted .
if the input is a byte array .
whether the input is encrypted or decrypted .
the value of the field .
a matcher for the given pattern .
( StringBuffer sb , String replacement ) { matcher . appendReplacement ( sb , replacement ) ; return this ; }
< String , String > namedGroups ( ) { Map < String , String > result = new LinkedHashMap < String , String > ( ) ; if ( parentPattern != null ) { for ( String groupName : parentPattern . groupNames ( ) ) { String groupValue = matcher . group ( groupIndex ( groupName ) ) ; result . put ( groupName , groupValue ) ; } } return result ; }
String replaceAll ( String replacement ) { String r = parentPattern . replaceProperties ( replacement ) ; return matcher . replaceAll ( r ) ; }
if avro schema exists .
the global variable from the database .
a start event .
a stop event .
the offset of the specified field .
a runtime value from a field .
( String qualifiedTableName , LinkedHashMap < String , String > partitionNameValueMap , Map < String , HiveTypeInfo > partitionTypeMap , String partitionPath ) { String sql = buildPartitionAdditionQuery ( qualifiedTableName , partitionNameValueMap , partitionTypeMap , partitionPath ) ; execute ( sql ) ; }
( String qualifiedTableName , String partitionPath ) throws StageException { String sql = buildSetTablePropertiesQuery ( qualifiedTableName , partitionPath ) ; execute ( sql ) ; }
( String dbName ) throws StageException { this . dbName = dbName ; }
the query .
the query .
a batch .
< Pipe > acceptConsumer ( ThrowingConsumer < Pipe > consumer , Pipe ... pipes ) { try { MDC . put ( LogConstants . RUNNER , String . valueOf ( runnerId ) ) ; for ( Pipe p : pipes ) { MDC . put ( LogConstants . STAGE , p . getStage ( ) . getInfo ( ) . getInstanceName ( ) ) ; acceptConsumer ( consumer , p ) ; } } catch ( StageException e ) { throw new RuntimeException ( e ) ; } }
getOffsetCommitTrigger ( ) { for ( Pipe pipe : pipes ) { Stage stage = pipe . getStage ( ) . getStage ( ) ; if ( stage instanceof Target && stage instanceof OffsetCommitTrigger ) { return ( OffsetCommitTrigger ) stage ; } } return null ; }
( ) { for ( Pipe pipe : pipes ) { stageContext = pipe . getStage ( ) . getContext ( ) ; if ( stageContext . getOnErrorRecord ( ) == OnRecordError . STOP_PIPELINE ) { return true ; } } }
< Pipe > acceptConsumer ( ThrowingConsumer < Pipe > consumer ) { return consumer ; }
the insert id for the record .
the value from a field .
the fragment in the record .
KV lookup in record .
N1QL property in record .
the data from the s3ObjectSummary .
incomplete transactions for the given gtid .
a new ExceptionSupplier for the given ClassLoader .
the stage creator .
to Kerberos .
the exceptions .
variables in the path .
whether the classloader is allowed access to Data Collector internal directories .
. main ( String [ ] args ) throws Exception { BootstrapEmrBatch . main ( args ) ; }
the path of the current directory .
( FileSystem fs , Path tempPath ) throws IOException { if ( tempPath != null ) { return fsHelper . renameAndGetPath ( fs , tempPath ) ; } return null ; }
whether the record should be rolled .
matchStrings ( String pattern , String str , Map < String , String > uriTemplateVariables ) { return getStringMatcher ( pattern ) . matchStrings ( str , uriTemplateVariables ) ; }
( ) { return getOffsets ( ) ; }
( long startTime , long maxWaitTimeMillis ) { long remaining = maxWaitTimeMillis - ( System . currentTimeMillis ( ) - startTime ) ; return ( remaining > 0 ) ? remaining : 0 ; }
( Map < String , String > offsetMap ) throws IOException { return fileContextProvider . getOffsetsLag ( offsetMap ) ; }
a new StageLibraryDelegate .
a StageLibraryDelegate .
instance of StageLibraryDelegateDefinitition .
getMetricValue ( MetricRegistry metrics , String metricId , MetricType metricType , MetricElement metricElement ) throws ObserverException { if ( metricElement . isOneOf ( MetricElement . CURRENT_BATCH_AGE , MetricElement . TIME_IN_CURRENT_STAGE ) ) { return getTimeFromRunner ( metrics , PipeRunner . METRIC_BATCH_START_TIME ) ; } if ( metricElement . isOneOf ( MetricElement . CURRENT_BATCH_AGE , MetricElement . TIME_IN_CURRENT_STAGE ) ) { return getTimeFromRunner ( metrics , PipeRunner . METRIC_BATCH_START_TIME ) ; } if ( metricElement . isOneOf ( MetricElement . CURRENT_BATCH_AGE , MetricElement . TIME_IN_CURRENT_STAGE ) ) { return getTimeFromRunner ( metrics , PipeRunner . METRIC_STAGE_START_TIME ) ; } if ( metricElement . isOneOf ( MetricElement .
the end of the header .
the body size .
a temporary file to the specified path .
a SSLSocketFactory from the given keystore .
the mime type for the given URI .
the response from the session .
all connections .
mappings to the router .
a response to the server .
a message to the server .
a new Response ( IStatus status , String mimeType , InputStream data , long totalBytes ) { return new Response ( status , mimeType , data , totalBytes ) ; }
useGzip ( ) { if ( gzipUsage == GzipUsage . DEFAULT ) return true ; else if ( gzipUsage == GzipUsage . ALWAYS ) return true ; else if ( gzipUsage == GzipUsage . ALWAYS ) return true ; else if ( gzipUsage == GzipUsage . ALWAYS ) return true ; else if ( gzipUsage == GzipUsage . ALWAYS ) return true ; else if ( gzipUsage == GzipUsage . ALWAYS ) return true ; else return false ; }
a cookie .
( ) { if ( this . queue != null ) { for ( Cookie cookie : this . queue ) { response . addCookieHeader ( cookie . getHTTPHeader ( ) ) ; } } }
the base64 value to a string .
a base64 encoded cookie string .
the table name .
the name of the principal .
a spring session repository filter .
the principal name from the session .
the session from the given id .
the JNDI name of the current MailSession .
the canonical name of the view method .
( Synchronization synchronization ) { if ( synchronization . getClass ( ) . getName ( ) . startsWith ( " org . jboss . jca " ) || synchronization . getClass ( ) . getName ( ) . startsWith ( " org . jboss . jca " ) || synchronization . getClass ( ) . getName ( ) . startsWith ( " org . jboss . jca " ) || synchronization . getClass ( ) . getName ( ) . startsWith ( " org . jboss . jca " ) ) { if ( TransactionLogger . ROOT_LOGGER . isTraceEnabled ( ) ) { TransactionLogger . ROOT_LOGGER . trace ( " JCAOrderedLastSynchronizationList . jcaSyncs . add - Class : " + synchronization . getClass ( ) + " HashCode : " + synchronization . hashCode ( ) + " toString : " + synchronization ) ; } jcaSyncs . add ( synchronization ) ; } }
beforeCompletion ( ) { if ( TransactionLogger . ROOT_LOGGER . isTraceEnabled ( ) ) { TransactionLogger . ROOT_LOGGER . trace ( " JCAOrderedLastSynchronizationList . preJcaSyncs . before _ completion - Class : " + preJcaSync . getClass ( ) + " HashCode : " + preJcaSync . hashCode ( ) + " toString : " + preJcaSync ) ; } return preJcaSync ; }
the current transaction .
a KernelDeploymentXmlDescriptor .
( ) { }
the service names for the given subsystem .
( ) { readLockCount . decrementAndGet ( ) ; }
readLockCount ( ) { readLockCount . incrementAndGet ( ) ; return readLockCount ; }
a service to a bean deployment archive .
the restoration calculation .
a search dependency to the deployment unit .
( ) { for ( BeanDeploymentArchiveImpl bda : beanDeploymentArchives ) { if ( bda . getBeanArchiveType ( ) . equals ( BeanDeploymentArchiveImpl . BeanArchiveType . EXTERNAL ) || bda . getBeanArchiveType ( ) . equals ( BeanDeploymentArchiveImpl . BeanArchiveType . SYNTHETIC ) ) { bda . addBeanDeploymentArchive ( bda ) ; } } }
a JBoss agnostic meta data for POJO webservice deployment .
the config name and file .
a jseSecurityMetaData from the list of security constraints .
the ServletMappings from the JBossWebMetaData .
< String , String > getServletClassMappings ( final JBossWebMetaData jbossWebMD , final List < POJOEndpoint > pojoEndpoints ) { final Map < String , String > mappings = new HashMap < String , String > ( ) ; final JBossServletsMetaData servlets = WebMetaDataHelper . getServlets ( jbossWebMD ) ; for ( final POJOEndpoint pojoEndpoint : pojoEndpoints ) { final String pojoName = pojoEndpoint . getName ( ) ; final String pojoClassName = pojoEndpoint . getClassName ( ) ; mappings . put ( pojoName , pojoClassName ) ; if ( ! pojoEndpoint . isDeclared ( ) ) { final String endpointName = pojoEndpoint . getName ( ) ; final String endpointClassName = pojoEndpoint . getClassName ( ) ; WebMetaDataHelper . newServlet ( endpointName , endpointClassName , servlets ) ; } } return mappings ; }
the EJBViewDescription .
the available connectors of the activeMQ server .
( final XMLExtendedStreamReader reader , final ModelNode operation ) throws XMLStreamException { final int count = reader . getAttributeCount ( ) ; for ( int i = 0 ; i < count ; i ++ ) { requireNoNamespaceAttribute ( reader , i ) ; final String value = reader . getAttributeValue ( i ) ; final Attribute attribute = Attribute . forName ( reader . getAttributeLocalName ( i ) ) ; switch ( attribute ) { case NODE_IDENTIFIER : TransactionSubsystemRootResourceDefinition . NODE_IDENTIFIER . parseAndSetParameter ( value , operation , reader ) ; break ; case PATH : case RELATIVE_TO : throw TransactionLogger . ROOT_LOGGER . unsupportedAttribute ( attribute . getLocalName ( ) , reader . getLocation ( ) ) ; default : throw unexpectedAttribute ( reader , i ) ; } } }
( XMLExtendedStreamReader reader , ModelNode coreEnvironmentAdd ) throws XMLStreamException { if ( reader . getAttributeCount ( ) > 0 ) { throw unexpectedAttribute ( reader , 0 ) ; } boolean encountered = false ; while ( reader . hasNext ( ) && reader . nextTag ( ) != START_ELEMENT ) { throw unexpectedElement ( reader ) ; } while ( reader . hasNext ( ) && reader . nextTag ( ) != END_ELEMENT ) { throw unexpectedElement ( reader ) ; } while ( reader . hasNext ( ) && reader . nextTag ( ) != START_ELEMENT ) { throw unexpectedElement ( reader ) ; } }
the path address of the operation .
setPathAddress ( ModelNode operation ) { operation . get ( ModelDescriptionConstants . OP_ADDR ) . set ( address . toModelNode ( ) ) ; return operation ; }
the value of the attribute .
the include defaults for the given operation .
a composite operation .
a new operation to the given address .
a new add operation .
a read attribute operation .
a write attribute operation .
undefineAttribute ( PathAddress address , Attribute attribute ) { return createAttributeOperation ( ModelDescriptionConstants . UNDEFINE_ATTRIBUTE_OPERATION , address , attribute ) ; }
the value of the given context .
a new url context factory .
the url context factory .
a list of ValidationProviders .
the JBossWebMetaData .
the servlets for the given endpoint .
the context root of the deployment .
the transport class name .
setRunAsIdentity ( final RunAs principal , final SecurityContext sc ) { if ( WildFlySecurityManager . isChecking ( ) ) { return WildFlySecurityManager . doUnchecked ( new PrivilegedAction < RunAs > ( ) { @ Override public RunAs run ( ) { if ( sc == null ) { throw UndertowLogger . ROOT_LOGGER . noSecurityContext ( ) ; } RunAs old = sc . getOutgoingRunAs ( ) ; sc . setOutgoingRunAs ( principal ) ; return old ; } } ) ; } else { if ( sc == null ) { throw UndertowLogger . ROOT_LOGGER . noSecurityContext ( ) ; } RunAs old = sc . getOutgoingRunAs ( ) ; sc . setOutgoingRunAs ( principal ) ; return old ; } }
popRunAsIdentity ( final SecurityContext sc ) { if ( WildFlySecurityManager . isChecking ( ) ) { return AccessController . doPrivileged ( new PrivilegedAction < RunAs > ( ) { @ Override public RunAs run ( ) { if ( sc == null ) { throw UndertowLogger . ROOT_LOGGER . noSecurityContext ( ) ; } RunAs principal = sc . getOutgoingRunAs ( ) ; sc . setOutgoingRunAs ( null ) ; return principal ; } } ) ; } else { if ( sc == null ) { throw UndertowLogger . ROOT_LOGGER . noSecurityContext ( ) ; } RunAs principal = sc . getOutgoingRunAs ( ) ; sc . setOutgoingRunAs ( null ) ; return principal ; } }
the management of a JBossServletMetaData .
SuppressWarnings ( " unchecked " ) public void inject ( Object object , String propertyName , Object propertyValue ) throws NoSuchMethodException , IllegalAccessException , InvocationTargetException { inject ( object , propertyName , propertyValue , null , false ) ; }
whether the class type matches the property type .
findMethod ( Class < ? > clz , String methodName , String propertyType ) { if ( clz != null && clz . getSuperclass ( ) != null && clz . getSuperclass ( ) . getSuperclass ( ) != null && clz . getSuperclass ( ) . getSuperclass ( ) != null && clz . getSuperclass ( ) . getSuperclass ( ) != null && clz . getSuperclass ( ) . getSuperclass ( ) != null && clz . getSuperclass ( ) . getSuperclass ( ) != null && clz . getSuperclass ( ) . getSuperclass ( ) != null && clz . getSuperclass ( ) . getSuperclass ( ) != null && clz . getSuperclass ( ) . getSuperclass ( ) != null && clz . getSuperclass ( ) . getSuperclass ( ) != null && clz . getSuperclass ( ) != null && clz . getSuperclass ( ) . getSuperclass ( ) != null && clz . getSuperclass ( ) != null && clz . getSuperclass ( ) != null && clz . getSuperclass ( ) != null && clz . getSuperclass ( ) != null && clz . getSuperclass ( ) != null
the field of the given class .
a keystore .
the useful info from the HttpServletRequest .
a standalone report .
the report from the serverEnvironment .
a resource adapter deployment .
( ResourceAdapterDeployment deployment ) { if ( deployment == null ) throw new IllegalArgumentException ( ConnectorLogger . ROOT_LOGGER . nullVar ( " Deployment " ) ) ; deployments . remove ( deployment ) ; }
transformers for the given subsystem .
the params to the output stream .
the exception .
the owner of the transaction .
lock .
a new log .
a CDI flag to the JBossWebMetaData .
( String componentViewName ) { ComponentView cv = componentView ; if ( cv == null ) { synchronized ( this ) { cv = componentView ; if ( cv == null ) { cv = getMSCService ( componentViewName , ComponentView . class ) ; if ( cv == null ) { throw WSLogger . ROOT_LOGGER . cannotFindComponentView ( componentViewName ) ; } if ( cv == null ) { throw WSLogger . ROOT_LOGGER . cannotFindComponentView ( componentViewName ) ; } if ( reference == null ) { try { reference = cv . createInstance ( ) ; } catch ( Exception e ) { throw new RuntimeException ( e ) ; } } componentView = cv ; } } } return cv ; }
the endpoint using the security domain context .
the component view method .
true if the sei method matches the view method .
( final ManagementAdaptor managementAdaptor ) { synchronized ( existingResourceDescriptionResolver ) { final EntityManagerFactoryLookup entityManagerFactoryLookup = new EntityManagerFactoryLookup ( ) ; final Statistics statistics = managementAdaptor . getStatistics ( ) ; if ( false == existingResourceDescriptionResolver . contains ( managementAdaptor . getVersion ( ) ) ) { ResourceDescriptionResolver resourceDescriptionResolver = new StandardResourceDescriptionResolver ( statistics . getResourceBundleKeyPrefix ( ) , statistics . getResourceBundleName ( ) , statistics . getClass ( ) . getClassLoader ( ) ) { private ResourceDescriptionResolver fallback = JPAExtension . getResourceDescriptionResolver ( ) ; @ Override public String getResourceAttributeDescription ( String attributeName , Locale locale , ResourceBundle bundle ) { if ( bundle . containsKey ( getBundleKey ( attributeName ) ) ) { return super . getResourceAttributeDescription ( attributeName , locale , bundle ) ; } else { return fallback . getResourceAttributeDescription ( attributeName , locale , fallback . getResourceBundle ( locale ) ) ; } } } ; pathAddress =
getEjbSecurityMetaData ( ) { return ejbSecurityMetaData ; }
the next security domain .
that all security domains are the same .
the IDL name .
the absolute name of the parent .
a new JndiName from the given name .
an IronJacamar deployment .
the request .
the transaction status of the current transaction .
the transactionSynchronizationRegistry .
the connection factory .
the last component of the given name .
static boolean isEmpty ( final Name name ) { return name . isEmpty ( ) || ( name . size ( ) == 1 && " " . equals ( name . get ( 0 ) ) ) ; }
nameNotFoundException ( final String name ) { return NamingLogger . ROOT_LOGGER . nameNotFoundInContext ( name , contextName ) ; }
a NamingException .
namingException ( final String message , final Throwable cause ) { final NamingException exception = namingException ( message , cause ) ; exception . setRemainingName ( remainingName ) ; return exception ; }
a CannotProceedException .
< T > namingEnumeration ( final Collection < T > collection ) { final Iterator < T > iterator = collection . iterator ( ) ; return new NamingEnumeration < T > ( ) { public T next ( ) { return nextElement ( ) ; } public boolean hasMore ( ) { return hasMoreElements ( ) ; } public void close ( ) { } public boolean hasMoreElements ( ) { return iterator . hasNext ( ) ; } public T nextElement ( ) { return iterator . next ( ) ; } } ; }
( final Context ctx ) throws NamingException { final Name n = ctx . getNameParser ( " " ) . parse ( name ) ; rebind ( ctx , n , value ) ; }
( final OperationContext context , final ModelNode operation , final boolean forWrite ) throws OperationFailedException { final ServiceName artemisServiceName = MessagingServices . getActiveMQServiceName ( PathAddress . pathAddress ( operation . get ( ModelDescriptionConstants . OP_ADDR ) ) ) ; ServiceController < ? > artemisService = context . getServiceRegistry ( forWrite ) . getService ( artemisServiceName ) ; ActiveMQServer server = ActiveMQServer . class . cast ( artemisService . getValue ( ) ) ; PathAddress address = PathAddress . pathAddress ( operation . require ( OP_ADDR ) ) ; T control = getActiveMQComponentControl ( server ) ; if ( control == null ) { throw ControllerLogger . ROOT_LOGGER . managementResourceNotFound ( address ) ; } return control ; }
the connection definition .
a new component instance .
the resource root .
the runtime name .
a listener builder .
the primitive analysis for the given class .
the given value .
a list of url patterns .
a JBossServletsMetaData from a JBossWebMetaData .
a list of ServletMappings .
the security constraints .
the login config from the JBossWebMetaData .
the context params of the JBossWebMetaData .
getWebResourceCollections ( final SecurityConstraintMetaData securityConstraintMD ) { WebResourceCollectionsMetaData webResourceCollectionsMD = securityConstraintMD . getResourceCollections ( ) ; if ( webResourceCollectionsMD == null ) { webResourceCollectionsMD = new WebResourceCollectionsMetaData ( ) ; securityConstraintMD . setResourceCollections ( webResourceCollectionsMD ) ; } return webResourceCollectionsMD ; }
the init params of the servlet .
a new SecurityConstraintMetaData .
newWebResourceCollectionMetaData ( ) { return new WebResourceCollectionMetaData ( ) ; }
a new JBossServletMetaData .
a new ServletMappingMetaData .
a new AuthConstraintMetaData .
a new UserDataConstraintMetaData from the given transportGuarantee .
a new ParamValueMetaData .
a new ParamValueMetaData .
( SessionBeanComponentDescription componentDescription ) { if ( componentDescription . isStateful ( ) || componentDescription . isStateless ( ) ) { componentDescription . getConfigurators ( ) . addFirst ( new ComponentConfigurator ( ) { @ Override public void configure ( DeploymentPhaseContext context , ComponentDescription description , ComponentConfiguration configuration ) throws DeploymentUnitProcessingException { configuration . addComponentInterceptor ( SFSBInvocationInterceptor . FACTORY , InterceptorOrder . Component . JPA_SFSB_INTERCEPTOR , false ) ; configuration . getInterceptorContextKeys ( ) . add ( SFSBInvocationInterceptor . CONTEXT_KEY ) ; } } ) ; } }
the injection target to a resource injection configuration .
the bootstrap service .
the JNDI name .
the value of the given attribute .
the type of the url pattern .
targetsPooledConnectionFactory ( ) { return true ; }
an external PooledConnectionFactory .
( Map < String , String > properties ) { return properties . getOrDefault ( SERVER , DEFAULT ) ; }
the default persistence unit name .
a suspend controller .
the SuspendController .
the current transaction .
the request .
the active invocations .
a new transaction .
a service based naming store .
resource into naming store .
( String capabilityBaseName ) { if ( capabilityServiceSupport == null ) { throw new IllegalStateException ( ) ; } if ( dynamicParts == null || dynamicParts . length == 0 ) { return capabilityServiceSupport . getCapabilityServiceName ( capabilityBaseName ) ; } return capabilityServiceSupport . getCapabilityServiceName ( capabilityBaseName ) ; }
a list of ResourceRoots from the deployment root .
< ClassLoader > allDeploymentModuleClassLoaders ( DeploymentUnit deploymentUnit ) { Set < ClassLoader > deploymentClassLoaders = new HashSet < ClassLoader > ( ) ; deploymentClassLoaders . add ( deploymentUnit . getClassLoader ( ) ) ; deploymentClassLoaders . add ( deploymentUnit . getClassLoader ( ) ) ; deploymentClassLoaders . add ( deploymentUnit . getClassLoader ( ) ) ; deploymentClassLoaders . add ( deploymentUnit . getClassLoader ( ) ) ; deploymentClassLoaders . add ( deploymentUnit . getClassLoader ( ) ) ; deploymentClassLoaders . add ( deploymentUnit . getClassLoader ( ) ) ; deploymentClassLoaders . add ( deploymentUnit . getClassLoader ( ) ) ; deploymentClassLoaders . add ( deploymentUnit . getClassLoader ( ) ) ; deploymentClassLoaders . add ( deploymentUnit . getClassLoader ( ) ) ; deploymentClassLoaders . add ( deploymentUnit . getClassLoader ( ) ) ; deploymentClassLoaders . add ( deploymentUnit . getClassLoader ( ) ) ;
whether the class file transformer is enabled or not .
two phase bootstrap .
default data source use .
.
the ORB .
the ORB .
a stub class for the portable remote object .
( final NamingStore namingStore ) { if ( WildFlySecurityManager . isChecking ( ) ) { System . getSecurityManager ( ) . checkPermission ( SET_ACTIVE_NAMINGSTORE ) ; } ACTIVE_NAMING_STORE = namingStore ; }
default values .
if the given type is a ParameterizedType .
( Annotation [ ] annotationArr ) { return lookupDefaultValueAnn ( annotationArr ) ; }
the base type .
a list of all registered entity managers .
the status string .
cache dependencies .
database dialects .
the database dialect .
the dialect for the given name .
if the database has been loaded .
a date from a timer .
the name of the node .
the deployment unit .
params from the input stream .
( OutputStream out , Object retVal ) { retvalWriter . write ( out , RemoteObjectSubstitutionManager . writeReplaceRemote ( retVal ) ) ; }
exceptions to the output stream .
< U > lookup ( Lookup < U > lookup , int start , int depth ) { ClassReflectionIndex cri = index . getClassIndex ( currentClass ) ; while ( cri != null ) { cri = cri . getSuperclass ( ) ; cri = cri . getClassIndex ( currentClass ) ; cri = cri . getSuperclass ( ) ; } return lookup ; }
a new instance of SFSBInjectedXPCs .
( ) { if ( data . creationTimeInjectedXPCs != null ) { data . creationTimeInjectedXPCs . endSfsbCreation ( ) ; } }
the current SFSBCallStack invocation .
calls to the current SFSB call stack .
the current SFSB call stack .
the current SFSB call .
a module dependency to the deployment unit .
( final DeploymentUnit deploymentUnit , final Set < String > managedBeanClasses ) { for ( final VirtualFile facesConfig : getConfigurationFiles ( deploymentUnit ) ) { if ( facesConfig . isFile ( ) && facesConfig . isFile ( ) && facesConfig . isFile ( ) && facesConfig . isFile ( ) && facesConfig . isFile ( ) && facesConfig . isFile ( ) && facesConfig . isFile ( ) && facesConfig . isFile ( ) && facesConfig . isFile ( ) && facesConfig . isFile ( ) && facesConfig . isFile ( ) && facesConfig . isFile ( ) && facesConfig . isFile ( ) && facesConfig . isFile ( ) && facesConfig . isFile ( ) && facesConfig . isFile ( ) && facesConfig . isFile ( ) && facesConfig . isFile ( ) && facesConfig . isFile ( ) && facesConfig . isFile ( ) && facesConfig . isFile ( ) && facesConfig . isFile ( ) && facesConfig . isFile ( )
phase listeners .
the typeIDL name of the class .
( Any any , Object primitive ) { if ( type == Boolean . class ) any . insert_boolean ( ( ( Boolean ) primitive ) . booleanValue ( ) ) ; else if ( type == Character . class ) any . insert_char ( ( ( Character ) primitive ) . charValue ( ) ) ; else if ( type == Byte . class ) any . insert_octet ( ( ( Byte ) primitive ) . byteValue ( ) ) ; else if ( type == Short . class ) any . insert_short ( ( ( Short ) primitive ) . shortValue ( ) ) ; else if ( type == Integer . class ) any . insert_int ( ( ( Integer ) primitive ) . intValue ( ) ) ; else if ( type == Long . class ) any . insert_long ( ( ( Long ) primitive ) . longValue ( ) ) ; else if ( type == Float . class ) any . insert_float ( ( ( Float ) primitive ) . floatValue
a string to a IDL name .
reservedIDL keywords .
the signature of the class .
the signature of the method .
the name of the primitive type .
forName ( final String name ) { Assert . checkNotNullParam ( " name " , name ) ; return name == null ? allPermission : mapping . getItemByString ( name ) ; }
a transaction scoped EntityManager .
put ( K key , V value ) { if ( key == null ) throw new NullPointerException ( ) ; int hash = hashOf ( key ) ; return segmentFor ( hash ) . put ( key , hash , value , false ) ; }
a list of security roles to a ModelNode .
the most recent entity version for the given timer .
the timers from the given timedObjectId .
a directory for persist timers .
a listener to the target scope .
all listeners from the given NamingListener .
an event for the given name .
the AutoCloseable .
a private credential to the subject .
the object instance of the given name .
a TxManagementInterceptor to the view .
a string to a string .
a TransportConfiguration for the given server .
the ear prefix to the configured name .
the root deployment unit .
the name of the component .
a view configuration .
a new injection source .
the list of viewInterceptors .
a new interceptor to the proxy .
a new interceptor to the view .
a list of clientInterceptors .
a client interceptor .
a client interceptor .
< T > void putPrivateData ( final Class < T > type , final T data ) { privateData . put ( type , data ) ; }
the element from the XMLExtendedStreamReader .
( ) { return getJaxwsEjbs ( ) ; }
the JaxwsPojos of the JAXWS deployment .
the endpoint name .
the endpoint class .
the ServletMetaData for the given name .
the required attachment .
( final DeploymentUnit unit , final AttachmentKey < A > key ) { return unit . getAttachment ( key ) ; }
( final DeploymentUnit unit ) { final WarMetaData warMetaData = getOptionalAttachment ( unit , WarMetaData . ATTACHMENT_KEY ) ; if ( warMetaData != null ) { result = warMetaData . getJBossWebMetaData ( ) ; } }
( final DeploymentUnit unit , final String name ) { if ( name != null ) { final JBossWebservicesMetaData jbossWebserviceMetaData = unit . getAttachment ( JBOSS_WEBSERVICES_METADATA_KEY ) ; if ( jbossWebserviceMetaData != null ) { JBossPortComponentMetaData [ ] portComponent = jbossWebserviceMetaData . getPortComponents ( ) ; if ( portComponent != null ) { for ( JBossPortComponentMetaData component : portComponent ) { if ( name . equals ( component . getEjbName ( ) ) ) { return component ; } } } } } return null ; }
getWebserviceMetadataEJBEndpoint ( final JAXWSDeployment jaxwsDeployment ) { return getWebserviceMetadataEJBEndpoint ( jaxwsDeployment ) ; }
the context root for the given deployment .
< ? > classForName ( String name ) { try { if ( classes . containsKey ( name ) ) { return classes . get ( name ) ; } final Class < ? > clazz = module . getClassLoader ( ) . loadClass ( name ) ; classes . put ( name , clazz ) ; return clazz ; } catch ( ClassNotFoundException | LinkageError e ) { throw new ResourceLoadingException ( e ) ; } }
the resource for the given name .
the resources of the given name .
< Resource > list ( String path ) { try { final List < Resource > ret = new ArrayList < > ( ) ; Resource res = deploymentResourceManager . getResource ( path ) ; if ( res != null ) { for ( Resource child : res . list ( ) ) { ret . add ( new ServletResource ( this , child ) ) ; } } return ret ; } catch ( IOException e ) { throw new RuntimeException ( e ) ; } }
the non - transactional entity manager .
the EntityManager for the given puScopedName .
a clean up listener to the transactionSynchronizationRegistry .
a war to a deployment unit .
the server config .
static boolean isAllFieldsPublic ( Class c ) { try { final Field [ ] list = c . getFields ( ) ; for ( int i = 0 ; i < list . length ; i ++ ) if ( ! Modifier . isPublic ( list [ i ] . getModifiers ( ) ) ) return false ; } catch ( Exception e ) { return false ; } return true ; }
a new endpoint .
new unified WS deployment model for % s .
if the deployment unit is a Jaxrs deployment .
( ) { return nextExpiration ; }
timer state .
the deployment data .
a module dependency to the deployment unit .
a remote transaction service dependency to the EJBComponentDescription .
all container interceptors .
isMethodLevel ( MethodIntf methodIntf , Method defaultMethodIntf ) { if ( methodIntf == null ) { throw new IllegalArgumentException ( " methodIntf is null " ) ; } if ( defaultMethodIntf == null ) { throw new IllegalArgumentException ( " defaultMethodIntf is null " ) ; } }
only one of the elements in the XMLExtendedStreamReader .
the type of the given class .
( ParameterizedType type ) { Type [ ] tp = type . getActualTypeArguments ( ) ; if ( index + 1 > tp . length ) return null ; return tp [ index ] ; }
the ElytronKeyStoreResourceDefinition .
( ) { }
( ) { }
( String name ) throws NamingException { Vector comps = insStringToStringifiedComps ( name ) ; return new CNCompoundName ( comps . elements ( ) ) ; }
a string from the given string .
a new NameComponent from a string .
( ) { try { poa . deactivateIRObject ( getReference ( ) ) ; } catch ( UserException ex ) { IIOPLogger . ROOT_LOGGER . warnCouldNotDeactivateIRObject ( ex ) ; } }
CORBA servant to reference .
the given username and password .
the type of the given class .
the bind info for the given name .
the given name .
a bean .
< PropertyConfig > configure ( BeanMetaDataConfig beanConfig , Module module , Object bean , boolean nullify ) throws StartException { Set < PropertyConfig > properties = beanConfig . getProperties ( ) ; if ( properties != null ) { List < PropertyConfig > used = new ArrayList < PropertyConfig > ( ) ; for ( PropertyConfig pc : properties ) { try { configure ( beanInfo , module , bean , pc , nullify ) ; used . add ( pc ) ; } catch ( Throwable t ) { if ( nullify == false ) { for ( PropertyConfig upc : used ) { try { configure ( beanInfo , module , bean , upc , true ) ; } catch ( Throwable ignored ) { } } throw new StartException ( t ) ; } } } }
the lifecycle joinpoint .
the current selector .
the name of the bean .
a ServiceName for the given class .
the EEModuleClassDescription of the given name .
the session beans for the given deployment unit .
the persistence unit xml .
the descriptor .
a JBossWebMetaData from a DeploymentUnit .
web . xml descriptor .
getAuthMethod ( final Deployment dep ) { for ( final Endpoint ejbEndpoint : dep . getService ( ) . getEndpoints ( ) ) { final String beanAuthMethod = ejb3SecurityAccessor . getAuthMethod ( ejbEndpoint ) ; if ( beanAuthMethod != null ) { return beanAuthMethod ; } } return null ; }
a service to a deployment unit .
a stateless session bean .
a stub class for the given class .
( long n ) { String s = anonOidPrefix + Long . toString ( n ) ; return s . getBytes ( StandardCharsets . UTF_8 ) ; }
( ) { List < PersistenceProvider > providersCopy = new ArrayList < > ( providers . size ( ) ) ; if ( persistenceProviderPerClassLoader != null ) { providersCopy . addAll ( persistenceProviderPerClassLoader . values ( ) ) ; } return providersCopy ; }
( ) { synchronized ( persistenceProviderPerClassLoader ) { for ( ClassLoader deploymentClassLoader : deploymentClassLoaders ) { persistenceProviderPerClassLoader . remove ( deploymentClassLoader ) ; } } }
a persistence provider to the deployment class loader .
the parent module ClassLoader .
a module to a deployment unit .
PuService to the deployment unit .
the annotation indexes for the deployment unit .
getPersistenceProviderAdaptor ( final PersistenceUnitMetadata pu , final PersistenceProviderDeploymentHolder persistenceProviderDeploymentHolder , final Platform platform ) throws DeploymentUnitProcessingException { if ( pu . getPersistenceProviderClassName ( ) == null ) { throw JpaLogger . ROOT_LOGGER . failedToGetPersistenceProviderAdaptor ( pu . getPersistenceProviderClassName ( ) ) ; } return getPersistenceProviderAdaptor ( pu , persistenceProviderDeploymentHolder , platform ) ; }
( DeploymentUnit deploymentUnit , String adaptorModule , PersistenceProviderAdaptor adaptor , PersistenceProvider provider ) { if ( deploymentUnit . getParent ( ) != null ) { deploymentUnit = deploymentUnit . getParent ( ) ; } synchronized ( deploymentUnit ) { Map < String , PersistenceProviderAdaptor > map = deploymentUnit . getAttachment ( providerAdaptorMapKey ) ; String key ; if ( adaptorModule != null ) { key = adaptorModule ; } else if ( provider != null ) { key = provider . getClass ( ) . getName ( ) ; } else { key = adaptor . getClass ( ) . getName ( ) ; } PersistenceProviderAdaptor current = map . get ( key ) ; if ( current == null ) { map . put ( key , adaptor ) ; current = adaptor ; } return current ; } }
lookupProvider ( PersistenceProviderDeploymentHolder persistenceProviderDeploymentHolder , DeploymentUnit deploymentUnit ) throws DeploymentUnitProcessingException { Map < String , PersistenceProvider > providerMap = persistenceProviderDeploymentHolder != null ? persistenceProviderDeploymentHolder . getProviders ( ) : null ; if ( providerMap != null ) { if ( providerMap . containsKey ( pu . getPersistenceProviderClassName ( ) ) ) { ROOT_LOGGER . tracef ( " deployment % s is using % s " , deploymentUnit . getName ( ) , pu . getPersistenceProviderClassName ( ) ) ; return providerMap . get ( pu . getPersistenceProviderClassName ( ) ) ; } } return null ; }
public Map < Class < ? extends Annotation > , Set < Class < ? > > > getAnnotatedClasses ( final Set uris ) { return annotations ; }
JBoss agnostic meta data for EJB webservice deployment .
( final List < EJBMetaData > wsEjbsMD , final EJBEndpoint ejbEndpoint , final JBossWebservicesMetaData jbossWebservicesMD ) { final SLSBMetaData . Builder wsEjbMDBuilder = new SLSBMetaData . Builder ( ) ; wsEjbMDBuilder . setEjbName ( ejbEndpoint . getName ( ) ) ; wsEjbMDBuilder . setEjbClass ( ejbEndpoint . getClassName ( ) ) ; final JBossPortComponentMetaData portComponentMD = getPortComponent ( ejbEndpoint . getName ( ) , jbossWebservicesMD ) ; if ( portComponentMD != null ) { wsEjbMDBuilder . setPortComponentName ( portComponentMD . getPortComponentName ( ) ) ; wsEjbMDBuilder . setPortComponentURI ( portComponentMD . getPortComponentURI ( ) ) ; } }
void refreshParticipant ( OperationContext context ) { context . addStep ( refreshHandler , OperationContext . Stage . MODEL , true ) ; }
the analysis of the given class .
a ContainerAnalysis from a Class .
a container analysis .
the idl module name .
the hexadecimal representation of an integer .
a long to a hex string .
if the accessor method is of the given type .
if a method is mutator .
whether an exception is thrown or not .
the attribute name .
a name to the attribute .
( ) throws RMIIIOPViolationException { for ( int i = 0 ; i < methods . length ; ++ i ) if ( methods [ i ] . getMethod ( ) . equals ( methods [ i ] ) ) if ( methods [ i ] . getMethod ( ) . equals ( methods [ i ] ) ) if ( methods [ i ] . getMethod ( ) . equals ( methods [ i ] ) ) if ( methods [ i ] . getMethod ( ) . equals ( methods [ i ] ) ) if ( methods [ i ] . getMethod ( ) . equals ( methods [ i ] ) ) if ( methods [ i ] . getMethod ( ) . equals ( methods [ i ] ) ) break ; } }
( ) throws RMIIIOPViolationException { for ( int i = 0 ; i < entries . size ( ) ; ++ i ) { if ( ! Character . isUpperCase ( entries . get ( i ) . getIDLName ( ) . toUpperCase ( Locale . ENGLISH ) ) ) { clash [ i ] = true ; } } }
( String name ) { StringBuffer b = new StringBuffer ( ) ; for ( int i = 0 ; i < name . length ( ) ; ++ i ) { char c = name . charAt ( i ) ; if ( c < 256 ) b . append ( c ) ; else b . append ( " \\ U " ) . append ( toHexString ( ( int ) c ) ) ; } return b . toString ( ) ; }
( XMLExtendedStreamReader reader ) throws XMLStreamException { if ( reader . getAttributeCount ( ) == 0 ) { throw ParseUtils . unexpectedAttributeCount ( reader ) ; } if ( reader . getAttributeCount ( ) == 1 ) { throw ParseUtils . unexpectedAttributeCount ( reader ) ; } if ( reader . getAttributeCount ( ) == 2 ) { throw ParseUtils . unexpectedAttributeCount ( reader ) ; } if ( reader . getAttributeCount ( ) == 3 ) { throw ParseUtils . unexpectedAttributeCount ( reader ) ; } if ( reader . getAttributeCount ( ) == 1 ) { throw ParseUtils . unexpectedAttributeCount ( reader ) ; } if ( reader . getAttributeCount ( ) == 2 ) { throw ParseUtils . unexpectedAttributeCount ( reader ) ; } if ( reader . getAttributeCount ( ) == 3 ) { throw ParseUtils . unexpectedAttributeCount ( reader ) ; } if ( reader . getAttributeCount ( ) == 1 ) { throw ParseUtils .
( XMLExtendedStreamReader reader , ModelNode subsystem ) throws XMLStreamException { parseDefaultContextPropagationElement ( reader , subsystem ) ; }
the attributes of the XMLExtendedStreamReader .
the PersistenceProvider from the given module .
a new AddStepHandler .
a dependency to the deployment unit .
a simple attribute .
of ( final InterceptorContext invocation ) { MethodIntf methodIntf = invocation . getPrivateData ( MethodIntf . class ) ; if ( methodIntf == null ) { final ComponentView componentView = invocation . getPrivateData ( ComponentView . class ) ; if ( componentView != null ) { methodIntf = componentView . getPrivateData ( MethodIntf . class ) ; } else { methodIntf = MethodIntf . BEAN ; } } return methodIntf ; }
createSession ( ) { ControlPoint controlPoint = getControlPoint ( ) ; if ( controlPoint == null ) { return createSession ( ) ; } else { try { RunResult result = controlPoint . beginRequest ( ) ; if ( result == RunResult . REJECTED ) { throw EjbLogger . ROOT_LOGGER . containerSuspended ( ) ; } try { return createSession ( ) ; } finally { controlPoint . requestComplete ( ) ; } } catch ( EJBComponentUnavailableException | ComponentIsStoppedException e ) { throw e ; } catch ( Exception e ) { throw new EJBException ( e ) ; } } }
the destination name .
endpoint handlers .
< String > getJobXmlNames ( ) { if ( jobNames . containsKey ( jobName ) ) { return Collections . unmodifiableSet ( jobNames . get ( jobName ) ) ; } return Collections . emptySet ( ) ; }
a job xml file to the classpath .
the URI of the request .
a ResolveResult from the given URL .
a java . lang . Object for the given name .
( String name , java . lang . Object obj ) throws NamingException { bind ( new CompositeName ( name ) , obj ) ; }
the given path .
listBindings ( Name name ) throws NamingException { if ( _nc == null ) throw IIOPLogger . ROOT_LOGGER . notANamingContext ( name . toString ( ) ) ; if ( name . size ( ) > 0 ) { try { java . lang . Object obj = lookup ( name ) ; if ( obj instanceof CNCtx ) { return new org . wildfly . iiop . openjdk . naming . jndi . CNBindingEnumeration ( ( CNCtx ) obj , true , _env ) ; } else { throw new NotContextException ( name . toString ( ) ) ; } } catch ( NamingException ne ) { throw ne ; } catch ( BAD_PARAM e ) { NamingException ne = new NotContextException ( name . toString ( ) ) ; ne . setRootCause ( e ) ; throw ne ; } } else { throw new NotContextException ( name . toString ( ) ) ; } }
a NamingContext .
the subcontext of the given name .
new context to the given path .
( String name ) { return createSubcontext ( new CompositeName ( name ) ) ; }
the link for the given name .
a property to the environment .
the key from the environment .
a transformation to the current version .
( XMLStreamReader reader ) throws XMLStreamException , ParserException , ValidateException { String userName = null ; String password = null ; String securityDomain = null ; boolean elytronEnabled = false ; String authenticationContext = null ; while ( reader . hasNext ( ) ) { if ( reader . nextTag ( ) == Credential . Tag . END_ELEMENT ) { throw new ParserException ( bundle . unexpectedEndTag ( reader . getLocalName ( ) ) ) ; } } return new CredentialImpl ( userName , password , securityDomain , elytronEnabled , authenticationContext ) ; }
the security domain .
up the JNDI for the given context .
a new ModularReference .
a new ModularReference .
a new ModularReference .
( TypeCode typeCode , RepositoryImpl repository ) { TCKind tcKind = typeCode . kind ( ) ; if ( PrimitiveDefImpl . isPrimitiveTCKind ( tcKind ) ) return new PrimitiveDefImpl ( typeCode , repository ) ; if ( tcKind == TCKind . tk_sequence ) return repository . getSequenceImpl ( typeCode ) ; throw IIOPLogger . ROOT_LOGGER . badKindForTypeCode ( tcKind . value ( ) ) ; }
for security domain service to be available .
masked password .
the security vault .
the vault session .
a display for a vault attribute .
the vault configuration .
a vault configuration .
whether the value is null or not .
( final String raName , final Activation raxml ) { if ( raName == null ) throw ConnectorLogger . ROOT_LOGGER . undefinedVar ( " RaName " ) ; ServiceName serviceName = null ; ModifiableResourceAdapter ra = ( ModifiableResourceAdapter ) raxml ; if ( ra != null && ra . getId ( ) != null ) { serviceName = getDeploymentServiceName ( raName , ra . getId ( ) ) ; } else { serviceName = getDeploymentServiceName ( raName , ( String ) null ) ; } ROOT_LOGGER . tracef ( " ConnectorServices : getDeploymentServiceName ( % s , % s ) - > % s " , raName , raxml , serviceName ) ; return serviceName ; }
a value into a given type .
boolean implies ( final JndiPermission permission ) { return permission != null && ( ( actionBits & permission . actionBits ) == actionBits ) && impliesPath ( permission . getName ( ) ) ; }
the action string .
the name of the log .
a state change notification .
the state to bind to a remote object .
the value of the given type .
the name of the context service .
all interceptors of the given class .
a method interceptor .
a dependency to the component .
< InterceptorFactory > getComponentInterceptors ( Method method ) { Map < Method , OrderedItemContainer < List < InterceptorFactory > > > map = componentInterceptors ; OrderedItemContainer < List < InterceptorFactory > > interceptors = map . get ( method ) ; if ( interceptors == null ) { return Collections . emptyList ( ) ; } List < List < InterceptorFactory > > sortedItems = interceptors . getSortedItems ( ) ; for ( List < InterceptorFactory > item : sortedItems ) { ret . addAll ( item ) ; } return ret ; }
timeout interceptor .
a timeout view interceptor .
aroundConstructInterceptors ( InterceptorFactory interceptorFactory ) { aroundConstructInterceptors . add ( interceptorFactory ) ; return this ; }
a postConstruct interceptor .
preDestroy interceptor to preDestroyInterceptors .
prePassivateInterceptor ( InterceptorFactory interceptorFactory ) { prePassivateInterceptors . add ( interceptorFactory ) ; return interceptorFactory ; }
postActivateInterceptor ( InterceptorFactory interceptorFactory ) { postActivateInterceptors . add ( interceptorFactory ) ; return this ; }
the component create service factory .
JNDI aliases .
a new EJBClientContext . Builder ( ) { return this ; }
the contextServiceName of the component .
the contextServiceName of the module .
bindInfoFor ( String app , String module , String comp , boolean useCompNamespace , final String envEntryName ) { if ( envEntryName . startsWith ( " java : " ) ) { if ( useCompNamespace ) { return bindInfoFor ( app , module , comp , " java : comp / env / " + envEntryName ) ; } else { return bindInfoFor ( app , module , comp , " java : module / env / " + envEntryName ) ; } } else { if ( useCompNamespace ) { return bindInfoFor ( app , module , comp , " java : comp / env / " + envEntryName ) ; } else { return bindInfoFor ( app , module , comp , " java : module / env / " + envEntryName ) ; } } }
bindInfoFor ( final String jndiName ) throws NamingException { if ( jndiName . startsWith ( " java : " ) ) { bindName = jndiName . substring ( 7 ) ; } else if ( jndiName . startsWith ( " jboss : " ) ) { bindName = jndiName . substring ( 8 ) ; } else if ( jndiName . startsWith ( " jboss : " ) ) { bindName = jndiName . substring ( 9 ) ; } else if ( jndiName . startsWith ( " jboss : " ) ) { bindName = jndiName . substring ( 10 ) ; } else if ( jndiName . startsWith ( " jboss : " ) ) { bindName = jndiName . substring ( 9 ) ; } else if ( jndiName . startsWith ( " jboss : " ) ) { bindName = jndiName . substring ( 10 ) ; } else if ( jndiName . startsWith ( " jboss : " ) ) { bindName = jndiName . substring ( 11
the domain info from the cache .
the value members .
the value members of a given type .
a subsystem root .
the config file .
a naming service .
a WeldIntegration interceptor for the given component .
the job operator service .
a view component to the deployment root .
a message destination .
the view descriptions for a given viewType .
the components from the deployment root .
the components of the given view .
the message destination from the deployment root .
a transformation for a hornetq server .
a defined attribute with a default value .
an attribute to an alias .
( final ContextStateCache stateCache ) { if ( stateCache . getSecurityContext ( ) != null ) { stateCache . getSecurityContext ( ) . popIdentity ( ) ; } }
( ) { apiIds . put ( " main " , ModuleIdentifier . create ( API_MODULE ) ) ; injectionIds . put ( " main " , ModuleIdentifier . create ( Injection_MODULE ) ) ; allVersions . add ( " main " ) ; activeVersions . add ( " main " ) ; }
versionIntegrity ( ) { if ( apiIds . containsKey ( version ) ) { JSFLogger . ROOT_LOGGER . missingJSFModule ( version , API_MODULE ) ; } }
the slot for the given jsf version .
the constantTypeCode of the given class .
a TypeCode to the given Class .
( LocalContainer c , String previous , String remainder ) throws IRConstructionException { if ( remainder == null ) throw IIOPLogger . ROOT_LOGGER . collisionWhileCreatingPackage ( ) ; if ( previous == null ) throw IIOPLogger . ROOT_LOGGER . collisionWhileCreatingPackage ( ) ; if ( remainder . length ( ) == 0 ) throw IIOPLogger . ROOT_LOGGER . collisionWhileCreatingPackage ( ) ; if ( remainder . length ( ) == 0 ) throw IIOPLogger . ROOT_LOGGER . collisionWhileCreatingPackage ( ) ; if ( remainder . length ( ) == 0 ) throw IIOPLogger . ROOT_LOGGER . collisionWhileCreatingPackage ( ) ; if ( remainder . length ( ) == 0 ) throw IIOPLogger . ROOT_LOGGER . collisionWhileCreatingPackage ( ) ; if ( remainder . length ( ) == 0 ) throw IIOPLogger . ROOT_LOGGER . collisionWhileCreatingPackage ( )
interfaces to the container .
abstract base valuetypes .
a class to the classpath .
a new interface to an existing module .
addValue ( ValueAnalysis va ) throws RMIIIOPViolationException { ValueDefImpl vDef ; Class cls = va . getCls ( ) ; vDef = ( ValueDefImpl ) valueMap . get ( cls ) ; if ( vDef != null ) { return vDef ; } return vDef ; }
a new ExceptionDef to the exception repository .
the class level injection type .
if jts is enabled .
a service based naming store .
the context .
if the method is allowed .
if the current sync method is denied .
( DeploymentUnit deploymentUnit , CompositeIndex index , WarMetaData metaData ) { if ( metaData == null ) return new HashSet < String > ( ) ; if ( metaData . getMergedJBossWebMetaData ( deploymentUnit ) != null ) { getAllComponentClasses ( metaData . getMergedJBossWebMetaData ( deploymentUnit ) , new HashSet < String > ( ) ) ; } if ( metaData . getMergedJBossWebMetaData ( deploymentUnit ) != null ) { getAllComponentClasses ( metaData . getMergedJBossWebMetaData ( deploymentUnit ) , new HashSet < String > ( ) ) ; } }
( ) { return waitingOnTxCompletionTimers ; }
extra parameters .
< String , Object > getParameters ( final OperationContext context , final ModelNode config ) throws OperationFailedException { Map < String , String > fromModel = CommonAttributes . PARAMS . unwrap ( context , config ) ; Map < String , Object > parameters = new HashMap < > ( ) ; for ( Map . Entry < String , String > entry : fromModel . entrySet ( ) ) { parameters . put ( entry . getKey ( ) , entry . getValue ( ) ) ; } return parameters ; }
< ? > toClass ( Class < ? > clazz ) { return clazz ; }
the value to a String .
the types of the values .
if the typeNames and typeInfos are the same .
the next binding .
the next binding list .
a javax . naming . Binding object .
health check procedure .
the health check .
the reference for the EJBLocator .
the handle for the given locator .
the enum value to a string .
the InputStream .
if the element1 and element2 are the same .
a new component to the given module .
< ClassLoader > addClassLoaders ( ClassLoader topLevel , Set < ClassLoader > allClassLoaders ) { deploymentClassLoaders . put ( topLevel , allClassLoaders ) ; return allClassLoaders ; }
( final Name name ) throws NamingException { if ( isLastComponentEmpty ( name ) ) { throw emptyNameException ( ) ; } writeLock . lock ( ) ; try { root . accept ( new UnbindVisitor ( name ) ) ; } finally { writeLock . unlock ( ) ; } }
the given name .
< NameClassPair > list ( ) throws NamingException { final Name nodeName = name . isEmpty ( ) ? new CompositeName ( " " ) : name ; return root . accept ( new ListVisitor ( nodeName ) ) ; }
< Binding > listBindings ( ) throws NamingException { final Name nodeName = name . isEmpty ( ) ? new CompositeName ( " " ) : name ; return root . accept ( new ListBindingsVisitor ( nodeName ) ) ; }
a new ContextHandleFactory .
the context .
a new Io subsystem .
a welcome content handler .
the bean from the semaphore .
the operation analysis map .
the resource metrics .
a WSEndpointDeploymentUnit .
a ServiceTarget to a DeploymentUnit .
a web application to a given deployment unit .
( Deployment deployment ) throws Exception { try { context = deployment . getAttachment ( WebDeploymentController . class ) ; context . stop ( ) ; } catch ( Exception e ) { throw WSLogger . ROOT_LOGGER . stopContextPhaseFailed ( e ) ; } }
the Weld container .
a new endpoint config .
the timeout of the timer .
( TimerImpl timer ) throws InterruptedException { timerService . persistTimer ( timer , false ) ; }
[ ] getDeclaredMethods ( final Class < ? > c ) { if ( System . getSecurityManager ( ) == null ) return c . getDeclaredMethods ( ) ; return AccessController . doPrivileged ( new PrivilegedAction < Method [ ] > ( ) { public Method [ ] run ( ) { return c . getDeclaredMethods ( ) ; } } ) ; }
getDeclaredFields ( final Class < ? > c ) { if ( System . getSecurityManager ( ) == null ) return c . getDeclaredFields ( ) ; return AccessController . doPrivileged ( new PrivilegedAction < Field [ ] > ( ) { public Field [ ] run ( ) { return c . getDeclaredFields ( ) ; } } ) ; }
the constructor of the specified class .
the method of the specified class .
a messaging activeMQ extension .
whether the parameter is allowed .
( ModelNode addOperation ) { String factoryClass = addOperation . get ( FACTORY_CLASS . getName ( ) ) . asString ( ) ; final String newFactoryClass ; switch ( factoryClass ) { case HORNETQ_NETTY_ACCEPTOR_FACTORY : newFactoryClass = ARTEMIS_NETTY_ACCEPTOR_FACTORY ; break ; case HORNETQ_NETTY_CONNECTOR_FACTORY : newFactoryClass = ARTEMIS_NETTY_CONNECTOR_FACTORY ; break ; default : newFactoryClass = factoryClass ; } addOperation . get ( FACTORY_CLASS . getName ( ) ) . set ( newFactoryClass ) ; }
the current state .
the state of the current thread .
the property type to the given type .
( OFromClause target , OBinaryCompareOperator operator , Object right ) { if ( this . identifier == null ) { return false ; } return identifier . canExecuteIndexedFunctionWithoutIndex ( target , context , operator , right ) ; }
the indexes of the given class .
all classes in the given directory .
< ? > getClassessOfInterface ( String thePackage , Class < ? > theInterface , final ClassLoader iClassLoader ) { List < Class < ? > > classList = new ArrayList < Class < ? > > ( ) ; try { for ( Class < ? > discovered : getClassesFor ( thePackage , iClassLoader ) ) { if ( Arrays . asList ( discovered . getInterfaces ( ) ) . contains ( theInterface ) ) { classList . add ( discovered ) ; } } } catch ( ClassNotFoundException ex ) { OLogManager . instance ( ) . error ( null , " Error finding classes " , ex ) ; } return classList ; }
( final Field p ) { if ( p . getType ( ) instanceof Class < ? > ) { return ( Class < ? > ) p . getType ( ) ; } else if ( p . getType ( ) instanceof ParameterizedType ) { return ( ParameterizedType ) p . getType ( ) ; } else if ( p . getType ( ) instanceof ParameterizedType ) { final ParameterizedType pt = ( ParameterizedType ) p . getType ( ) ; if ( pt . getActualTypeArguments ( ) != null && pt . getActualTypeArguments ( ) . length > 1 ) { if ( pt . getActualTypeArguments ( ) [ 1 ] instanceof Class < ? > ) { return ( Class < ? > ) pt . getActualTypeArguments ( ) [ 1 ] ; } else if ( pt . getActualTypeArguments ( ) [ 1 ] instanceof ParameterizedType ) return ( Class < ? > ) ( ( ParameterizedType ) pt . getActualTypeArguments ( ) [ 1 ] ) . getRawType (
the result of the query .
( ODocument iRecord , String fieldName , OType requestedFieldType ) { if ( iRecord . getSchemaClass ( ) . existsProperty ( fieldName ) ) { return iRecord . getSchemaClass ( ) . getProperty ( fieldName ) . getType ( ) ; } if ( requestedFieldType != null ) { return requestedFieldType ; } return null ; }
the record .
the record in Level1 Cache .
the minimum set of nodes for a sharded query .
( List < OAndBlock > flattenedWhereClause ) { if ( flattenedWhereClause == null ) { return null ; } List < OAndBlock > result = new ArrayList < > ( ) ; for ( OAndBlock block : flattenedWhereClause ) { List < OBooleanExpression > equalityExpressions = new ArrayList < > ( ) ; List < OBooleanExpression > nonEqualityExpressions = new ArrayList < > ( ) ; for ( OBooleanExpression exp : block . getSubBlocks ( ) ) { if ( exp . getOperator ( ) instanceof OEqualsCompareOperator ) { equalityExpressions . add ( exp ) ; } else { nonEqualityExpressions . add ( exp ) ; } } result . add ( block ) ; } return result ; }
( QueryPlanningInfo info ) { addOrderByProjections ( info ) ; }
all subqueries from the query planning info .
the clusters from the given ORid .
the index for the given class .
whether a given class is a diamond hierarchy .
the order direction .
whether the key condition has multiple index lookups .
( OCommandContext ctx , Set < OIndex < ? > > indexes ) { List < IndexSearchDescriptor > descriptors = indexes . stream ( ) . filter ( x -> x . getInternal ( ) . canBeUsedInEqualityOperators ( ) ) . map ( index -> buildIndexSearchDescriptor ( ctx , index , block , clazz ) ) . filter ( Objects :: nonNull ) . filter ( x -> x . keyCondition != null ) . filter ( x -> x . keyCondition . getSubBlocks ( ) . size ( ) > 0 ) . collect ( Collectors . toList ( ) ) ; descriptors . addAll ( descriptors ) ; }
buildIndexSearchDescriptorForFulltext ( OCommandContext ctx , OIndex < ? > index ) { return new IndexSearchDescriptor ( ) ; }
a new IndexSearchDescriptor from the given index search descriptors .
a smart field handling strategy .
the roles of the given resource .
if a rule is defined .
( final ODistributedServerManager manager , final ODocument distribCfg ) { final StringBuilder buffer = new StringBuilder ( ) ; final Collection < ODocument > members = distribCfg . field ( " members " ) ; if ( members != null ) { buffer . append ( " { " ) ; int memberCount = 0 ; for ( ODocument m : members ) { if ( m == null ) continue ; if ( memberCount ++ > 0 ) buffer . append ( " , " ) ; buffer . append ( m . field ( " name " ) ) ; buffer . append ( " = " ) ; buffer . append ( manager . getDatabaseStatus ( serverName , m . field ( " status " ) ) ) ; buffer . append ( " ( " ) ; buffer . append ( manager . getServerRole ( serverName ) ) ; buffer . append ( " ) " ) ; } buffer . append ( " } " ) ; } }
the system database .
local databases .
the server from the cluster .
new lock manager .
a lock manager to the current node .
a micro - transaction .
the micro - transaction .
identity after record commit .
( ) { final OLocalRecordCache databaseLocalCache = database . getLocalCache ( ) ; for ( ORecordOperation recordOperation : recordOperations . values ( ) ) databaseLocalCache . deleteRecord ( recordOperation . getRecord ( ) ) ; }
( Path path ) throws IOException { if ( Files . deleteIfExists ( path ) ) OLogManager . instance ( ) . warn ( requester , " ' % s ' deleted while % s " , path , operation ) ; }
the atomic file to the target .
.
only locally .
characters to the StringBuilder .
true if the socket is closed .
( final ByteBuffer buffer , final ByteBuffer buffer1 ) { short result = 0 ; result = ( short ) ( result | ( buffer . get ( ) & MASK ) ) ; result = ( short ) ( result | ( buffer1 . get ( ) & MASK ) ) ; return result ; }
( final ByteBuffer buffer , final ByteBuffer buffer1 , final short MASK ) { buffer . put ( ( byte ) ( MASK & ( iValue >>> SIZE_OF_BYTE_IN_BITS ) ) ) ; buffer1 . put ( ( byte ) ( MASK & iValue ) ) ; }
the command .
a single value to the index .
a value from a key .
< T > run ( final Object ... iArgs ) { final ODatabaseDocumentInternal database = ODatabaseRecordThreadLocal . instance ( ) . get ( ) ; if ( database == null ) throw new OQueryParsingException ( " No database configured " ) ; ( ( OMetadataInternal ) database . getMetadata ( ) ) . makeThreadLocalSchemaSnapshot ( ) ; try { setParameters ( iArgs ) ; Object o = database . getStorage ( ) . command ( this ) ; if ( o instanceof List ) { return ( List < T > ) o ; } else { return ( List < T > ) Collections . singletonList ( o ) ; } } finally { ( ( OMetadataInternal ) database . getMetadata ( ) ) . clearThreadLocalSchemaSnapshot ( ) ; } }
the first command .
a new file .
if the file size is greater than the specified size .
the content with the new content file .
a command .
endRequest ( ) { return endRequest ; }
a new available server to the specified host .
a new OChannelBinaryAsynchClient .
the current database .
the client connection .
the binary protocol .
the connection .
a connection from the server .
cluster configuration to the remote client .
the value on the current index .
the lock against the given record .
the schema .
the metadata .
the last record in the cluster range .
the next character .
the command .
public OCommandRequestAbstract onAsyncReplicationError ( final OAsyncReplicationError iCallback ) { if ( iCallback != null ) { onAsyncReplicationError = new OAsyncReplicationError ( ) { int retry = 0 ; @ Override public ACTION onAsyncReplicationError ( Throwable iException , final int iRetry ) { switch ( iCallback . onAsyncReplicationError ( iException , ++ retry ) ) { case RETRY : execute ( ) ; break ; case IGNORE : } return ACTION . IGNORE ; } } ; } else onAsyncReplicationError = null ; return this ; }
storage compression algorithm .
( boolean verbose ) { if ( Platform . isLinux ( ) ) { if ( verbose ) { OLogManager . instance ( ) . infoNoDb ( this , " Linux OS is detected , % d limit of open files will be set for the disk cache . " , defLimit ) ; } return defLimit ; } if ( Platform . isWindows ( ) ) { if ( verbose ) { OLogManager . instance ( ) . infoNoDb ( this , " Windows OS is detected , % d limit of open files will be set for the disk cache . " , defLimit ) ; } return defLimit ; } if ( Platform . isLinux ( ) ) { if ( verbose ) { OLogManager . instance ( ) . infoNoDb ( this , " Linux OS is detected , % d limit of open files will be set for the disk cache . " , defLimit ) ; } return defLimit ; } if ( Platform . isLinux ( )
( OFromClause target ) { if ( this . childExpressions . size ( ) != 1 ) { return false ; } return this . childExpressions . get ( 0 ) . allowsIndexedFunctionExecutionOnTarget ( target ) ; }
the buffer to the given position .
the buffer .
a script line step .
the full script line step .
boolean evaluateRecord ( final OIdentifiable iRecord , ODocument iCurrentResult , final OSQLFilterCondition iCondition , final Object iLeft , final Object iRight , final OCommandContext iContext , final ODocumentSerializer serializer ) { return true ; }
the command .
the configuration from the database .
the query text .
the request .
the schedule starting at the startNode .
a new index definition .
the aggregate into a projection item .
the type of the object .
the collate for the given document .
the value of the given string .
( int probe ) { this . probe . get ( ) . set ( probe ) ; return probe ; }
the command .
the json file from the given path .
the password .
a hash from a given input string .
if a PBKDF2_SHA256 algorithm is supported .
a new index .
the vertices of the given graph .
< Edge > getEdges ( ) { return edges ; }
the partition key for the given task .
the timeout for the given task .
getFeatures ( ) { if ( FEATURES == null ) { FEATURES = new Features ( ) ; FEATURES . supportsVertexIteration = true ; FEATURES . supportsVertexKeyIndex = true ; FEATURES . supportsEdgeIteration = true ; FEATURES . supportsEdgeRetrieval = true ; FEATURES . supportsEdgeKeyIndex = true ; FEATURES . supportsEdgeKeyIndex = true ; FEATURES . supportsEdgeKeyIndex = true ; FEATURES . supportsEdgeKeyIndex = true ; FEATURES . supportsEdgeIteration = true ; FEATURES . supportsEdgeRetrieval = true ; FEATURES . supportsEdgeKeyIndex = true ; FEATURES . supportsEdgeKeyIndex = true ; FEATURES . supportsEdgeKeyIndex = true ; FEATURES . supportsEdgeIteration = true ; FEATURES . supportsEdgeRetrieval = true ; FEATURES . supportsEdgeKeyIndex = true ; FEATURES . supportsEdgeKeyIndex = true ; FEATURES . supportsEdgeKeyIndex = true ; FEATURES
if the changes container is empty .
a timeout string .
the lock strategy for a given key .
a new cluster .
the cluster .
the number of entries in the cache .
the profiler .
a new OScriptResultSet from the given entity .
an access to the given resource .
the ORole .
the record .
parameters to the query parameters .
the table .
the index of the item .
the spread of an int .
a new index .
dropIndexes ( ) { getDatabase ( ) . checkSecurity ( ORule . ResourceGeneric . SCHEMA , ORole . PERMISSION_DELETE ) ; }
the index for the given globalRef .
the linked class .
a ODocument to an OTrackedSet .
the listener from the database .
a new database .
the request .
the database document .
a single item of a multi value field .
( final OSBTreeRidBag delegate ) { if ( delegate == null ) throw new IllegalArgumentException ( " delegate cannot be null . " ) ; if ( delegate instanceof OSBTreeRidBag ) { final OSBTreeRidBag treeBag = ( OSBTreeRidBag ) delegate ; treeBag . setCollectionPointer ( pointer ) ; treeBag . setOwner ( delegate . getOwner ( ) ) ; for ( OMultiValueChangeListener < OIdentifiable , OIdentifiable > listener : delegate . getChangeListeners ( ) ) treeBag . addChangeListener ( listener ) ; delegate = treeBag ; } }
the result to a Map .
a cluster to the database .
the pooled database .
the storage .
the types of the function .
< String > getCollateTypes ( ) { Set < String > types = new HashSet < String > ( ) ; final Iterator < OCollateFactory > ite = getCollateFactories ( ) ; while ( ite . hasNext ( ) ) { types . addAll ( ite . next ( ) . getNames ( ) ) ; } return types ; }
the command names .
the field size from the current position .
status to the response .
( final String iContentType , final boolean iKeepAlive ) { response . writeHeaders ( iContentType , iKeepAlive ) ; return this ; }
records to the response .
( final ORecord iRecord ) throws IOException { response . writeRecord ( iRecord , iFetchPlan , null ) ; return this ; }
a response to the server .
a stream to the server .
a database object .
the database pool .
for changes to the collection .
( ) { final Component currentComponent = componentsStack . peek ( ) ; if ( currentComponent == null ) return ; currentComponent . operationCount -- ; if ( currentComponent . operationCount == 0 ) { final String componentName = currentComponent . name ; PerformanceCountersHolder cHolder = countersByComponent . computeIfAbsent ( componentName , k -> currentComponent . type . newCountersHolder ( ) ) ; cHolder . operationsCount ++ ; makeSnapshotIfNeeded ( - 1 ) ; } }
counters to the snapshot .
( ) { if ( snapshot == null ) return holder ; if ( snapshot . writCacheCountersHolder == null ) return holder ; if ( holder == null ) holder = new WritCacheCountersHolder ( ) ; snapshot . writCacheCountersHolder . pushData ( holder ) ; return holder ; }
a StorageCountersHolder to the snapshot .
a WALCountersHolder to the snapshot .
the counters to the component .
the write cache flush timer .
( ) { writCacheCountersHolder = null ; }
the full checkpoint timer .
the commit timer .
.
.
the statement from the database .
messages from OrientDB DistributedDiscovery thread .
a disconnect timer .
a record from the graph .
the property of the graph element .
a property from the graph .
a new class from the given schema .
( OIndex < ? > source , OIndexCursor cursor ) { if ( cursor instanceof OIndexChangesWrapper ) return cursor ; if ( cursor instanceof OSizeable ) { return new OIndexChangesSizeable ( source , cursor , indexRebuildVersion ) ; } return new OIndexChangesWrapper ( source , cursor , indexRebuildVersion ) ; }
defineVertexAttributeStrategy ( final String iAttributeName , final OGraphMLImportStrategy iStrategy ) { vertexPropsStrategy . put ( iAttributeName , iStrategy ) ; return this ; }
defineEdgeAttributeStrategy ( final String iAttributeName , final OGraphMLImportStrategy iStrategy ) { edgePropsStrategy . put ( iAttributeName , iStrategy ) ; return this ; }
< ORecordOperation > getNewRecordEntriesByClass ( final OClass iClass , final boolean iPolymorphic ) { final List < ORecordOperation > result = new ArrayList < ORecordOperation > ( ) ; if ( iClass == null ) for ( ORecordOperation entry : allEntries . values ( ) ) { if ( entry . type == ORecordOperation . CREATED ) result . add ( entry ) ; } return result ; }
< ORecordOperation > getNewRecordEntriesByClusterIds ( final int [ ] iIds ) { final List < ORecordOperation > result = new ArrayList < ORecordOperation > ( ) ; if ( iIds == null ) for ( ORecordOperation entry : allEntries . values ( ) ) if ( entry . type == ORecordOperation . CREATED ) result . add ( entry ) ; else for ( ORecordOperation entry : allEntries . values ( ) ) { for ( int id : iIds ) { if ( entry . getRecord ( ) != null && entry . getRecord ( ) . getIdentity ( ) . getClusterId ( ) == id ) { result . add ( entry ) ; break ; } } } return result ; }
a new index entry .
Set < ORecord > mergeSet ( Set < ORecord > target , Set < ORecord > source ) { if ( source != null ) { if ( target == null ) { return source ; } else { if ( target . size ( ) > source . size ( ) ) { target . addAll ( source ) ; return target ; } else { source . addAll ( target ) ; return source ; } } } else { if ( target == null ) { return source ; } else { return mergeSet ( target , source ) ; } } }
true if the record is updated .
( String name ) { if ( name == null ) { return false ; } if ( name . length ( ) == 0 ) { return true ; } if ( name . length ( ) == 1 ) { return true ; } if ( name . length ( ) == 2 ) { return true ; } if ( name . length ( ) == 3 ) { return true ; } if ( name . length ( ) == 4 ) { return true ; } if ( name . length ( ) == 2 ) { return true ; } return false ; }
( OIndex < ? > index , Object keys ) { final OIndexDefinition indexDefinition = index . getDefinition ( ) ; if ( keys instanceof Collection ) { final Set < Comparable > newKeys = new TreeSet < Comparable > ( ) ; for ( Object o : ( ( Collection ) keys ) ) { newKeys . add ( ( Comparable ) indexDefinition . createValue ( o ) ) ; } return newKeys ; } else { return Collections . emptySet ( ) ; } }
a new page .
the last written page .
the page .
the last WAL page .
true if the replication is active .
a new node strategy .
whether the execution mode is synchronous .
your writes from distributed - config . json .
the cluster names from the server .
all configured servers .
if the server is contained in the cluster .
if the server is contained in the cluster .
the masters of the cluster .
< String > getAllConfiguredServers ( ) { return new HashSet < String > ( ) ; }
the clusters on the server .
getClustersOwnedByServer ( final String iNodeName ) { final Set < String > clusters = new HashSet < String > ( ) ; for ( String cl : getClusterNames ( ) ) if ( iNodeName . equals ( getClusterOwner ( cl ) ) ) clusters . add ( cl ) ; return clusters ; }
the cluster owner .
the owner of the cluster .
the list of configured servers .
the registered servers .
< String > getDataCenters ( ) { final ODocument dcs = configuration . field ( DCS ) ; if ( dcs == null ) return Collections . EMPTY_SET ; final Set < String > result = new HashSet < String > ( ) ; for ( String dc : dcs . fieldNames ( ) ) { result . add ( dc ) ; } return result ; }
the write quorum of the data center .
whether the cluster is sharded .
the list of servers for the given data center .
the data center of the specified server .
the read quorum of the given cluster .
the write quorum .
the cluster configuration .
the data center configuration .
the initialization stack .
< T > getIndex ( final String indexName , final Class < T > indexClass ) { makeActive ( ) ; final OIndexManager indexManager = getDatabase ( ) . getMetadata ( ) . getIndexManager ( ) ; final OIndex idx = indexManager . getIndex ( indexName ) ; if ( idx == null || ! hasIndexClass ( idx ) ) throw ExceptionFactory . indexDoesNotSupportClass ( indexName , indexClass ) ; return idx ; }
the index from the database .
( final Object id ) { makeActive ( ) ; return addVertex ( id , ( Object [ ] ) null ) ; }
addEdge ( final Object id , final Vertex outVertex , final Vertex inVertex ) { if ( outVertex instanceof PartitionVertex ) outVertex = ( ( PartitionVertex ) outVertex ) . getBaseVertex ( ) ; if ( inVertex instanceof PartitionVertex ) inVertex = ( ( PartitionVertex ) inVertex ) . getBaseVertex ( ) ; if ( id != null ) { if ( id instanceof String ) { final String [ ] args = ( ( String ) id ) . split ( " , " ) ; for ( String s : args ) { if ( s . startsWith ( CLASS_PREFIX ) ) className = s . substring ( CLASS_PREFIX . length ( ) ) ; else if ( s . startsWith ( CLUSTER_PREFIX ) ) clusterName = s . substring ( CLUSTER_PREFIX . length ( ) ) ; } } } }
the vertex with the given id .
Iterable < Vertex > getVerticesOfClass ( final String iClassName ) { makeActive ( ) ; final OClass cls = getRawGraph ( ) . getMetadata ( ) . getSchema ( ) . getClass ( iClassName ) ; if ( cls == null ) throw new IllegalArgumentException ( " Cannot find class ' " + iClassName + " ' in database schema " ) ; if ( ! cls . isSubClassOf ( OrientVertexType . CLASS_NAME ) ) throw new IllegalArgumentException ( " Class ' " + iClassName + " ' is not a vertex class " ) ; return new OrientElementScanIterable < Vertex > ( this ) ; }
( final String iClassName ) { return getEdgesOfClass ( iClassName , false ) ; }
getEdge ( final Object id ) { makeActive ( ) ; if ( null == id ) throw ExceptionFactory . edgeIdCanNotBeNull ( ) ; if ( id instanceof OrientEdge ) return ( OrientEdge ) id ; else if ( id instanceof ODocument ) return new OrientEdge ( this , ( ODocument ) id ) ; else if ( id instanceof OIdentifiable ) return new OrientEdge ( this , ( OIdentifiable ) id ) ; }
reuse ( final ODatabaseDocumentInternal iDatabase ) { ODatabaseRecordThreadLocal . instance ( ) . set ( iDatabase ) ; database = iDatabase ; makeActive ( ) ; return this ; }
the database .
getVertexType ( ) { makeActive ( ) ; return new OrientVertexType ( this ) ; }
getVertexType ( ) { makeActive ( ) ; final OClass cls = getRawGraph ( ) . getMetadata ( ) . getSchema ( ) . getClass ( iTypeName ) ; if ( cls == null ) return null ; OrientVertexType . checkType ( cls ) ; return new OrientVertexType ( this , cls ) ; }
( final String iClassName , final int clusters ) { makeActive ( ) ; return createVertexType ( iClassName , clusters ) ; }
the vertex type .
( final String iTypeName ) { makeActive ( ) ; final OClass cls = getRawGraph ( ) . getMetadata ( ) . getSchema ( ) . getClass ( iTypeName ) ; if ( cls == null ) return null ; OrientEdgeType . checkType ( cls ) ; return new OrientEdgeType ( this , cls ) ; }
( final String iClassName ) { makeActive ( ) ; return createEdgeType ( iClassName , ( String ) null , clusters ) ; }
the element from the given id .
a key index .
a key index .
background exception listeners .
( final Throwable e ) { for ( final WeakReference < OBackgroundExceptionListener > ref : backgroundExceptionListeners ) { if ( ref . get ( ) != null ) { listener . onException ( e ) ; } } }
monitoring .
a profiler MBean .
MBean for performance statistics .
fetchWriteCacheCounters ( Map < Thread , PerformanceSnapshot > statistics ) { if ( statistics == null ) { return null ; } if ( statistics . size ( ) == 0 ) { return new WritCacheCountersHolder ( ) ; } if ( statistics . size ( ) == 1 ) { return new WritCacheCountersHolder ( ) ; } if ( statistics . size ( ) == 2 ) { return new WritCacheCountersHolder ( ) ; } if ( statistics . size ( ) == 3 ) { return new WritCacheCountersHolder ( ) ; } return new WritCacheCountersHolder ( ) ; }
the system counters from the database .
the counters for the given component .
a JSON string into a GZIPOutputStream .
the value of the property .
( final Object iPojo , boolean returnNonProxiedInstance ) { return ( RET ) OObjectEntitySerializer . detach ( iPojo , this , returnNonProxiedInstance ) ; }
the version of a user object .
a new OCommandSQLPojoWrapper for the given command .
the dirty property of the object .
( final Object iPojo ) { if ( iPojo == null ) return ; final ODocument record = getRecordByUserObject ( iPojo , false ) ; if ( record == null ) return ; ORecordInternal . unsetDirty ( record ) ; }
the index types .
the index engines .
the missing nodes from the response .
the servers for the given group .
the maximum number of coherent responses for a given group .
the quorum response .
the parsed responses .
the execution plan for a given statement .
boolean allowsIndexedFunctionExecutionOnTarget ( OFromClause target , OCommandContext context ) { return left . allowsIndexedFunctionExecutionOnTarget ( target , context , operator , right . execute ( ( OResult ) null , context ) ) ; }
the function definition for the given database .
the database engine .
( final long fileId ) throws IOException { final long filledUpTo = getFilledUpTo ( atomicOperation , fileId ) ; final long pageIndex = filledUpTo - 1 ; final OCacheEntry cacheEntry = loadPageForRead ( atomicOperation , fileId , pageIndex , false , 1 ) ; try { final OClusterPositionMapBucket bucket = new OClusterPositionMapBucket ( cacheEntry , false ) ; final int bucketSize = bucket . getSize ( ) ; return pageIndex * OClusterPositionMapBucket . MAX_ENTRIES + bucketSize ; } finally { releasePageFromRead ( atomicOperation , cacheEntry ) ; } }
the size of the tree .
the value from the entry .
whether the index should be used by ordering after the equals filter fields .
( final String iText ) { if ( iText == null ) return - 1 ; if ( iText . length ( ) == 0 ) return - 1 ; if ( iText . charAt ( iText . length ( ) - 1 ) == ' ' ) return - 1 ; if ( iText . charAt ( iText . length ( ) - 1 ) == ' ' ) return - 1 ; if ( iText . charAt ( iText . length ( ) - 1 ) == ' ' ) return - 1 ; if ( iText . charAt ( iText . length ( ) - 1 ) == ' ' ) return - 1 ; if ( iText . charAt ( iText . length ( ) - 1 ) == ' ' ) return - 1 ; if ( iText . charAt ( iText . length ( ) - 1 ) == ' ' ) return - 1 ; if ( iText . charAt ( iText . length ( ) - 1 ) == ' ' ) { if ( iText . charAt ( iText . length ( ) - 1 ) ==
( final CharSequence iText , final int iCurrentPosition , final int iMaxPosition ) { return jump ( iText , iCurrentPosition , iMaxPosition , COMMON_JUMP ) ; }
the current position of the text .
the fetch plan .
( final ORecordId rid ) { if ( rid == null || ! rid . isPersistent ( ) ) return ; if ( rid . getClusterPosition ( ) < - 1 ) return ; records . put ( rid , Boolean . TRUE ) ; }
the repair record .
( final int clusterId ) { if ( clusterId < - 1 ) return ; recordProcessed . incrementAndGet ( ) ; clusters . put ( clusterId , Boolean . TRUE ) ; }
< String > getDependencies ( Pattern pattern ) { return getDependencies ( pattern ) ; }
a new pojo .
entity classes for class names .
entity classes .
the class handler .
( final String iName ) { setup ( ) ; return dbPool . acquire ( iName ) ; }
( final String name ) { setup ( ) ; return dbPool . getAvailableConnections ( name ) ; }
the DB .
synchronization of cluster .
( Class < T > clazz ) { return lookupProviderWithOrientClassLoader ( clazz , OClassLoaderHelper . class . getClassLoader ( ) ) ; }
the maximum memory size of the cache .
the vertex from the given json .
the edge from the given json .
the json from the given element .
a new object node from the given element .
an OETL job .
the status of the current job .
the active data center map .
the cipher transformation .
a OSymmetricKeyConfig to a OSymmetricKey .
a new OSymmetricKey from the given path .
a new OSymmetricKey from the given input stream .
the encrypted data .
( final OutputStream os ) throws OSecurityException { if ( os == null ) throw new OSecurityException ( " OSymmetricKey . saveToStream ( ) OutputStream is null " ) ; try { final OutputStreamWriter osw = new OutputStreamWriter ( os ) ; try { final BufferedWriter writer = new BufferedWriter ( osw ) ; try { writer . write ( getBase64Key ( ) ) ; } finally { writer . close ( ) ; } } finally { os . close ( ) ; } } catch ( Exception ex ) { throw OException . wrapException ( new OSecurityException ( " OSymmetricKey . saveToStream ( ) Exception : " + ex . getMessage ( ) ) , ex ) ; } }
to Keystore .
the child to the parent .
a unique result to the result .
the value of the given field .
the user to the database .
the value of the given key .
( final ORecord reusedRecord ) { if ( reusedRecord != null ) { record = reusedRecord ; record . reset ( ) ; } else record = null ; return record ; }
the current record from the database .
getTxGraph ( ) { if ( pool == null ) { g = ( OrientGraph ) getTxGraphImplFactory ( ) . getGraph ( getDatabase ( ) , user , password , settings ) ; } else { g = ( OrientGraph ) getTxGraphImplFactory ( ) . getGraph ( pool , settings ) ; } initGraph ( g ) ; return g ; }
the graph .
the database pool .
properties for the given name .
the transaction .
an OStatement .
the next token .
the token from the source .
an expentry for the given token .
Iterable < Vertex > getVertices ( final Direction iDirection , final String ... iLabels ) { setCurrentGraphInThreadLocal ( ) ; OrientBaseGraph . getEdgeClassNames ( getGraph ( ) , iLabels ) ; OrientBaseGraph . encodeClassNames ( iLabels ) ; final ODocument doc = getRecord ( ) ; final OMultiCollectionIterator < Vertex > iterable = new OMultiCollectionIterator < Vertex > ( ) ; for ( OTriple < String , Direction , String > connectionField : getConnectionFields ( iDirection , iLabels ) ) { String fieldName = connectionField . getKey ( ) ; OPair < Direction , String > connection = connectionField . getValue ( ) ; final Object fieldValue = doc . rawField ( fieldName ) ; if ( fieldValue != null ) if ( fieldValue instanceof OIdentifiable ) { addSingleVertex ( doc , iterable , fieldName , connection , fieldValue , iLabels ) ; } else if ( fieldValue instanceof List < ? > ) addSingleVertex ( doc , iterable
a node from the graph .
addEdge ( String label , Vertex inVertex ) { if ( inVertex instanceof PartitionVertex ) inVertex = ( ( PartitionVertex ) inVertex ) . getBaseVertex ( ) ; return addEdge ( label , ( OrientVertex ) inVertex , null , null , ( Object [ ] ) null ) ; }
addEdge ( final String label , final OrientVertex inVertex , final String iClassName ) { return addEdge ( label , inVertex , iClassName , null , ( Object [ ] ) null ) ; }
the connection class .
the connection class .
broken RIDs .
the methods of the given class .
a distributed request on a local node .
the number of nodes in the database .
the file .
for the next retry .
the value of the given argument .
the number of parameters in the request .
to the remote server / database .
the list of databases .
the server information .
existence of the remote storage .
the remote storage .
the remote storage .
the remote storage .
the cluster status .
an index .
getGraph ( final boolean autoStartTx , OModifiableBoolean shouldBeShutDown ) { final ODatabaseDocumentInternal database = ODatabaseRecordThreadLocal . instance ( ) . get ( ) ; final OrientBaseGraph result = OrientGraphFactory . getTxGraphImplFactory ( ) . getGraph ( database , shouldBeShutDown ) ; if ( result != null && ( result instanceof OrientGraph ) ) { return ( OrientGraph ) result ; } return null ; }
retry number .
a record to the database .
the record .
the authentication header from the database .
the given username and password .
boolean isAuthorized ( final String username , final String resource ) { if ( username == null || resource == null ) return false ; try { if ( getServer ( ) != null ) { OUser user = getServer ( ) . getSecurity ( ) . getSystemUser ( username , null ) ; if ( user != null && user . getAccountStatus ( ) == OSecurityUser . STATUSES . ACTIVE ) { ORole role = null ; ORule . ResourceGeneric rg = ORule . mapLegacyResourceToGenericResource ( resource ) ; if ( rg != null ) { String specificResource = ORule . mapLegacyResourceToSpecificResource ( resource ) ; if ( specificResource == null || specificResource . equals ( " * " ) ) { specificResource = null ; } role = user . checkIfAllowed ( rg , specificResource , ORole . PERMISSION_EXECUTE ) ; } return role != null ; } } return true ; }
public void shutdown ( ) { if ( server != null ) if ( ! server . shutdown ( ) ) { try { Thread . sleep ( 5000 ) ; } catch ( InterruptedException e ) { } } }
( int newLine , int newCol ) { if ( newLine > bufline [ bufsize - 1 ] ) bufline [ bufsize - 1 ] = newLine ; if ( newLine < bufline [ bufsize - 1 ] ) bufline [ bufsize - 1 ] = newLine ; if ( newCol > bufcolumn [ bufsize - 1 ] ) bufcolumn [ bufsize - 1 ] = newCol ; }
( int pageOffset , OBonsaiBucketPointer value ) throws IOException { setLongValue ( pageOffset , value . getPageIndex ( ) ) ; setIntValue ( pageOffset + OLongSerializer . LONG_SIZE , value . getPageOffset ( ) ) ; }
a bucket pointer .
an atomic operation .
( OAtomicOperation operation ) { if ( operation . containsInLockedObjects ( lockName ) ) { return ; } lockManager . acquireLock ( lockName , OOneEntryPerKeyLockManager . LOCK . EXCLUSIVE ) ; operation . addLockedObject ( lockName ) ; }
the maximum amount of memory used by disk cache .
for connections using the configured ports .
the parameters from the server .
the LogManager .
a closable entry .
the entry from the cache .
a new OClosableEntry .
the value of the given key .
the data .
the file .
are empty .
a task to the state buffer .
the entry from the read buffer .
the entry in the read buffer .
( int value ) { int n = value - 1 ; n |= n >>> 2 ; n |= n >>> 4 ; n |= n >>> 8 ; n |= n >>> 16 ; return ( n < 0 ) ? 1 : ( n >= ( 1 << 30 ) ) ? 1 << 30 : n + 1 ; }
push request .
a key to a value .
all enums to numbers .
the serializer for the given type .
( ) { initShutdownQueue ( ) ; }
( final String engineName ) { if ( engines . containsKey ( engineName ) ) { return engines . get ( engineName ) ; } return null ; }
the database .
a query .
a new ReadersEntry .
a user to the database .
a new user .
will try to acquire a read lock .
getVertex ( final Direction direction ) { if ( direction . equals ( Direction . OUT ) ) return graph . getVertex ( getOutVertex ( ) ) ; else if ( direction . equals ( Direction . IN ) ) return graph . getVertex ( getInVertex ( ) ) ; else throw ExceptionFactory . bothIsNotSupported ( ) ; }
( ) { if ( rawElement == null ) return vOut . getIdentity ( ) + " - > " + vIn . getIdentity ( ) ; setCurrentGraphInThreadLocal ( ) ; return super . getId ( ) ; }
the property of the element .
( String key ) { setCurrentGraphInThreadLocal ( ) ; }
the subtrees .
subtrees .
the batch importer job .
a vertex .
the strategy word .
the positions from an embedded collection .
the command .
a link to the database .
the record .
the version of the record .
the type of the record .
the database instance .
the exception stack trace .
( OCommandContext iContext , OIndex < ? > index , List < Object > keyParams , boolean ascSortOrder ) { return null ; }
( final Object iKey , final Object sourceRecord ) { if ( iKey == null || sourceRecord == null || sourceRecord . length ( ) == 0 || sourceRecord . length ( ) == 0 || sourceRecord . length ( ) == 0 || sourceRecord . length ( ) == 0 || sourceRecord . length ( ) == 0 || sourceRecord . length ( ) == 0 || sourceRecord . length ( ) == 0 || sourceRecord . length ( ) == 0 || sourceRecord . length ( ) == 0 || sourceRecord . length ( ) == 0 || sourceRecord . length ( ) == 0 || sourceRecord . length ( ) == 0 || sourceRecord . length ( ) == 0 || sourceRecord . length ( ) == 0 || sourceRecord . length ( ) == 0 || sourceRecord . length ( ) == 0 || sourceRecord . length ( ) == 0 || sourceRecord . length ( ) == 0 || sourceRecord . length ( ) == 0 )
a server command .
a server user configuration .
the condition .
an indexed property .
a new object to the specified class .
the index class from the given string .
the current value of the sequence .
the database .
the base class to the list of subclasses .
polymorphic cluster ids to indexes .
a link to an OIdentifiable .
( OPointer pointer ) { if ( pointerMapping . containsKey ( pointer ) ) { return pointerMapping . get ( pointer ) ; } return null ; }
memory leaks .
the pointers pool .
a byte array to an int .
the database .
the clusters of the given class .
the server status .
static int indexOf ( final Object [ ] array , final Comparable object ) { for ( int i = 0 ; i < array . length ; ++ i ) { if ( object . compareTo ( array [ i ] ) == 0 ) return i ; } return - 1 ; }
the index of the array .
( ) { return getInvolvedClustersOfClass ( parsedTarget . getTargetClasses ( ) . values ( ) ) ; }
the result to the last record .
the temporary RID counter from the parent query .
the tip of the message .
the fetch plan for the given word .
( final String w ) throws OCommandSQLParsingException { if ( ! w . equals ( KEYWORD_NOCACHE ) ) return false ; noCache = true ; return true ; }
( OClass iSchemaClass ) { this . iSchemaClass = iSchemaClass ; }
the status of the message handler .
a command .
the JVM error .
( final int indexId , final Object key , final ORID value , final OBaseIndexEngine . Validator < Object , ORID > validator ) throws OInvalidIndexEngineIdException { try { if ( transaction . get ( ) != null ) { return doValidatedPutIndexValue ( indexId , key , value , validator ) ; } return doValidatedPutIndexValue ( indexId , key , value , validator ) ; } catch ( final OInvalidIndexEngineIdException ie ) { throw logAndPrepareForRethrow ( ie ) ; } }
micro - transaction .
a command .
a cluster to the database .
the value of the property .
the command .
the SYNC DATABASE command .
a record from the database .
callbackHooks ( final List < ORecordHook > hooks ) { if ( hooks == null || hooks . isEmpty ( ) ) return ORecordHook . RESULT . RECORD_NOT_CHANGED ; final List < ORecordHook > hooksByScope = hooks . toArray ( new ORecordHook [ hooks . size ( ) ] ) ; if ( hooksByScope . isEmpty ( ) ) return ORecordHook . RESULT . RECORD_NOT_CHANGED ; return hooksByScope . get ( hooksByScope . size ( ) - 1 ) ; }
the database document .
the views in the database .
the number of classes in the database .
( ) { final ODatabaseRecordThreadLocal tl = ODatabaseRecordThreadLocal . instance ( ) ; if ( tl != null ) tl . set ( this ) ; return this ; }
storage encryption algorithm .
the relative position of the current chunk .
the optional word from the parser .
the required word from the parser .
the next word from the given text .
the optional keyword from the parser .
if the separator is valid .
if a class has been dropped from the database .
the configuration files .
the offset of the byte array .
the tokenType from the OAuth2AccessToken .
an OAuth2AccessToken for the given resource .
the token to the context .
true if no more characters are found .
( final byte [ ] array , final EnumSet < LineTerminator > terminators ) throws IOException { return readLine ( array , 0 , array . length , terminators ) ; }
( final byte [ ] array , final int off , final int len , final EnumSet < LineTerminator > terminators ) throws IOException { ByteArrays . ensureOffsetLength ( array , off , len ) ; if ( len == 0 ) return 0 ; if ( terminators . contains ( LineTerminator . LF ) ) return readLine ( array , off , len , terminators ) ; return readLine ( array , off , len , terminators ) ; }
the length of the buffer .
the stream .
offset length is greater than array length .
( final int from , final int to , final IntComparator c , final Swapper swapper ) { final int length = to - from ; if ( length < MERGESORT_NO_REC ) { for ( int i = from ; i < to ; i ++ ) { for ( int j = i ; j > from && ( c . compare ( j - 1 , j ) > 0 ) ; j -- ) { swapper . swap ( j , j - 1 ) ; } } return ; } for ( int i = from ; i < to ; i ++ ) { for ( int j = i ; j > from && ( c . compare ( j - 1 , j ) < 0 ) ; j -- ) { swapper . swap ( j , j - 1 ) ; } } }
( final Swapper swapper ) { for ( int i = 0 ; i < n ; i ++ , a ++ , b ++ ) swapper . swap ( a , b ) ; }
( final int from , final int to , final IntComparator comp ) { final ForkJoinPool pool = new ForkJoinPool ( Runtime . getRuntime ( ) . availableProcessors ( ) ) ; pool . invoke ( new ForkJoinGenericQuickSort ( from , to , comp ) ) ; }
murmurHash3 ( int x ) { x ^= x >>> 16 ; x *= 0x85ebca6b ; x ^= x >>> 13 ; x *= 0xc2b2ae35 ; x ^= x >>> 16 ; return x ; }
( long x ) { x ^= x >>> 33 ; x *= 0xff51afd7ed558ccdL ; x ^= x >>> 33 ; x *= 0xc4ceb9fe1a85ec53L ; x ^= x >>> 33 ; return x ; }
the contents to the file .
( final long size , final long writePosition ) throws IOException { if ( size > writePosition ) { throw new IOException ( " Truncated file . " ) ; } if ( size > writePosition ) { throw new IOException ( " Truncated file . " ) ; } if ( size > writePosition ) { throw new IOException ( " Truncated file . " ) ; } if ( size > writePosition ) { throw new IOException ( " Truncated file . " ) ; } if ( size > writePosition ) { throw new IOException ( " Truncated file . " ) ; } return this ; }
position ( ) throws IOException { if ( repositionableStream != null ) repositionableStream . position ( newPosition ) ; else if ( fileChannel != null ) fileChannel . position ( newPosition ) ; else throw new UnsupportedOperationException ( " position ( ) can only be called if the underlying byte stream implements the RepositionableStream interface or if the getChannel ( ) method of the underlying byte stream exists and returns a FileChannel " ) ; }
the consumer refresh end metrics .
the completion of the current task .
matches for the given query .
compaction targets for a given schema .
all snapshots .
the hash of a field .
if a field is equal to another field .
the referenced out of the closure .
complete .
the cycle metrics for the given status .
the header tags .
the primary key from the object .
all the segments .
the ordinals of a given type .
the size of a sparseBitSet .
the value of the field .
a ByteData to a ByteData .
the data from the source to the destination .
if a range is equal to another range .
a copy of a SegmentedByteArray .
the ordered copy of a byte array .
the length of the segment .
the start position to the file .
the number of segments in the array .
the index of the name field .
( MultiLinkedElementArray elementArray , GrowingSegmentedLongArray matchIndexHashAndSizeArray ) { if ( elementArray . numLists ( ) == 0 ) return 0 ; if ( matchIndexHashAndSizeArray . size ( ) == 0 ) return 0 ; if ( matchIndexHashAndSizeArray . size ( ) == 0 ) return 0 ; if ( matchIndexHashAndSizeArray . size ( ) == 0 ) return 0 ; return calculateDedupedSizesAndTotalNumberOfSelectBuckets ( elementArray , matchIndexHashAndSizeArray ) ; }
if the dataset has collections in it .
the files for the given package .
files for hollow schemas .
if a key matches a given value .
the record key .
a FieldPath < ObjectFieldSegment > for the given path .
a field path for hash index .
a FieldPath for a prefix index .
a new object into the array .
the average word length of the object .
the given key .
the percentage of the latest cardinality .
a field to the specified objectFilterConfig .
< HollowSchema > dependencyOrderedSchemaList ( Collection < HollowSchema > schemas ) { DependencyIndex idx = new DependencyIndex ( ) ; Map < String , HollowSchema > schemaMap = new HashMap < String , HollowSchema > ( ) ; for ( HollowSchema schema : schemas ) { schemaMap . put ( schema . getName ( ) , schema ) ; idx . indexSchema ( schema , schemas ) ; } return orderedSchemas ; }
( ) { usePackageGrouping = true ; useBooleanFieldErgonomics = true ; reservePrimaryKeyIndexForTypeWithPrimaryKey = true ; useVerboseToString = true ; }
the index of the segment .
matching records .
matching records for the given type .
( String ... paths ) { resetResults ( ) ; this . elementPaths = paths ; }
element key paths .
the result of the calculation .
the latest announcement .
the version of the cycle .
the key from the index .
( ) { Set < HollowReadStateEngine > stateEngines = new HashSet < HollowReadStateEngine > ( ) ; for ( Map . Entry < HollowTypeReadState , BitSet > entry : excludedOrdinals . entrySet ( ) ) stateEngines . add ( entry . getKey ( ) . getStateEngine ( ) ) ; return stateEngines ; }
a HollowBlobHeader .
type metrics for HollowReadStateEngine .
data to a ByteDataBuffer .
( ByteDataBuffer fieldBuffer , int intBits ) { fieldBuffer . write ( ( byte ) ( intBits >>> 24 ) ) ; fieldBuffer . write ( ( byte ) ( intBits >>> 16 ) ) ; fieldBuffer . write ( ( byte ) ( intBits >>> 8 ) ) ; fieldBuffer . write ( ( byte ) ( intBits ) ) ; }
( ByteDataBuffer fieldBuffer , long intBits ) { fieldBuffer . write ( byte ) ( intBits ) ; fieldBuffer . write ( ( byte ) ( intBits >>> 56 ) ) ; fieldBuffer . write ( ( byte ) ( intBits >>> 48 ) ) ; fieldBuffer . write ( ( byte ) ( intBits >>> 40 ) ) ; fieldBuffer . write ( ( byte ) ( intBits >>> 32 ) ) ; fieldBuffer . write ( ( byte ) ( intBits >>> 24 ) ) ; fieldBuffer . write ( ( byte ) ( intBits >>> 16 ) ) ; fieldBuffer . write ( ( byte ) ( intBits >>> 8 ) ) ; fieldBuffer . write ( ( byte ) ( intBits ) ) ; }
an ordinal to the pool .
the free ordinals .
the hash of the key and fieldType .
static int hash ( Object key ) { return HashCodes . hashInt ( HashCodes . hashCode ( ( Object ) key ) ) ; }
the storage .
( int preferredOrdinal ) { if ( preferredOrdinal != - 1 && unusedPreviousOrdinals . get ( preferredOrdinal ) ) { unusedPreviousOrdinals . clear ( preferredOrdinal ) ; return preferredOrdinal ; } return null ; }
a new array of pointers and ordinals .
a byteDataBuffer to a byteDataBuffer .
the underlying array for the map .
( byteData ) { long position = key & POINTER_MASK ; int sizeOfData = VarInt . readVInt ( byteData . getUnderlyingArray ( ) , position ) ; position += VarInt . sizeOfVInt ( sizeOfData ) ; return HashCodes . hashCode ( byteData . getUnderlyingArray ( ) , position ) ; }
a new AtomicLongArray .
if fieldMatchLists [ matchIdx ] . equals ( fieldSchemaPosition [ matchIdx ] ) { return true ; }
a match for the given key .
swap ( ) { return new ReadStateHelper ( newReadState ( current . getVersion ( ) , pending . getStateEngine ( ) ) , newReadState ( pending . getVersion ( ) , current . getStateEngine ( ) ) ) ; }
the size of the hash table .
a compaction cycle .
a snapshot to the stateEngine .
delta to the given state .
< String > schemaNameSet = Sets . newHashSet ( ) ; for ( String schemaName : schemaNames ) { if ( ! HollowCodeGenerationUtils . isCollectionType ( schemaName , dataset ) && ! HollowCodeGenerationUtils . isPrimitiveType ( schemaName ) ) { schemaNameSet . add ( schemaName ) ; } }
the field path to lowercase .
the hash index .
the hash index for the given query .
( int delayMillis ) { if ( delayMillis < 0 ) { delayMillis = 0 ; } else { delayMillis = delayMillis ; } return delayMillis ; }
a refresh on the client .
a type diff .
the diffs of a given type .
( OutputStream out , long value ) throws IOException { if ( value < 0 ) out . write ( ( byte ) 0x81 ) ; if ( value > 0xFFFFFFFFFFFFFFL || value < 0 ) out . write ( ( byte ) ( 0x80 | ( ( value >>> 56 ) & 0x7FL ) ) ) ; if ( value > 0x1FFFFFFFFFFFFL || value < 0 ) out . write ( ( byte ) ( 0x80 | ( ( value >>> 49 ) & 0x7FL ) ) ) ; if ( value > 0x3FFFFFFFFFFL || value < 0 ) out . write ( ( byte ) ( 0x80 | ( ( value >>> 42 ) & 0x7FL ) ) ) ; if ( value > 0x7FFFFFFFFL || value < 0 ) out . write ( ( byte ) ( 0x80 | ( ( value >>> 35 ) & 0x7FL ) ) ) ;
the value to the output stream .
the value from the byte array .
the int value from the InputStream .
( InputStream in ) throws IOException { byte b = ( byte ) in . read ( ) ; if ( b == ( byte ) 0x80 ) throw new RuntimeException ( " Attempting to read null value as long " ) ; long value = b & 0x7F ; while ( ( b & 0x80 ) != 0 ) { b = ( byte ) in . read ( ) ; value <<= 7 ; value |= ( b & 0x7F ) ; } return value ; }
addView ( View child , int index , ViewGroup . LayoutParams params ) { return addViewInternal ( child , index , params ) ; }
the maximum size of the loading view .
( ) { }
the data from the server .
overScrollBy ( final PullToRefreshBase < ? > view , final int deltaX , final int scrollX , final int deltaY , final int scrollY , final int scrollRange , final int fuzzyThreshold , final float scaleFactor , final boolean isTouchEvent ) { final int deltaValue , currentScrollValue ; switch ( view . getPullToRefreshScrollDirection ( ) ) { case HORIZONTAL : deltaValue = deltaX ; scrollValue = scrollX ; currentScrollValue = view . getScrollX ( ) ; break ; case VERTICAL : default : deltaValue = deltaY ; scrollValue = scrollY ; currentScrollValue = view . getScrollY ( ) ; break ; } if ( view . isPullToRefreshOverScrollEnabled ( ) && ! view . isRefreshing ( ) ) { final Mode mode = view . getMode ( ) ; if ( mode . permitsPullToRefresh ( ) && ! isTouchEvent && deltaValue != 0 ) { final int newScrollValue = ( deltaValue + scrollValue
< T , U > given ( String name , T value ) { return given ( new Fact < T > ( name , value ) ) ; }
< T , U > given ( NameValueReferable ... facts ) { _rule . addFacts ( facts ) ; return this ; }
a new RuleBuilder ( Class < ? extends Rule > ruleClass , RuleChainActionType actionType ) { return new RuleBuilder ( ruleClass , actionType ) ; }
a new RuleBuilder < Object , Object > .
< S , U > withFactType ( Class < S > factType ) { RuleBuilder < S , U > builder = new RuleBuilder < > ( _ruleClass ) ; builder . _factType = factType ; return builder ; }
a new RuleBuilder < T , S > .
< T , U > given ( String name , T value ) { Rule < T , U > rule = _name . map ( ruleName -> ( Rule < T , U > ) new AuditableRule < T , U > ( newRule ( ) , ruleName ) ) . orElse ( newRule ( ) ) ; if ( rule == null ) { throw new IllegalStateException ( " No Rule is instantiated ; An invalid Rule class may have been provided .
< T , U > given ( NameValueReferable ... facts ) { Rule < T , U > rule = _name . map ( name -> ( Rule < T , U > ) new AuditableRule < T , U > ( newRule ( ) , name ) ) . orElse ( newRule ( ) ) ; if ( rule == null ) { throw new IllegalStateException ( " No Rule is instantiated . " ) ; } return new GivenRuleBuilder < T , U > ( rule , facts ) ; }
a ThenRuleBuilder < T , U > .
a new instance of the rule .
( Class annotation , Class clazz ) { List < Field > fields = getAnnotatedFields ( annotation , clazz ) ; return Optional . ofNullable ( fields . size ( ) > 0 ? fields . get ( 0 ) : null ) ; }
the annotated method .
getAnnotation ( Class < A > annotation , Class < ? > clazz ) { return Optional . ofNullable ( clazz . getAnnotation ( annotation ) ) . orElse ( null ) ; }
a rule to the audit map .
the rule status .
< String , RuleStatus > getRuleStatusMap ( ) { _lock . readLock ( ) . lock ( ) ; try { return _auditMap . keySet ( ) . stream ( ) . collect ( Collectors . toMap ( key -> key , key -> _auditMap . get ( key ) . getOrDefault ( Thread . currentThread ( ) . getId ( ) , RuleStatus . PENDING ) ) ) ; } finally { _lock . readLock ( ) unlock ( ) ; } }
a new RuleBookWithResultTypeBuilder < U > .
a new rule for the given type .
< T , U > then ( BiConsumer < NameValueReferableTypeConvertibleMap < T > , Result < U > > action ) { _rule . addAction ( action ) ; return this ; }
the default value .
withFactType ( Class < T > factType ) { Rule < T , U > rule = ( Rule < T , U > ) RuleBuilder . create ( _ruleClass ) . withFactType ( factType ) . build ( ) ; _ruleBook . addRule ( rule ) ; return new RuleBookRuleWithFactTypeBuilder < > ( rule ) ; }
< Class < ? > > getPojoRules ( ) { Reflections reflections = new Reflections ( _package ) ; List < Class < ? > > rules = reflections . getTypesAnnotatedWith ( com . deliveredtechnologies . rulebook . annotation . Rule . class ) . stream ( ) . filter ( rule -> rule . getAnnotatedSuperclass ( ) != null ) . filter ( rule -> _subPkgMatch . test ( rule . getPackage ( ) . getName ( ) ) ) . collect ( Collectors . toList ( ) ) ; rules . sort ( comparingInt ( aClass -> getAnnotation ( com . deliveredtechnologies . rulebook . annotation . Rule . class , aClass ) . order ( ) ) ) ; return rules ; }
an empty line for end of row .
a list of services .
the ports from the image .
the ports from the config .
the port mapping specification .
the port to the list .
( List < ServicePort > ports ) { if ( ! ports . isEmpty ( ) ) { return ports . remove ( 0 ) ; } return null ; }
missing default ports to the specified service .
an image stream to the target .
true if the service port matches the given string .
the service port .
the hostname of the service .
a new Map < String , String > .
putIfAbsent ( Map < String , String > map , Map < String , String > toMerge ) { for ( Map . Entry < String , String > entry : toMerge . entrySet ( ) ) { putIfAbsent ( map , entry . getKey ( ) , entry . getValue ( ) ) ; } }
the two maps .
< String , String > putAllIfNotNull ( Map < String , String > ret , Map < String , String > toPut ) { if ( toPut != null ) { ret . putAll ( toPut ) ; } return ret ; }
for pod to be ready .
the given value .
< HasMetadata > toItemList ( Object entity ) throws IOException { if ( entity instanceof List ) { List < HasMetadata > list = ( List < HasMetadata > ) entity ; return list . getItems ( ) ; } else if ( entity instanceof HasMetadata [ ] ) { HasMetadata [ ] array = ( HasMetadata [ ] ) entity ; return Arrays . asList ( array ) ; } else if ( entity instanceof KubernetesList ) { KubernetesList config = ( KubernetesList ) entity ; return config . getItems ( ) ; } else if ( entity instanceof Template ) { Template objects = ( Template ) entity ; return objects . getObjects ( ) ; } else { List < HasMetadata > answer = new ArrayList < > ( ) ; if ( entity instanceof HasMetadata ) { answer . add ( ( HasMetadata ) entity ) ; } return answer ; } }
the resource version of the entity .
the status of the pod .
the current context .
a list of routes .
if a resource is found in the classpath .
a fragment from a file .
a list of env variables to a list of env variables .
deployments ( Deployment item1 , Deployment item2 , Logger log , boolean switchOnLocalCustomisation ) { if ( item1 instanceof Deployment && item2 instanceof Deployment ) { return mergeDeployments ( ( Deployment ) item1 , ( Deployment ) item2 , log , switchOnLocalCustomisation ) ; } return item1 ; }
and remove empty strings .
if PodSpec is a PodSpec .
configuration from a file .
a port to the map .
the docker json config string .
the plugin configuration for the given system .
a Map < String , Object > of the secret configuration .
a file from the given URL .
v1 and v2 to v1 and v2
Processsor Processsor Processsor configurations .
a list of profiles from the classpath .
the profile from the classpath .
a list of all profiles from the classpath .
the profileYaml file .
a list of all profile files .
a list of profiles from Yaml .
the image pull policy .
( ) { }
the number of replicas for the given resource .
the first child of the given element .
a Template from the given sourceName .
a tag from a list of tags .
a namespace to a given entity .
to the given project .
a ProjectRequest to a given namespace .
the namespace of the entity .
( String message , Exception e ) { log . error ( message , e ) ; throw new RuntimeException ( message ) ; }
a default namespace to the list .
a list of Kubernetes metadata .
the main class from the classpath .
the duration of the specified duration .
the durationNs of the given duration .
all files in the specified directory .
( ApplyService applyService ) { this . applyService = applyService ; }
a list of Ingress rules for a given service .
the mapping file .
the generator context .
generator config .
getEnricherContext ( ) { return new MavenEnricherContext . Builder ( ) . project ( project ) . properties ( project . getProperties ( ) ) . session ( session ) . config ( extractEnricherConfig ( ) ) . images ( getResolvedImages ( ) ) . resources ( resources ) . log ( log ) . build ( ) ; }
enricher config .
the name of the class loader .
app config files .
getPropertiesResource ( URL resource ) { if ( resource != null ) { try ( InputStream stream = resource . openStream ( ) ) { answer . load ( stream ) ; } catch ( IOException e ) { throw new IllegalStateException ( " Error while reading resource from URL " + resource , e ) ; } } return answer ; }
( ) { return Optional . ofNullable ( SpringBootConfigurationHelper . getSpringBootVersion ( ) ) ; }
a list of service objects .
the enricher .
a Map < String , String >
( Map < String , Object > source ) { buildFlattenedMap ( source , null ) ; return source ; }
watcher config .
a single template from a KubernetesList .
the timestamp from the given file .
the value of the given key .
the config for the given name .
a list of named processors for the given type .
an image stream tag to the builder .
the name of the mode .
the name of the generator .
the registry of the fabric8 generator .
whether the user is online or not .
the external service URL .
a Boolean .
a JestClient .
a new ES node .
the plugins from the classpath .
a new AmericanExpressRewardsBalance object .
the rewards balance .
fromJson ( String jsonString ) throws JSONException { PayPalPaymentResource payPalPaymentResource = new PayPalPaymentResource ( ) ; JSONObject redirectJson = json . optJSONObject ( PAYMENT_RESOURCE_KEY ) ; if ( redirectJson != null ) { payPalPaymentResource . redirectUrl ( Json . optString ( redirectJson , REDIRECT_URL_KEY , " " ) ) ; } return payPalPaymentResource ; }
the given path .
a request to the server .
fromJson ( JSONObject json ) { if ( json == null ) { json = new JSONObject ( ) ; } return new VenmoConfiguration ( json ) ; }
the device data .
the device data .
( final BraintreeFragment fragment ) { }
the client metadata id .
if a signature is valid .
optString ( JSONObject json ) { if ( json . isNull ( name ) ) { return fallback ; } else { return json . optString ( name , fallback ) ; } }
( String jsonBody ) throws JSONException { JSONArray paymentMethods = new JSONObject ( jsonBody ) . getJSONArray ( PAYMENT_METHOD_NONCE_COLLECTION_KEY ) ; if ( paymentMethods == null || paymentMethods . length ( ) == 0 ) { return Collections . emptyList ( ) ; } List < PaymentMethodNonce > paymentMethodsNonces = new ArrayList < > ( ) ; JSONObject json ; PaymentMethodNonce paymentMethodNonce ; for ( int i = 0 ; i < paymentMethods . length ( ) ; i ++ ) { json = paymentMethods . getJSONObject ( i ) ; paymentMethodNonce = parsePaymentMethodNonces ( json , json . getString ( PAYMENT_METHOD_TYPE_KEY ) ) ; if ( paymentMethodNonce != null ) { paymentMethodsNonces . add ( paymentMethodNonce ) ; } } return paymentMethodsNonces ; }
getBrowserCheckoutConfig ( ) { for ( CheckoutRecipe recipe : mCheckoutRecipesInDecreasingPriorityOrder ) { if ( recipe . getTarget ( ) == RequestTarget . browser ) { return recipe ; } } return null ; }
getBrowserBillingAgreementConfig ( ) { for ( BillingAgreementRecipe recipe : mBillingAgreementRecipesInDecreasingPriorityOrder ) { if ( recipe . getTarget ( ) == RequestTarget . browser ) { return recipe ; } } return null ; }
the url of the given path .
a request to the given path .
a post request to the given path .
a payment .
a local payment .
for BraintreeListener .
the BraintreeListener .
the Billing Agreement flow .
a response from PayPalOneTouch .
parseResponse ( PayPalRequest paypalRequest , Request request , Result result , Intent intent ) { PayPalAccountBuilder paypalAccountBuilder = new PayPalAccountBuilder ( ) . clientMetadataId ( request . getClientMetadataId ( ) ) ; if ( paypalRequest != null && paypalRequest . getMerchantAccountId ( ) != null ) { paypalAccountBuilder . merchantAccountId ( paypalRequest . getMerchantAccountId ( ) ) ; } if ( paypalRequest != null && paypalRequest . getIntent ( ) != null ) { paypalAccountBuilder . intent ( paypalRequest . getIntent ( ) ) ; } return paypalAccountBuilder ; }
Nouns to Dictionary .
words from dictionary .
a list of tokens to a Java string .
the Korean phrases .
( List < String > tokens ) { return OpenKoreanTextProcessor . detokenize ( tokens ) ; }
the bytes from the given channel .
the nal units .
to buffer .
the profile for an int .
( double [ ] taps , int precBits ) { double [ ] out = new double [ taps . length ] ; for ( int i = 0 ; i < taps . length ; i ++ ) { out [ i ] = ( short ) ( taps [ i ] * precBits ) ; sum += out [ i ] ; } return out ; }
the next marker from the channel .
to next marker buffer .
the max available frame .
the file .
the contents of the file to the destination .
the duration of the current track .
the time value of the given frame .
the frame of a time to sample .
the mediaTv from the trak box .
editedTv to movieTimescale .
the qt player frame no .
the current time of the video .
the time value to a timecode frame .
( TrakBox timecodeTrack , int counter ) { TimecodeSampleEntry tmcd = NodeBox . findFirstPath ( timecodeTrack , TimecodeSampleEntry . class , Box . path ( " mdia . minf . stbl . stsd . tmcd " ) ) ; String tc = String . format ( " % 02d " , counter % nf ) ; counter /= nf ; tc = String . format ( " % 02d " , counter % 60 ) + " : " + tc ; counter /= 60 ; tc = String . format ( " % 02d " , counter % 60 ) + " : " + tc ; counter /= 60 ; tc = String . format ( " % 02d " , counter % 60 ) + " : " + tc ; return tc ; }
the integer value of the given value .
the value of the list .
the color of the input color .
the size of the specified component .
a raw MP4Demuxer .
the contents of the buffer .
a WavHeader .
multiChannelWav ( WavHeader [ ] headers ) { WavHeader w = emptyWavHeader ( ) ; int totalSize = 0 ; for ( int i = 0 ; i < headers . length ; i ++ ) { WavHeader wavHeader = headers [ i ] ; totalSize += wavHeader . dataSize ; } return w ; }
parseMP4DecoderSpecificInfo ( byte [ ] data ) throws AACException { final IBitStream _in = BitStream . createBitStream ( data ) ; final AACDecoderConfig config = new AACDecoderConfig ( ) ; try { config . profile = readProfile ( _in ) ; int sf = _in . readBits ( 4 ) ; if ( sf == 0xF ) config . sampleFrequency = SampleFrequency . forFrequency ( _in . readBits ( 24 ) ) ; else config . sampleFrequency = SampleFrequency . forInt ( sf ) ; config . channelConfiguration = ChannelConfiguration . forInt ( _in . readBits ( 4 ) ) ; Profile cp = config . profile ; if ( AAC_SBR == cp ) { config . extProfile = cp ; config . sbrPresent = true ; sf = _in . readBits ( 4 ) ; config . downSampledSBR = config . sampleFrequency .
the range of the symbol .
( ) { return null ; }
the track and movie .
the frame .
the bigEndian flag to true .
( EncodedMB cur , EncodedMB left , EncodedMB top ) { int [ ] [ ] vertStrength = new int [ 4 ] [ 4 ] ; int [ ] [ ] horizStrength = new int [ 4 ] [ 4 ] ; calcStrengthForBlocks ( cur , left , vertStrength , LOOKUP_IDX_P_V , LOOKUP_IDX_Q_V ) ; calcStrengthForBlocks ( cur , top , horizStrength , LOOKUP_IDX_P_H , LOOKUP_IDX_Q_H ) ; deblockMBGeneric ( cur , left , top , vertStrength , horizStrength ) ; }
( Picture pic ) throws IOException { if ( pic . getColor ( ) != ColorSpace . RGB ) throw new IllegalArgumentException ( " The input images is expected in RGB color . " ) ; if ( pic . getColor ( ) != ColorSpace . RGB ) throw new IllegalArgumentException ( " The input images is expected in RGB color . " ) ; LoanerPicture toEncode ; if ( sinkColor != null ) { toEncode = pixelStore . getPicture ( pic . getWidth ( ) , pic . getHeight ( ) , sinkColor ) ; transform . transform ( pic , toEncode . getPicture ( ) ) ; } else { toEncode = new LoanerPicture ( pic , 0 ) ; } pkt = Packet . createPacket ( null , timestamp , fps . getNum ( ) , fps . getDen ( ) , frameNo , FrameType . KEY , null ) ; sink . outputVideoFrame ( new VideoFrameWithPacket ( pkt , toEncode ) ) ;
a long value to a byte array .
the ebml length .
a new FLVPacket to the stream .
the file .
( int m , int range ) { if ( range < 0 ) range = 0 ; if ( range < 0 ) range = 0 ; if ( range < 0 ) range = 0 ; if ( range < 0 ) range = 0 ; if ( range < 0 ) range = 0 ; if ( range < 0 ) range = 0 ; if ( range < 0 ) range = 0 ; if ( range < 0 ) range = 0 ; if ( range < 0 ) range = 0 ; if ( range < 0 ) range = 0 ; if ( range < 0 ) range = 0 ; if ( range < 0 ) range = 0 ; if ( range < 0 ) range = 0 ; if ( range < 0 ) range = 0 ; if ( range < 0 ) range = 0 ; if ( range < 0 ) range = 0 ; if ( range < 0 ) range = 0 ; if ( range < 0 ) range = 0 ; if ( range < 0 ) range = 0
( int code , int range ) { if ( range < 0 ) throw new IllegalArgumentException ( ) ; if ( range == 0 ) throw new IllegalArgumentException ( ) ; int tmp = code - ( range << 8 ) ; if ( tmp < 0 ) { return 0 ; } else { code = tmp ; return 1 ; } }
a marker .
forInt ( int i ) { if ( i >= 0 ) freq = values ( ) [ i ] ; else freq = SAMPLE_FREQUENCY_NONE ; return freq ; }
the plane .
the block .
the coefficients of the block .
the block .
the bits of the given buffer .
( int v ) { v = ( v >> S [ 0 ] ) & B [ 0 ] ; v = ( ( v << S [ 0 ] ) & ~ B [ 0 ] ) ; v = ( ( v >> S [ 1 ] ) & B [ 1 ] ) | ( ( v << S [ 1 ] ) & ~ B [ 1 ] ) ; v = ( ( v >> S [ 2 ] ) & B [ 2 ] ) | ( ( v << S [ 2 ] ) & ~ B [ 2 ] ) ; v = ( ( v >> S [ 3 ] ) & B [ 3 ] ) | ( ( v << S [ 3 ] ) & ~ B [ 3 ] ) ; v = ( ( v >> S [ 4 ] ) & B [ 4 ] ) | ( ( v << S [ 4 ] ) & ~ B [ 4 ] ) ; v >>= ( 32 - len ) ; return v ; }
( int lo , int hi ) { int [ ] i = new int [ 2 ] ; if ( len <= 32 ) { i [ 0 ] = lo ; i [ 1 ] = hi ; i [ 2 ] = lo ; i [ 3 ] = hi ; i [ 4 ] = lo ; i [ 5 ] = hi ; i [ 6 ] = lo ; i [ 7 ] = hi ; return i ; }
to key frame .
the pixel buffer from the video codec .
( int lngain ) { for ( int i = 0 ; i < ID_GAIN ; i ++ ) { if ( lngain == LN_GAIN [ i ] ) return i ; } return 0 ; }
a byte array to an int array .
a byte array to a byte array .
floats to PCM .
floats to PCM .
the AudioFormat .
( AudioFormat format , ByteBuffer inb , ByteBuffer [ ] outs ) { int bytesPerSample = format . getSampleSizeInBits ( ) >> 3 ; int bytesPerFrame = bytesPerSample * outs . length ; while ( inb . remaining ( ) >= bytesPerFrame ) { for ( int j = 0 ; j < outs . length ; j ++ ) { for ( int i = 0 ; i < bytesPerSample ; i ++ ) { outs [ j ] . put ( inb . get ( ) ) ; } } } }
the size of the video track .
a bounding box out map .
a WipeMap from the given image .
( ByteBuffer _bb ) { int count = _bb . getInt ( ) ; UL [ ] result = new UL [ count ] ; for ( int i = 0 ; i < count ; i ++ ) { result [ i ] = UL . read ( _bb ) ; } return result ; }
( ByteBuffer _bb ) { int count = _bb . getInt ( ) ; _bb . getInt ( ) ; int [ ] result = new int [ count ] ; for ( int i = 0 ; i < count ; i ++ ) { result [ i ] = _bb . getInt ( ) ; } return result ; }
( int a , int b , int c , int d , boolean aAvb , boolean bAvb , boolean cAvb , boolean dAvb , int ref , int comp ) { if ( aAvb && ! bAvb && ! cAvb ) { a = b ; bAvb = cAvb ; } if ( bAvb && ! cAvb && ! dAvb ) { c = d ; dAvb = dAvb ; } if ( aAvb && ! bAvb && ! cAvb ) { b = c = a ; bAvb = aAvb ; } if ( bAvb && ! cAvb && ! dAvb ) { c = d ; dAvb = dAvb ; } if ( aAvb && bAvb && cAvb ) return mvC ( a , comp ) + mvC ( b , comp )
encodeFrame ( Picture pic , ByteBuffer _out ) { int frameNumber = 0 ; if ( pic . getColor ( ) != ColorSpace . YUV420J ) throw new IllegalArgumentException ( " Input picture color is not supported : " + pic . getColor ( ) ) ; if ( frameNumber >= keyInterval ) { frameNumber = 0 ; } SliceType sliceType = frameNumber == 0 ? SliceType . I : SliceType . P ; ByteBuffer data = doEncodeFrame ( pic , _out , idr , frameNumber ++ , sliceType ) ; return new EncodedFrame ( data ) ; }
( Picture pic , ByteBuffer _out ) { frameNumber = 0 ; return doEncodeFrame ( pic , _out , true , frameNumber , SliceType . I ) ; }
( Picture pic , ByteBuffer _out ) { frameNumber ++ ; return doEncodeFrame ( pic , _out , true , frameNumber ) ; }
the supported codecs .
supported tags .
a reference to a JNIReference .
a JNIReference .
all references .
a JNILibrary .
the library .
temporary files .
the default layout of the AudioChannel .
( int index ) { return AudioChannel . Type . swigToEnum ( VideoJNI . AudioChannel_getChannelFromLayoutAtIndex ( index ) ) ; }
MediaPacket ( ) { return new MediaPacket ( ) ; }
the version info of the given class .
( ) { long cPtr = VideoJNI . Global_getDefaultTimeBase ( ) ; return ( cPtr == 0 ) ? null : new Rational ( cPtr , false ) ; }
make ( ) { long cPtr = VideoJNI . Demuxer_make ( ) ; return ( cPtr == 0 ) ? null : new Demuxer ( cPtr , false ) ; }
a video stream .
the video at the specified time .
a new CodecDescriptor .
the help for the given property .
a factory .
a unique name .
a MediaAudioResampler .
the supported video frame rates .
the supported video pixel formats .
the supported audio sample rates .
the supported audio formats .
. Layout getSupportedAudioChannelLayouts ( ) { return getSupportedAudioChannelLayouts ( ) ; }
( Coder . Flag flag , boolean value ) { if ( value ) { setFlag ( flag ) ; } else { setFlag ( flag ) ; } }
( Coder . Flag2 flag , boolean value ) { VideoJNI . Coder_setFlag2 ( swigCPtr , this , flag . swigValue ( ) , value ) ; }
( ) { return new Decoder ( cPtr , false ) ; }
( ) { long cPtr = VideoJNI . DemuxerStream_getDemuxer ( ) ; return ( cPtr == 0 ) ? null : new Demuxer ( cPtr , false ) ; }
a list of formats .
new FilterGraph ( ) { return new FilterGraph ( ) ; }
( ) { return ( cPtr == 0 ) ? null : new BitStreamFilterType ( cPtr , false ) ; }
( int offset , int length ) { return getByteBuffer ( offset , length , null ) ; }
a new AudioFrame .
a MediaPicture .
the passed image .
a picture .
( ) { return new FilterGraph ( cPtr , false ) ; }
( ) { long cPtr = VideoJNI . MediaRaw_getMetaData ( swigCPtr , this ) ; return ( cPtr == 0 ) ? null : new KeyValueBag ( cPtr ) ; }
the CPUArch .
the CPUArch from the gnu string .
( String osName ) { final OSFamily retval ; if ( osName != null && osName . length ( ) > 0 ) { if ( osName . startsWith ( " Windows " ) ) retval = OSFamily . WINDOWS ; else if ( osName . startsWith ( " Mac " ) ) retval = OSFamily . MAC ; else if ( osName . startsWith ( " Linux " ) ) retval = OSFamily . LINUX ; else retval = OSFamily . UNKNOWN ; } else retval = OSFamily . UNKNOWN ; return retval ; }
the OSFamily from the given gnu string .
the audio stream .
the specified library .
the loaded library version .
( String aLibraryName , Long aMajorVersion ) { return loadCandidateLibrary ( aLibraryName , aMajorVersion ) ; }
search paths .
the specified version of the library .
a screen .
( ) { final long swigPtr = mSwigCPtr . getAndSet ( 0 ) ; if ( swigPtr != 0 ) { if ( mJavaRefCount . decrementAndGet ( ) == 0 ) { FerryJNI . RefCounted_release ( swigPtr , null ) ; } mMemAllocator = null ; } }
( int position ) throws IOException { long cPtr = VideoJNI . Muxer_getStream ( swigCPtr , this , position ) ; return ( cPtr == 0 ) ? null : new MuxerStream ( cPtr ) ; }
( long cPtr ) { return new Muxer ( cPtr , false ) ; }
makeScriptTx ( PrivateKeyAccount sender , String script , byte chainId , long fee , long timestamp ) { return new SetScriptTransaction ( sender , script , chainId , fee , timestamp ) ; }
a base58 string into a byte array .
a random seed .
the transaction info .
( String address , int limit ) throws IOException { return getAddressTransactions ( address , limit , null ) ; }
the list of address transactions .
a list of blocks headers .
the signature to a block .
a transaction .
a script to a PrivateKeyAccount .
a compiled script .
( Object array , int off , int len ) throws IOException { Class < ? > componentType = array . getClass ( ) . getComponentType ( ) ; if ( componentType == byte . class ) { writeFByteArr ( ( byte [ ] ) array , off , len ) ; } else if ( componentType == char . class ) { writeFCharArr ( ( char [ ] ) array , off , len ) ; } else if ( componentType == short . class ) { writeFShortArr ( ( short [ ] ) array , off , len ) ; } else if ( componentType == int . class ) { writeFIntArr ( ( int [ ] ) array , off , len ) ; } else if ( componentType == long . class ) { writeFLongArr ( ( long [ ] ) array , off , len ) ; } else if ( componentType == float . class ) { writeFFloatArr ( ( float [ ] ) array , off , len ) ;
the output stream .
the size of the object .
the FSTClazzInfo .
the object to a byte array .
( File file , FileChannel fileChannel , Cleaner cleaner ) { this . file = file ; this . fileChannel = fileChannel ; this . cleaner = cleaner ; }
the specificity of a given class .
the store .
the key from the index .
writeStringAsc ( String name ) throws IOException { int len = name . length ( ) ; if ( len >= 127 ) { throw new RuntimeException ( " Ascii String too long " ) ; } writeFByte ( ( byte ) len ) ; buffout . ensureFree ( len ) ; if ( ascStringCache == null || ascStringCache . length < len ) ascStringCache = new byte [ len ] ; name . getBytes ( 0 , len , ascStringCache , 0 ) ; return ascStringCache ; }
the output stream to the specified FSTOutputStream .
a new FSTConfiguration .
a new FSTConfiguration .
the size of the object .
the cached objects .
getObjectInput ( ) { FSTObjectInput fstObjectInput = getIn ( ) ; try { fstObjectInput . resetForReuse ( ) ; return fstObjectInput ; } catch ( IOException e ) { FSTUtil . < RuntimeException > rethrow ( e ) ; } return null ; }
getObjectInput ( byte arr [ ] , int len ) { FSTObjectInput fstObjectInput = getIn ( ) ; try { fstObjectInput . resetForReuseUseArray ( arr , len ) ; return fstObjectInput ; } catch ( IOException e ) { FSTUtil . rethrow ( e ) ; } return null ; }
( byte arr [ ] ) { FSTObjectInput fstObjectInput = getIn ( ) ; try { fstObjectInput . resetForReuseCopyArray ( arr , off , len ) ; return fstObjectInput ; } catch ( IOException e ) { FSTUtil . < RuntimeException > rethrow ( e ) ; } return null ; }
getObjectOutput ( ) { FSTObjectOutput fstObjectOutput = getOut ( ) ; fstObjectOutput . resetForReUse ( out ) ; return fstObjectOutput ; }
a cross platform class mapping .
the name of the class .
( byte type , long data ) { if ( ! MinBin . isPrimitive ( type ) || MinBin . isArray ( type ) ) throw new RuntimeException ( " illegal type code " ) ; writeOut ( type ) ; writeRawInt ( type , data ) ; }
( byte type , long data ) { writeOut ( type ) ; writeOut ( ( byte ) ( data & 0xff ) ) ; writeOut ( ( byte ) ( data & 0xff ) ) ; writeOut ( ( byte ) ( data & 0xff ) ) ; writeOut ( ( byte ) ( data & 0xff ) ) ; writeOut ( ( byte ) ( data & 0xff ) ) ; writeOut ( ( byte ) ( data & 0xff ) ) ; writeOut ( ( byte ) ( data & 0xff ) ) ; writeOut ( ( byte ) ( data & 0xff ) ) ; writeOut ( ( byte ) ( data & 0xff ) ) ; writeOut ( ( byte ) ( data & 0xff ) ) ; }
void writeIntPacked ( int data ) { if ( data <= Byte . MAX_VALUE && data >= Byte . MIN_VALUE ) writeInt ( MinBin . INT_8 , data ) ; else if ( data <= Short . MAX_VALUE && data >= Short . MIN_VALUE ) writeInt ( MinBin . INT_16 , data ) ; else if ( data <= Integer . MAX_VALUE && data >= Integer . MIN_VALUE ) writeInt ( MinBin . INT_32 , data ) ; else if ( data <= Long . MAX_VALUE && data >= Long . MIN_VALUE ) writeInt ( MinBin . INT_64 , data ) ; else if ( data <= Long . MAX_VALUE && data >= Long . MIN_VALUE ) writeInt ( MinBin . INT_32 , data ) ; else if ( data <= Long . MAX_VALUE && data >= Long . MIN_VALUE ) writeInt ( MinBin . INT_64 , data ) ; }
a primitive array .
a byte [ ] to the stream .
. FSTFieldInfo getCachedFI ( Class ... possibles ) { if ( refs == null ) { refs = new FSTClazzInfo . FSTFieldInfo [ ] { new FSTClazzInfo . FSTFieldInfo ( possibles , null , true ) , new FSTClazzInfo . FSTFieldInfo ( possibles , null , true ) , new FSTClazzInfo . FSTFieldInfo ( possibles , null , true ) } return new FSTClazzInfo . FSTFieldInfo ( possibles , null , true ) ; }
whether the object will be written to the stream .
if an object has been written .
getFstClazzInfo ( FSTClazzInfo . FSTFieldInfo referencee , Configuration conf ) { FSTClazzInfo serializationInfo = null ; FSTClazzInfo lastInfo = referencee . lastInfo ; if ( lastInfo != null && lastInfo . getClazz ( ) == clazz && lastInfo . conf == conf ) { serializationInfo = lastInfo ; } else { serializationInfo = getClassInfoRegistry ( ) . getCLInfo ( clazz , conf ) ; referencee . lastInfo = serializationInfo ; } return serializationInfo ; }
( FSTClazzInfo . FSTFieldInfo referencee , Object array ) throws IOException { if ( array == null ) { getCodec ( ) . writeClass ( Object . class ) ; getCodec ( ) . writeFInt ( - 1 ) ; return ; } final int len = Array . getLength ( array ) ; Class < ? > componentType = array . getClass ( ) . getComponentType ( ) ; getCodec ( ) . writeClass ( array . getClass ( ) ) ; getCodec ( ) . writeFInt ( len ) ; if ( ! componentType . isArray ( ) ) { if ( getCodec ( ) . isPrimitiveArray ( array , componentType ) ) { getCodec ( ) . writePrimitiveArray ( array , 0 , len ) ; } else { writeObjectWithContext ( referencee , array , null ) ; } } }
the length of the string .
( Object array , int start , int length ) throws IOException { if ( array . getClass ( ) . isArray ( ) ) { writePrimitiveArray ( array , start , length ) ; } else { writePrimitiveArray ( array , start , length ) ; } }
the change tracking .
the snapshot of the origin .
( Object o , int streamPosition , FSTClazzInfo clzInfo , int reUseType [ ] ) { if ( disabled ) { return Integer . MIN_VALUE ; } if ( clzInfo == null ) { } else if ( clzInfo . isFlat ( ) ) { return Integer . MIN_VALUE ; } int handle = objects . putOrGet ( o , streamPosition ) ; if ( handle >= 0 ) { reUseType [ 0 ] = handle ; return handle ; } return Integer . MIN_VALUE ; }
an object to a byte array .
a byte array to an object .
a byte array .
the first 4 bytes from the file .
( int pollIndex ) { if ( pollIndex >= len ) pollIndex -= len ; else pollIndex = pollIndex + len ; }
the threadPoolEnabled property to true .
Cassandra daemon .
Cassandra data .
a file to a directory .
thread information .
the remote port of the given node .
an empty SubscriberState .
< String , OpDescriptor > onnxOpDescriptors ( ) throws Exception { try ( InputStream is = new ClassPathResource ( " onnxops . json " ) . getInputStream ( ) ) { ObjectMapper objectMapper = new ObjectMapper ( ) ; OnnxDescriptor opDescriptor = objectMapper . readValue ( is , OnnxDescriptor . class ) ; Map < String , OpDescriptor > descriptorMap = new HashMap < > ( ) ; for ( OpDescriptor descriptor : opDescriptor . getDescriptors ( ) ) { descriptorMap . put ( descriptor . getName ( ) , descriptor ) ; } return descriptorMap ; } }
output shape .
or ( IComplexNDArray n , Condition cond ) { boolean ret = false ; IComplexNDArray linear = n . linearView ( ) ; for ( int i = 0 ; i < linear . length ( ) ; i ++ ) { ret = ret || cond . apply ( linear . getComplex ( i ) ) ; } return ret ; }
true if the condition is satisfied .
whether a condition is true or false .
true or false for the given condition .
a condition to a INDArray .
the first index of the array .
asFlatProperties ( FlatBufferBuilder bufferBuilder ) { int i = FlatProperties . createIVector ( bufferBuilder , Ints . toArray ( i ) ) ; int l = FlatProperties . createLVector ( bufferBuilder , Longs . toArray ( l ) ) ; int d = FlatProperties . createDVector ( bufferBuilder , Doubles . toArray ( d ) ) ; return FlatProperties . createFlatProperties ( bufferBuilder , iname , ii , il , id , d ) ; }
fromFlatProperties ( FlatProperties properties ) { for ( int e = 0 ; e < properties . iLength ( ) ; e ++ ) props . getI ( ) . add ( properties . i ( e ) ) ; }
a list of properties .
the cause of the exception .
( Throwable t ) { try { lock . writeLock ( ) . lock ( ) ; if ( this . t == null ) this . t = t ; } finally { lock . writeLock ( ) . unlock ( ) ; } }
coords .
a List of List < Double > .
DataBuffer . Type of the given type .
the transport .
the current device architecture .
col2im ( INDArray col , int sy , int sx , int ph , int pw , int h , int w ) { if ( col . rank ( ) != 6 ) throw new IllegalArgumentException ( " col2im input array must be rank 6" ) ; INDArray output = Nd4j . create ( new long [ ] { col . size ( 0 ) , col . size ( 1 ) , h , w } ) ; Nd4j . getExecutioner ( ) . exec ( output ) ; return output ; }
pooling2D ( INDArray img , int kh , int kw , int ph , int pw , int dh , int dw , boolean isSameMode , Pooling2D . Pooling2DType type , Pooling2D . Divisor divisor ) { return pooling2D ( img , kh , kw , ph , pw , dh , dw , isSameMode ) ; }
a CompressionDescriptor from a ByteBuffer .
the list into batches .
Concatenated arrays .
the dtype of the operation .
the linspace of the given number .
matrices .
a bilinear product of the input tensor .
a complex ndarray .
complexValueOf ( int num ) { IComplexNDArray ones = complexOnes ( num ) ; ones . assign ( Nd4j . createDouble ( value , 0.0 ) ) ; return ones ; }
the complex value of a given shape .
the last synced time .
( IComplexNumber c , IComplexNumber result ) { if ( c . realComponent ( ) . doubleValue ( ) < result . realComponent ( ) . doubleValue ( ) ) { result . set ( result . realComponent ( ) . doubleValue ( ) - c . realComponent ( ) . doubleValue ( ) , result . imaginaryComponent ( ) . doubleValue ( ) - c . imaginaryComponent ( ) . doubleValue ( ) ) ; } return result ; }
( IComplexNumber num ) { Complex c = new Complex ( num . realComponent ( ) . doubleValue ( ) , num . imaginaryComponent ( ) . doubleValue ( ) ) ; return Nd4j . createDouble ( c . getReal ( ) , c . getImaginary ( ) ) ; }
( IComplexNumber num ) { Complex c = new Complex ( FastMath . ceil ( num . realComponent ( ) . doubleValue ( ) ) , FastMath . ceil ( num . imaginaryComponent ( ) . doubleValue ( ) ) ) ; return Nd4j . createDouble ( c . getReal ( ) , c . getImaginary ( ) ) ; }
negatives of a complex number .
the abs of a complex number .
( IComplexNumber num , IComplexNumber power ) { Complex c = new Complex ( num . realComponent ( ) . doubleValue ( ) , num . imaginaryComponent ( ) . doubleValue ( ) ) . pow ( new Complex ( power . realComponent ( ) . doubleValue ( ) , power . imaginaryComponent ( ) . doubleValue ( ) ) ) ; if ( c . isNaN ( ) ) c = new Complex ( num . realComponent ( ) . doubleValue ( ) , num . imaginaryComponent ( ) . doubleValue ( ) ) . pow ( new Complex ( power . realComponent ( ) . doubleValue ( ) , power . imaginaryComponent ( ) . doubleValue ( ) ) ) ; return c ; }
getContext ( ) { Aeron . Context ctx = new Aeron . Context ( ) . publicationConnectionTimeout ( - 1 ) . availableImageHandler ( AeronUtil :: printAvailableImage ) . unavailableImageHandler ( AeronUtil :: printUnavailableImage ) . aeronDirectoryName ( mediaDriverDirectoryName ) . keepAliveInterval ( 100000 ) . errorHandler ( e -> log . error ( e . toString ( ) , e ) ) ; return ctx ; }
the feature matrix .
a dataset from a given number of samples .
the memory footprint of the given feature .
the exception details .
the hostname of the given hostname .
the array to a string .
a byte array to a hex string .
the values of the given string .
the given string .
the given string .
the next character in the string .
HTML characters .
a string with a separator .
a string to a camelized string .
tokens in the template .
the stackTrace of the Thread .
the inverse of an array .
a new BigInteger to the given array .
if the device is on the host side .
whether the device is on the given host .
shape information .
shape information .
static boolean isVector ( DataBuffer shapeInfo ) { int rank = Shape . rank ( shapeInfo ) ; if ( rank > 2 || rank < 1 ) return false ; else { int len = Shape . length ( shapeInfo ) ; DataBuffer shape = Shape . shapeOf ( shapeInfo ) ; return shape . getInt ( 0 ) == len || shape . getInt ( 1 ) == len ; } }
( INDArray arr ) { return getOrder ( arr . shape ( ) ) ; }
the offset for the given shape .
a INDArrayIndex [ ] of the given indices .
getShort ( long i ) { if ( dataType ( ) != Type . HALF ) throw new UnsupportedOperationException ( " getShort ( ) is supported for Half - precision buffers only " ) ; return fromFloat ( ( ( HalfIndexer ) indexer ) . get ( offset ( ) + i ) ) ; }
a new DataBuffer .
the data from the given buffer to the given buffer .
the buffer for the given array .
the kafka broker URI .
pow ( INDArray ndArray , INDArray power ) { INDArray result = ( dup ? Nd4j . create ( ndArray . shape ( ) , ndArray . ordering ( ) ) : ndArray ) ; return exec ( new Pow ( ndArray , power , result , ndArray . length ( ) , 0 ) ) ; }
log ( INDArray ndArray , double base ) { return Nd4j . getExecutioner ( ) . exec ( new LogX ( duplicate ? ndArray . dup ( ndArray . ordering ( ) ) : ndArray , base ) ) . z ( ) ; }
max ( INDArray ndArray , double k , boolean dup ) { return ndArray . max ( k , dup ) ; }
max ( INDArray first , INDArray second , boolean dup ) { if ( dup ) { first = first . dup ( ) ; } return exec ( new OldMax ( second , first , first . length ( ) ) ) ; }
the minimum of the given array .
the min of the first and the second .
( INDArray ndArray , double k ) { return exec ( dup ? new Stabilize ( ndArray , ndArray . dup ( ) , k ) : new Stabilize ( ndArray , k ) ) ; }
expm1 ( INDArray ndArray ) { return exec ( dup ? new Expm1 ( ndArray . dup ( ) ) : new Expm1 ( ndArray ) ) ; }
log1p ( INDArray ndArray ) { return exec ( dup ? new Log1p ( ndArray , ndArray . dup ( ) ) : new Log1p ( ndArray ) ) ; }
( INDArray bounds ) { return new INDArray [ ] { Nd4j . valueArrayOf ( x . shape ( ) , bounds . getDouble ( 0 ) ) , Nd4j . valueArrayOf ( bounds . getDouble ( 1 ) ) } ; }
( INDArray x , INDArray h , int numSteps , INDArray lowerBound , INDArray upperBound ) { INDArray oneSided = Nd4j . onesLike ( h ) ; if ( and ( lowerBound . eq ( Double . NEGATIVE_INFINITY ) , upperBound . eq ( Double . POSITIVE_INFINITY ) ) . sumNumber ( ) . doubleValue ( ) > 0 ) { return new INDArray [ ] { hAdjusted , oneSided } ; } if ( and ( lowerBound . eq ( Double . NEGATIVE_INFINITY ) , upperBound . eq ( Double . POSITIVE_INFINITY ) ) . sumNumber ( ) . doubleValue ( ) > 0 ) { return new INDArray [ ] { hAdjusted , oneSided } ; } if ( and ( lowerBound . eq ( Double . POSITIVE_INFINITY ) , upperBound . eq ( Double . NEGATIVE_INFINITY ) ) . sumNumber ( ) . doubleValue ( ) > 0 ) { return new INDArray [ ] { hAdjusted , oneSided
the next dataset .
sgeqrf ( int M , int N , INDArray A , INDArray R , INDArray INFO ) { INDArray tau = Nd4j . create ( N ) ; int status = LAPACKE_sgeqrf ( getColumnOrder ( A ) , M , N , ( FloatPointer ) A . data ( ) . addressPointer ( ) , getLda ( A ) , ( FloatPointer ) tau . data ( ) . addressPointer ( ) ) ; if ( status != 0 ) { throw new BlasException ( " Failed to execute sgeqrf " , status ) ; } }
a new AllocationShape from the buffer .
the name of the current directory .
the data .
the tail of the device .
a Nd4j DataBuffer from a NpyPointer .
a new numpy from a given file .
PagedPointer alloc ( long requiredMemory , MemoryKind kind , DataBuffer . Type dataType , boolean initialize ) { return alloc ( requiredMemory , kind , dataType , initialize ) ; }
( Object object ) { if ( ! objectLocks . containsKey ( object ) ) objectLocks . put ( object , new ReentrantReadWriteLock ( ) ) ; return objectLocks . get ( object ) ; }
the server .
the given operation .
( ) { flushQueue ( ) ; }
the InputStream of the given URL .
the device for the given threadId .
a thread to the specified device .
a single device to a single device .
the name of the operating system .
the arch type of the platform .
a message to the destination .
the server .
a new DataBuffer .
INT data .
a complex number to the result .
the value to the array .
( SDVariable [ ] inputs , Pooling3DConfig pooling3DConfig ) { Pooling3D maxPooling3D = Pooling3D . builder ( ) . inputs ( inputs ) . sameDiff ( sameDiff ( ) ) . pooling3DConfig ( pooling3DConfig ) . build ( ) ; return maxPooling3D ; }
depthWiseConv2d ( SDVariable [ ] inputs , Conv2DConfig depthConv2DConfig ) { SConv2D depthWiseConv2D = SConv2D . sBuilder ( ) . inputFunctions ( inputs ) . sameDiff ( sameDiff ( ) ) . conv2DConfig ( depthConv2DConfig ) . build ( ) ; return depthWiseConv2D ; }
the counters .
the op class .
a new array .
the shape of a given variable .
the same diff .
( double [ ] data , int [ ] shape , char order ) { DoublePointer pointer = new DoublePointer ( data ) ; DataBuffer shapeInfo = Nd4j . getShapeInfoProvider ( ) . createShapeInformation ( shape , order ) . getFirst ( ) ; DataBuffer buffer = compressPointer ( DataBuffer . TypeEx . DOUBLE , pointer , data . length , 8 ) ; return Nd4j . createArrayFromBuffer ( buffer , shapeInfo ) ; }
a complex array .
an IComplexNDArray .
( IComplexNDArray nd , int dimension ) { if ( nd . isVector ( ) ) nd . putScalar ( dimension , nd . getComplex ( dimension ) ) ; else nd . putScalar ( dimension , nd . getComplex ( dimension ) ) ; return nd ; }
( IComplexNDArray nd , long [ ] targetShape ) { if ( Arrays . equals ( nd . shape ( ) , targetShape ) ) return nd ; if ( ArrayUtil . prod ( nd . shape ( ) ) >= ArrayUtil . prod ( targetShape ) ) return nd ; IComplexNDArray ret = Nd4j . createComplex ( targetShape ) ; INDArrayIndex targetShapeIndex = NDArrayIndex . createCoveringShape ( nd . shape ( ) ) ; ret . put ( targetShapeIndex , nd ) ; return ret ; }
( INDArray arr ) { switch ( arr . data ( ) . dataType ( ) ) { case DOUBLE : DefaultOpExecutioner . validateDataType ( DataBuffer . Type . DOUBLE , arr ) ; return isamax ( arr . length ( ) , arr , 1 ) ; case FLOAT : DefaultOpExecutioner . validateDataType ( DataBuffer . Type . FLOAT , arr ) ; return isamax ( arr . length ( ) , arr , 1 ) ; case HALF : DefaultOpExecutioner . validateDataType ( DataBuffer . Type . HALF , arr ) ; return ihamax ( arr . length ( ) , arr , 1 ) ; default : } throw new UnsupportedOperationException ( ) ; }
the array to the current device .
a message to the originator .
gamma ( MathContext mc ) { if ( mc . getPrecision ( ) < GAMMA . precision ( ) ) { return GAMMA . round ( mc ) ; } else { double eps = prec2err ( 0.577 , mc . getPrecision ( ) ) ; MathContext mcloc = new MathContext ( 2 + mc . getPrecision ( ) ) ; BigDecimal resul = BigDecimal . ONE ; resul = resul . add ( log ( 2 , mcloc ) ) ; resul = resul . subtract ( log ( 3 , mcloc ) ) ; return resul . round ( mc ) ; } }
( final BigDecimal x ) { if ( x . compareTo ( BigDecimal . ZERO ) < 0 ) { throw new ArithmeticException ( " negative argument " + x . toString ( ) + " of square root " ) ; } return root ( 2 , x ) ; }
( final BigDecimal x ) { if ( x . compareTo ( BigDecimal . ZERO ) < 0 ) { return root ( 3 , x ) . negate ( ) ; } else { return root ( 3 , x ) ; } }
the root of the given BigDecimal .
exp ( BigDecimal x ) { if ( x . compareTo ( BigDecimal . ZERO ) == 0 ) { return exp ( x ) ; } else if ( x . compareTo ( BigDecimal . ONE ) == 0 ) { return exp ( x ) ; } else if ( x . compareTo ( BigDecimal . ONE ) == 0 ) { return exp ( x ) ; } else if ( x . compareTo ( BigDecimal . ONE ) == 0 ) { return exp ( x ) ; } else if ( x . compareTo ( BigDecimal . ONE ) == 0 ) { return exp ( x ) ; } else if ( x . compareTo ( BigDecimal . ONE ) == 0 ) { return exp ( x ) ; } else if ( x . compareTo ( BigDecimal . ONE ) == 0 ) { return exp ( x ) ; } else if ( x . compareTo ( BigDecimal . ONE ) == 0 ) { return exp ( x ) ; } else if ( x . compareTo ( BigDecimal . ONE ) == 0 ) { return exp
exp ( final MathContext mc ) { if ( mc . getPrecision ( ) < E . precision ( ) ) { return E . round ( mc ) ; } else { BigDecimal uni = scalePrec ( BigDecimal . ONE , mc . getPrecision ( ) ) ; return exp ( uni ) ; } }
the power of the given BigDecimal .
( final BigDecimal x , final int n ) { MathContext mc = new MathContext ( x . precision ( ) - ( int ) Math . log10 ( ( double ) ( Math . abs ( n ) ) ) ) ; return x . pow ( n , mc ) ; }
sin ( final BigDecimal x ) { if ( x . compareTo ( BigDecimal . ZERO ) < 0 ) { return sin ( x . negate ( ) ) . negate ( ) ; } else if ( x . compareTo ( BigDecimal . ZERO ) == 0 ) { return BigDecimal . ZERO ; } double errpi = 0.5 * Math . abs ( x . ulp ( ) . doubleValue ( ) ) ; int val = 2 + err2prec ( FastMath . PI , errpi ) ; MathContext mc = new MathContext ( val ) ; BigDecimal p = pi ( mc ) ; mc = new MathContext ( x . precision ( ) ) ; if ( res . compareTo ( p ) > 0 ) { return sin ( subtractRound ( res , p ) ) . negate ( ) ; } else if ( res . multiply ( new BigDecimal ( 2 ) ) . compareTo ( p ) > 0 ) { return sin ( subtractRound ( p , res ) ) . negate ( ) ; } else
( final BigDecimal x ) { if ( x . compareTo ( BigDecimal . ZERO ) == 0 ) { return x ; } else if ( x . compareTo ( BigDecimal . ZERO ) < 0 ) { return tan ( x . negate ( ) ) . negate ( ) ; } else if ( x . compareTo ( BigDecimal . ZERO ) > 0 ) { return tan ( x . negate ( ) ) . negate ( ) ; } else if ( x . compareTo ( BigDecimal . ZERO ) < 0 ) { return tan ( x . negate ( ) ) . negate ( ) ; } else if ( x . compareTo ( BigDecimal . ZERO ) > 0 ) { return tan ( x . negate ( ) ) . negate ( ) ; } else if ( x . compareTo ( BigDecimal . ZERO ) < 0 ) { return tan ( x . negate ( ) ) . negate ( ) ; } else { return tan ( x . negate ( ) ) . negate ( ) ; } }
( final BigDecimal x ) { if ( x . compareTo ( BigDecimal . ZERO ) < 0 ) { return cosh ( x . negate ( ) ) ; } else if ( x . compareTo ( BigDecimal . ZERO ) == 0 ) { return sinh ( x . negate ( ) ) ; } else if ( x . compareTo ( BigDecimal . ONE ) == 0 ) { return cosh ( x . negate ( ) ) ; } else { if ( x . doubleValue ( ) > 1.5 ) { return hypot ( 1 , sinh ( x ) ) ; } else { BigDecimal xhighpr = scalePrec ( x , 2 ) ; BigDecimal resul = BigDecimal . ONE ; BigInteger ifac = BigInteger . ONE ; double xUlpDbl = 0.5 * x . ulp ( ) . doubleValue ( ) * x . doubleValue ( ) ; int k = ( int ) ( Math . log ( xUlpDbl ) / Math . log ( x . doubleValue ( )
sinh ( final BigDecimal x ) { if ( x . compareTo ( BigDecimal . ZERO ) < 0 ) { return sinh ( x . negate ( ) ) . negate ( ) ; } else if ( x . compareTo ( BigDecimal . ZERO ) == 0 ) { return sinh ( x . negate ( ) ) . negate ( ) ; } else if ( x . compareTo ( BigDecimal . ONE ) == 0 ) { return sinh ( x . negate ( ) ) . negate ( ) ; } else if ( x . compareTo ( BigDecimal . TWO ) == 0 ) { return sinh ( x . negate ( ) ) . negate ( ) ; } }
( final BigDecimal x ) { if ( x . compareTo ( BigDecimal . ZERO ) < 0 ) { return tanh ( x . negate ( ) ) . negate ( ) ; } else if ( x . compareTo ( BigDecimal . ZERO ) == 0 ) { return BigDecimal . ZERO ; } else { BigDecimal xhighpr = scalePrec ( x , 2 ) ; BigDecimal exp2x = exp ( xhighpr . multiply ( new BigDecimal ( - 2 ) ) ) ; double eps = 0.5 * x . ulp ( ) . doubleValue ( ) / Math . pow ( Math . cosh ( x . doubleValue ( ) ) , 2.0 ) ; MathContext mc = new MathContext ( err2prec ( Math . tanh ( x . doubleValue ( ) ) , eps ) ) ; return BigDecimal . ONE . subtract ( exp2x ) . divide ( BigDecimal . ONE . add ( exp2x ) , mc ) ; } }
( final BigDecimal x ) { if ( x . compareTo ( BigDecimal . ZERO ) == 0 ) { return BigDecimal . ZERO ; } else { BigDecimal xhighpr = scalePrec ( x , 2 ) ; BigDecimal logx = log ( hypot ( 1 , xhighpr ) . add ( xhighpr ) ) ; double xDbl = x . doubleValue ( ) ; double eps = 0.5 * x . ulp ( ) . doubleValue ( ) / Math . hypot ( 1. , xDbl ) ; MathContext mc = new MathContext ( err2prec ( logx . doubleValue ( ) , eps ) ) ; return logx . round ( mc ) ; } }
the acosh of the given BigDecimal .
( final BigDecimal x ) { if ( x . compareTo ( BigDecimal . ZERO ) < 0 ) { return divideRound ( Gamma ( x . add ( BigDecimal . ONE ) ) , x ) ; } else if ( x . doubleValue ( ) > 1.5 ) { int n = ( int ) ( x . doubleValue ( ) - 0.5 ) ; BigDecimal xmin1 = x . subtract ( BigDecimal . ONE ) ; return multiplyRound ( Gamma ( xmin1 ) , pochhammer ( xmin1 , n ) ) ; } else { BigDecimal z = x . subtract ( BigDecimal . ONE ) ; z = scalePrec ( z , 2 ) ; MathContext mcloc = new MathContext ( z . precision ( ) ) ; double eps = x . ulp ( ) . doubleValue ( ) / x . doubleValue ( ) ; BigDecimal resul = log ( scalePrec ( x , 2 ) ) . negate ( ) ; if ( x . compareTo ( BigDecimal . ONE ) != 0
broadhurstBBP ( final int n , final int p , final int a [ ] ) { if ( a == null ) { return BigDecimal . ZERO ; } if ( a . length == 0 ) { return BigDecimal . ZERO ; } if ( a [ a . length - 1 ] == 0 ) { return BigDecimal . ZERO ; } if ( a [ a . length - 1 ] == 0 ) { return BigDecimal . ZERO ; } if ( a [ a . length - 1 ] == 0 ) { return BigDecimal . ZERO ; } if ( a [ a . length - 1 ] == 0 ) { return BigDecimal . ZERO ; } if ( a [ a . length - 1 ] == 0 ) { return BigDecimal . ZERO ; } if ( a [ a . length - 1 ] == 0 ) { return BigDecimal . ZERO ; } if ( a [ a . length - 1 ] == 0 ) { return BigDecimal . ZERO ; } if ( a [ a . length - 1
scalePrec ( final BigDecimal x , int d ) { return x . setScale ( d + x . scale ( ) ) ; }
( final BigDecimal x , final MathContext mc ) { final int diffPr = mc . getPrecision ( ) - x . precision ( ) ; if ( diffPr > 0 ) { return scalePrec ( x , diffPr ) ; } else { return x ; } }
err2prec ( BigDecimal x , BigDecimal xerr ) { return err2prec ( xerr . divide ( x , MathContext . DECIMAL64 ) . doubleValue ( ) ) ; }
the function for the given id .
inputs for a given function .
the array for the given varName .
a shape for a given varName .
an array with a variable .
the property for the given function .
void addPropertyForFunction ( DifferentialFunction functionFor , String propertyName , INDArray property ) { addPropertyForFunction ( functionFor , propertyName , ( Object ) property ) ; }
outgoing arguments for the given function .
args for the given function .
if a function has a given vertexId .
the inputs .
one ( String name ) { return var ( name , ArrayUtil . toLongArray ( shape ) , new ConstantInitScheme ( ' f ' , 1.0 ) ) ; }
onesLike ( String name , SDVariable input ) { return f ( ) . onesLike ( name , input ) ; }
zerosLike ( String name , SDVariable input ) { return f ( ) . zerosLike ( name , input ) ; }
the argument from the function .
gradient for variable name .
( SDVariable [ ] inputs , Pooling3DConfig pooling3DConfig ) { return avgPooling3d ( null , inputs , pooling3DConfig ) ; }
gru ( String baseName , GRUCellConfiguration configuration ) { return new GRUCell ( this , configuration ) . outputVariables ( baseName ) [ 0 ] ; }
a DifferentialFunction .
a While statement .
the same diff function .
the same diff function .
the result of the function .
a place holder for the given variable .
a pointer to a host memory .
the length of the data type .
the type of the allocation mode .
dtype from context .
( String opName ) { try { DifferentialFunction op = DifferentialFunctionClassHolder . getInstance ( ) . getInstance ( opName ) ; return op . opNum ( ) ; } catch ( Exception e ) { throw new RuntimeException ( " OpName failed : [ " + opName + " ] " , e ) ; } }
all workspaces for current thread .
Workspace statistics for current thread .
( char order , char Uplo , char TransA , char Diag , INDArray A , INDArray X ) { if ( Nd4j . getExecutioner ( ) . getProfilingMode ( ) == OpExecutioner . ProfilingMode . ALL ) OpProfiler . getInstance ( ) . processBlasCall ( order , Uplo , TransA , Diag , A , X ) ; else OpProfiler . getInstance ( ) . processBlasCall ( order , Uplo , TransA , Diag , A , X ) ; }
a message .
a Variance accumulation .
INDArray thresholdDecode ( INDArray encoded , INDArray target ) { return backendExecutioner . thresholdDecode ( encoded , target ) ; }
the name of the node .
a scalar operation .
all workspaces for the current thread .
log likelihood .
( long time , TimeUnit timeUnit ) { long timeframeMs = TimeUnit . MILLISECONDS . convert ( time , timeUnit ) ; try { Thread . sleep ( timeframeMs ) ; } catch ( InterruptedException e ) { throw new RuntimeException ( e ) ; } }
toe ( ) { if ( isToeWaiting . get ( ) || getCurrentState ( ) == AccessState . TOE ) { discardScheduledToe ( ) ; return false ; } else { discardScheduledToe ( ) ; requestToe ( ) ; return true ; } }
the Toe object .
getCurrentState ( ) { if ( AccessState . values ( ) [ currentState . get ( ) ] == AccessState . TOE ) { return AccessState . TOE ; } else { if ( tickRequests . get ( ) <= tackRequests . get ( ) ) { tickRequests . set ( 0 ) ; tackRequests . set ( 0 ) ; return AccessState . TACK ; } else return AccessState . TICK ; } }
the environment .
a message to the clipboard .
a new DataSet .
hostCollectors .
Pointer getPointer ( DataBuffer buffer , CudaContext context ) { return memoryHandler . getDevicePointer ( buffer , context ) ; }
the host data .
Updater to the gradient .
( AllocationPoint point ) { if ( ! point . isConstant ( ) && point . isEnqueued ( ) ) { waitTillFinished ( point ) ; } super . synchronizeToHost ( point ) ; }
a new NDArrayIndex array from the given index .
the properties of the function .
whether a given argument is a place holder .
the gradients of a given variable .
the scientific format .
the same graph .
a ComplexNDArray to a Blob .
( Blob blob ) throws SQLException { DataInputStream dis = new DataInputStream ( blob . getBinaryStream ( ) ) ; return Nd4j . readComplex ( dis ) ; }
( IComplexNDArray save , String id ) throws IOException { if ( save == null ) { return null ; } if ( save instanceof IComplexNDArray ) { ( ( IComplexNDArray ) save ) . save ( ) ; } return save ; }
the real to the linear view .
the Imag to the linear view .
( Number other ) { if ( other . length ( ) == linearView ( ) . length ( ) ) return this ; if ( other . length ( ) == linearView ( ) . length ( ) ) return this ; if ( other . length ( ) == linearView ( ) . length ( ) ) return this ; if ( other . length ( ) == linearView ( ) . length ( ) ) return this ; if ( other . length ( ) == linearView ( ) . length ( ) ) return this ; if ( other . length ( ) == linearView ( ) . length ( ) ) return this ; if ( other . length ( ) == linearView ( ) . length ( ) ) return this ; if ( other . length ( ) == linearView ( ) . length ( ) ) return this ; if ( other . length ( ) == linearView ( ) . length ( ) ) return this ; return this ; }
a scalar to a linear view .
an IComplexNDArray .
IComplexNDArray putRow ( long row , INDArray toPut ) { return ( IComplexNDArray ) super . putRow ( row , toPut ) ; }
a new column into the given array .
a new IComplexNDArray .
( INDArray other , INDArray result ) { if ( other == null ) { throw new IllegalArgumentException ( ) ; } if ( result == null ) { throw new IllegalArgumentException ( ) ; } if ( other . isComplex ( ) ) { throw new IllegalArgumentException ( ) ; } if ( result . isComplex ( ) ) { throw new IllegalArgumentException ( ) ; } }
( IComplexNDArray other , INDArray result ) { if ( other . isScalar ( ) ) return subi ( other . getComplex ( 0 ) , result ) ; if ( result . isScalar ( ) ) return subi ( other . getComplex ( 1 ) , result ) ; if ( result . isScalar ( ) ) return subi ( other . getComplex ( 2 ) , result ) ; if ( result . isScalar ( ) ) return subi ( other . getComplex ( 3 ) , result ) ; if ( result . isScalar ( ) ) return subi ( other . getComplex ( 4 ) , result ) ; if ( result . isScalar ( ) ) { if ( data . dataType ( ) == DataBuffer . Type . DOUBLE ) { Nd4j . getBlasWrapper ( ) . scal ( Nd4j . NEG_UNIT . asDouble ( ) , cResult ) ; Nd4j . getBlasWrapper ( ) . axpy
( INDArray other , INDArray result ) { if ( other . isScalar ( ) ) { return cOther . addi ( getComplex ( 0 ) , result ) ; } if ( result . isScalar ( ) ) { return cResult . addi ( getComplex ( 0 ) , result ) ; } if ( result . isScalar ( ) ) { return cResult . addi ( getComplex ( 0 ) , result ) ; } if ( result . isScalar ( ) ) { return cResult . addi ( getComplex ( 0 ) , result ) ; } if ( result . isScalar ( ) ) { return cResult . addi ( getComplex ( 0 ) , result ) ; } if ( result . isScalar ( ) ) { return cResult . addi ( getComplex ( 0 ) , result ) ; } if ( result . isScalar ( ) ) { return cResult . addi ( getComplex ( 0 ) , result ) ; }
a value to the linear view .
a new IComplexNDArray .
the eigenvalues of the given matrix .
( INDArray A , INDArray B ) { assert A . rows ( ) == A . columns ( ) ; assert B . rows ( ) == B . columns ( ) ; INDArray W = Nd4j . create ( A . rows ( ) ) ; A = InvertMatrix . invert ( B , false ) . mmuli ( A ) ; B = InvertMatrix . invert ( B , false ) . mmuli ( B ) ; W = Nd4j . create ( W . rows ( ) ) ; Nd4j . getBlasWrapper ( ) . syev ( ' V ' , ' L ' , A , W ) ; return W ; }
( IComplexNDArray arr ) { if ( arr . data ( ) . dataType ( ) == DataBuffer . Type . DOUBLE ) return izamax ( arr . length ( ) , arr , BlasBufferUtil . getBlasStride ( arr ) ) ; if ( arr . data ( ) . dataType ( ) == DataBuffer . Type . FLOAT ) return izamax ( arr . length ( ) , arr , BlasBufferUtil . getBlasStride ( arr ) ) ; if ( arr . data ( ) . dataType ( ) == DataBuffer . Type . DOUBLE ) return izamax ( arr . length ( ) , arr , BlasBufferUtil . getBlasStride ( arr ) ) ; return izamax ( arr . length ( ) , arr , BlasBufferUtil . getBlasStride ( arr ) ) ; }
( IComplexNDArray x , IComplexNDArray y ) { if ( x . data ( ) . dataType ( ) == DataBuffer . Type . DOUBLE ) zcopy ( x . length ( ) , x , BlasBufferUtil . getBlasStride ( x ) , y , BlasBufferUtil . getBlasStride ( y ) ) ; else ccopy ( x . length ( ) , x , BlasBufferUtil . getBlasStride ( x ) , y , BlasBufferUtil . getBlasStride ( y ) ) ; }
( long N , IComplexNumber alpha , IComplexNDArray X ) { if ( X . dataType ( ) == DataBuffer . Type . DOUBLE ) zscal ( N , alpha . asDouble ( ) , X , BlasBufferUtil . getBlasStride ( X ) ) ; else if ( X . dataType ( ) == DataBuffer . Type . FLOAT ) zscal ( N , alpha . asFloat ( ) , X , BlasBufferUtil . getBlasStride ( X ) ) ; else if ( X . dataType ( ) == DataBuffer . Type . DOUBLE ) zscal ( N , alpha . asDouble ( ) , X , BlasBufferUtil . getBlasStride ( X ) ) ; else if ( X . dataType ( ) == DataBuffer . Type . FLOAT ) zscal ( N , alpha . asFloat ( ) , X , BlasBufferUtil . getBlasStride ( X ) ) ; else if ( X . dataType ( ) == DataBuffer . Type . DOUBLE )
a message to the originator .
the sum of the weights and labels .
a LossInfo for the specified reduction .
a no - arg constructor .
constructor for " + clazz . getName ( ) ; }
the method with the given params .
getAnnotation ( Annotation [ ] annotations ) { for ( Annotation anno : annotations ) if ( annotationType . isAssignableFrom ( anno . getClass ( ) ) ) return ( A ) anno ; return null ; }
the annotated annotation .
static < A extends Annotation > boolean isDeclaredAnnotation ( Class < ? > onClass , Class < A > annotationType ) { return getDeclaredAnnotation ( onClass , annotationType ) != null ; }
a new instance of this class .
the entity value .
a full entity .
a new instance of MemcacheService .
the metadata for the given kind .
< Key < T > > queryKeysOnly ( final KeyQuery query ) { log . trace ( " Starting keys - only query " ) ; return new KeyQueryResults < > ( ds . run ( query ) ) ; }
< T > queryHybrid ( final KeyQuery query , final int chunkSize ) { log . trace ( " Starting hybrid query " ) ; final QueryResults < Key < T > > results = new KeyQueryResults < > ( ds . run ( query ) ) ; return new HybridQueryResults < > ( loader . createLoadEngine ( ) , results , chunkSize ) ; }
< T > queryNormal ( final EntityQuery query , final int chunkSize ) { log . trace ( " Starting normal query " ) ; final LoadEngine loadEngine = loader . createLoadEngine ( ) ; final QueryResults < Entity > entityResults = ds . run ( query ) ; final QueryResults < com . google . cloud . datastore . Key > stuffed = new StuffingQueryResults ( loadEngine , entityResults ) ; final QueryResults < Key < T > > keyResults = new KeyQueryResults < > ( stuffed ) ; return new HybridQueryResults < > ( loadEngine , keyResults , chunkSize ) ; }
< T > queryProjection ( final ProjectionEntityQuery query ) { log . trace ( " Starting projection query " ) ; final LoadEngine loadEngine = loader . createLoadEngine ( ) ; return new ProjectionQueryResults < > ( ds . run ( query ) , loadEngine ) ; }
the results of the query .
< Iterator < T > , Iterator < T > > partition ( Iterator < T > input , int chunkSize ) { if ( chunkSize > 1000 ) { chunkSize = 1000 ; } return Iterators . transform ( Iterators . partition ( input , chunkSize ) , IterateFunction . instance ( ) ) ; }
the results from the database .
the message of the given path .
a new Key < T > instance .
( final Object k1 , final Object k2 ) { return Integer . compare ( System . identityHashCode ( k1 ) , System . identityHashCode ( k2 ) ) ; }
< V > key ( ) { if ( raw == null ) return null ; else return new Key < > ( raw ) ; }
the key of the typed object .
the kind of the entity .
true if the given type is a ParameterizedType .
static boolean isSuperType ( Type superType , Type subType ) { if ( superType instanceof ParameterizedType ) { return isSuperType ( superType , subType ) ; } else if ( subType instanceof ParameterizedType ) { return isSuperType ( subType , subType ) ; } else if ( subType instanceof ParameterizedType ) { return isSuperType ( subType , subType ) ; } else if ( subType instanceof ParameterizedType ) { return isSuperType ( subType , subType ) ; } else if ( subType instanceof ParameterizedType ) { return isSuperType ( subType , subType ) ; } else if ( subType instanceof ParameterizedType ) { return isSuperType ( subType , subType ) ; } else if ( subType instanceof ParameterizedType ) { return isSuperType ( subType , subType ) ; } else if ( subType instanceof ParameterizedType ) { return isSuperType ( subType , subType ) ; } else if ( subType instanceof ParameterizedType ) { return isSuperType ( subType , subType ) ; } else if (
( Type type ) { if ( type == null ) { throw new NullPointerException ( ) ; } else if ( type instanceof ParameterizedType ) { type = ( ParameterizedType ) type ; } return mapTypeParameters ( type , type ) ; }
the given type .
< P , D > getTranslator ( final TypeKey < P > tk ) { return factory . getTranslator ( tk ) ; }
< P > getPopulator ( final Class < P > clazz , final Path path ) { if ( clazz == null || clazz . equals ( Object . class ) ) { return ( Populator < P > ) NullPopulator . INSTANCE ; } else { final ClassTranslator < P > classTranslator = ( ClassTranslator < P > ) this . < P , FullEntity < ? > > getTranslator ( new TypeKey < > ( clazz ) , this , path ) ; return classTranslator . getPopulator ( ) ; } }
the index instruction for the given class .
if a method is of interest .
the properties of the given class .
the key metadata for the given entity .
the result of a given key .
the given round .
all pending entities from the datastore .
indexed discriminators .
a subclass of the given class .
the collection component type .
the map key type .
of ( Path path ) { ForwardPath next = new ForwardPath ( path ) ; if ( path . getPrevious ( ) == Path . root ( ) ) return next ; ForwardPath previous = of ( path ) ; previous . next = next ; return previous ; }
( ) { ForwardPath here = this ; while ( here . next != null ) here = here . next ; return here . getPath ( ) ; }
the path of the root .
the depth of the given path .
void putAll ( final Collection < Bucket > updates ) { final Set < Key > good = this . cachePutIfUntouched ( updates ) ; if ( good . size ( ) == updates . size ( ) ) return ; final List < Key > bad = updates . stream ( ) . map ( Bucket :: getKey ) . filter ( key -> ! good . contains ( key ) ) . collect ( Collectors . toList ( ) ) ; if ( ! bad . isEmpty ( ) ) { final Map < Key , Object > cached = this . cacheGetAll ( bad ) ; cached . values ( ) . removeIf ( Objects :: isNull ) ; this . empty ( cached . keySet ( ) ) ; } }
a Map < Key , Object > for the given key .
a new entry to the memcache .
all keys from memcache .
the keys of the buckets .
all @ Id fields in the class hierarchy .
the key to the datastore .
the id of the given POJO .
the parent key .
a subclass of the given type .
the common subtype of the given type .
the given owner to a subtype of the given class .
getAnnotationAnywhere ( Class < A > annotationType ) { A anno = getAnnotation ( annotationType ) ; if ( anno == null ) { Class < ? > clazz = ( Class < ? > ) GenericTypeReflector . erase ( type ) ; return clazz . getAnnotation ( annotationType ) ; } else { return anno ; } }
all values to session .
the given key .
a new round .
a Map < Key < ? > , Object > .
the data from the datastore .
the entity from the datastore .
a raw key .
the raw key .
the id value of the given key .
( final String urlSafeKey ) { if ( urlSafeKey . startsWith ( " a " ) ) { return KeyFormat . INSTANCE . parseOldStyleAppEngineKey ( urlSafeKey . substring ( 1 ) ) ; } else if ( urlSafeKey . startsWith ( " b " ) ) { return KeyFormat . INSTANCE . parseOldStyleAppEngineKey ( urlSafeKey . substring ( 2 ) ) ; } else { return KeyFormat . INSTANCE . parseOldStyleAppEngineKey ( urlSafeKey ) ; } }
a new TransactorNo ( final TransactorNo parentTransactor ) { return new TransactorNo ( parentTransactor ) ; }
new ( final ObjectifyImpl parent , final int limit , final Work < R > work ) { return transactionless ( parent ) . transactNew ( limitTries , work ) ; }
a single transaction .
true if a condition matches a given value .
the ofy object .
asyncDatastore ( ) { if ( this . entityMemcache != null && enableGlobalCache && this . registrar . isCacheEnabled ( ) ) return new CachingAsyncDatastore ( asyncDatastore ( ) , this . entityMemcache ) ; else return asyncDatastore ( ) ; }
the metadata for the given entity .
a key range .
the objectify .
the objectify .
the index of the given value .
< T > create ( T value ) { Key < T > key = Key . create ( value ) ; return create ( key ) ; }
the value of the key .
a value to the list .
the result of the operation .
if conditions for a given field .
a runnable .
the container from the given path .
the stats of a given kind .
( Throwable ex ) { if ( ex instanceof RuntimeException ) throw ( RuntimeException ) ex ; else if ( ex instanceof Error ) throw ( Error ) ex ; else if ( ex instanceof ExecutionException ) unwrapAndThrow ( ex . getCause ( ) ) ; else throw new UndeclaredThrowableException ( ex ) ; }
< P , D > get ( final TypeKey tk ) { if ( translators . containsKey ( tk ) ) { return translators . get ( tk ) ; } return null ; }
< P , FullEntity < ? > > getRoot ( final Class < P > clazz ) { return get ( new TypeKey ( clazz ) , new CreateContext ( fact ) , Path . root ( ) ) ; }
a new Translator for the given type .
the property from the container .
the property from the container .
the value of the pojo .
the value of the property .
the value to the container .
extensions to the message .
content category .
( String fieldName , List < String > cats , JsonGenerator gen ) throws IOException { if ( ! cats . isEmpty ( ) ) { gen . writeArrayFieldStart ( fieldName ) ; for ( String cat : cats ) { writeContentCategory ( cat , gen ) ; } gen . writeEndArray ( ) ; } }
the given snippet .
< Bid . Builder > bids ( ) { return new ResponseBidsIterator ( response , SEAT_ANY , null ) ; }
the bid for the given id .
the Bid . Builder list .
all seatbids from the response .
a list of all imps that are included in the request .
all extensions .
true if the token is empty .
register ( OpenRtbJsonExtReader < EB > extReader ) { extReaders . put ( extReader . getClass ( ) . getName ( ) , extReader ) ; return this ; }
a new OpenRtbJsonExtWriter for the given message .
( SnippetProcessorContext bidCtx ) { for ( SeatBid . Builder seat : bidCtx . response ( ) . getSeatbidBuilderList ( ) ) { for ( Bid . Builder bid : seat . getBidBuilderList ( ) ) { bidCtx . setBid ( bid ) ; processFields ( bidCtx ) ; } } }
the Bid . Builder from the SnippetProcessorContext .
a messageLite . Builder object .
the given list .
the current name .
the name of the object .
the start of the array .
the current token .
( String fieldName , boolean data , JsonGenerator gen ) throws IOException { if ( data ) { gen . writeNumberField ( fieldName , 0 ) ; } else { gen . writeNumberField ( fieldName , 1 ) ; } }
a list of strings to a JSON file .
( String fieldName , List < Integer > data , JsonGenerator gen ) throws IOException { if ( ! data . isEmpty ( ) ) { gen . writeArrayFieldStart ( fieldName ) ; for ( Integer d : data ) { gen . writeNumber ( d ) ; } gen . writeEndArray ( ) ; } }
a list of longs to a JSON file .
( String fieldName , List < ProtocolMessageEnum > enums , JsonGenerator gen ) throws IOException { if ( ! enums . isEmpty ( ) ) { gen . writeArrayFieldStart ( fieldName ) ; for ( ProtocolMessageEnum e : enums ) { writeEnum ( e , gen ) ; } gen . writeEndArray ( ) ; } }
the URL for the given target .
( URL base , String target ) throws MalformedURLException { if ( target . startsWith ( " ? " ) ) target = target . substring ( 1 ) ; if ( target . startsWith ( " ? " ) ) target = target . substring ( 1 ) ; if ( target . startsWith ( " ? " ) ) target = target . substring ( 1 ) ; if ( target . startsWith ( " ? " ) ) target = target . substring ( 1 ) ; if ( target . startsWith ( " ? " ) ) target = target . substring ( 1 ) ; if ( target . startsWith ( " ? " ) ) target = target . substring ( 1 ) ; if ( target . startsWith ( " ? " ) ) target = target . substring ( 1 ) ; return new URL ( base , target ) ; }
the host name from the URL .
the hostname of the given URL .
the page of the given url .
List < String > fromConf ( Map stormConf ) { return loadListFromConf ( stormConf ) ; }
the config element .
the protocol of the URL .
WARC info .
the refresh url from the value .
the outlink metadata from the given URL .
the given metadata .
a scheduled URL to the queue .
the field name .
the charset name from the byte data .
the charset from a byte array .
the charset from the given input .
whether the given content is sniffed or not .
the value of the given key .
the first value of the given key .
the cookies from the given URL .
if the cookie domain matches the url .
the cache key from the URL .
the robot rules from the cache .
meta tags from the document .
an acknowledgement .
the given URL .
the url string .
rules from file .
the URL to a string .
the NavigationFilters from the config file .
a new record format .
( ) { if ( timeLastQuerySent != 0 ) { long difference = System . currentTimeMillis ( ) - timeLastQuerySent ; if ( difference < minDelayBetweenQueries ) { return minDelayBetweenQueries - difference ; } } return 0 ; }
a query .
the ParseFilters from the config file .
a new node to the document .
an empty string into the document .
a processing instruction to the document .
a comment to the document .
cdata ( char ch [ ] , int start , int length ) { if ( isOutsideDocElem ( ) && XMLCharacterRecognizer . isWhiteSpace ( ch , start , length ) ) { return ; } String s = new String ( ch , start , length ) ; Node n = m_currentNode . getFirstChild ( ) ; if ( n instanceof CDATASection ) { ( ( CDATASection ) n ) . appendData ( s ) ; } if ( n instanceof Comment ) { ( ( Comment ) n ) . appendData ( s ) ; } }
void startDTD ( String name , String publicId , String systemId ) throws SAXException { if ( publicId != null && systemId != null && systemId . length ( ) > 0 ) { startDTD ( name , publicId , systemId ) ; } }
void startPrefixMapping ( String prefix , String uri ) throws SAXException { if ( prefix == null ) { throw new SAXException ( ) ; } if ( uri == null ) { throw new SAXException ( ) ; } }
the canonical URL for the given URL .
the text .
the duration of a custom interval .
the URLFilters from the config file .
the number of items in the wheel .
the size of the specified measureSpec .
the empty item drawable .
the angle .
the selected position .
( int position ) { int adapterPos = rawPositionToAdapterPosition ( position ) ; if ( isEmptyItemPosition ( adapterPos ) ) return ; CacheItem cacheItem = mItemCacheArray [ adapterPos ] ; if ( cacheItem != null ) cacheItem . mDirty = true ; invalidate ( ) ; }
raw position to wheel position .
the angular velocity .
the color of the given color .
clamp ( int value , int upperLimit ) { if ( upperLimit > 0 ) { return value + ( - 1 * ( int ) Math . floor ( value / ( float ) upperLimit ) ) * upperLimit ; } else if ( upperLimit < 0 ) { return value + ( - 1 * ( int ) Math . floor ( value / ( float ) upperLimit ) ) * upperLimit ; } else if ( upperLimit < 0 ) { return value + ( - 1 * ( int ) Math . floor ( value / ( float ) upperLimit ) ) * upperLimit ; } else { return value + ( - 1 * ( int ) Math . floor ( value / ( float ) upperLimit ) ) * upperLimit ; } }
Coveralls data to a file .
( ) { return getDataAsByteBuffer ( ) ; }
setString ( String val ) { int rank = getRank ( ) ; if ( rank != 1 ) throw new IllegalArgumentException ( " ArayChar . setString rank must be 1" ) ; int arrayLen = indexCalc . getShape ( 0 ) ; int strLen = Math . min ( val . length ( ) , arrayLen ) ; for ( int k = 0 ; k < strLen ; k ++ ) storage [ k ] = val . charAt ( k ) ; return val ; }
a string array .
a new ArrayChar from the given string .
( ArrayObject values ) { if ( values == null ) { return makeFromStringArray ( null ) ; } if ( values instanceof String ) { return makeFromStringArray ( ( String ) values ) ; } return makeFromStringArray ( values ) ; }
a new ArrayChar from the given array .
( Grib2Record gr ) { Grib2Pds pds = gr . getPDS ( ) ; if ( ! pds . isTimeInterval ( ) ) { return new int [ 0 ] ; } return new int [ 0 ] ; }
IndependentWindow .
the IndependentWindow .
the size of the grid .
a file .
new UnitName ( final String name ) throws NameException { return newUnitName ( name , null ) ; }
new UnitName ( final String name , final String plural , final String symbol ) throws NameException { return new UnitName ( name , plural , symbol ) ; }
the plural of the given name .
boolean included ( Date d ) { if ( isEmpty ) return false ; if ( getStart ( ) . after ( d ) ) return false ; if ( getEnd ( ) . before ( d ) ) return false ; return true ; }
( DateRange clip ) { if ( clip == null ) return this ; if ( clip . isEmpty ( ) ) return clip ; DateType ss = getStart ( ) ; DateType s = ss . before ( clip . getStart ( ) ) ? clip . getStart ( ) : ss ; DateType ee = getEnd ( ) ; DateType e = ee . before ( clip . getEnd ( ) ) ? ee : clip . getEnd ( ) ; return new DateRange ( s , e ) ; }
( DateRange dr ) { boolean localEmpty = isEmpty ; if ( localEmpty || dr . getStart ( ) . before ( getStart ( ) ) ) setStart ( dr . getStart ( ) ) ; if ( localEmpty || getEnd ( ) . before ( dr . getEnd ( ) ) ) setEnd ( dr . getEnd ( ) ) ; }
the given date .
the start of a DateType .
the end of the given date .
the duration of the given duration .
the duration for the given date .
a MapBean to the menu .
( String s ) { System . err . println ( " CEParserImpl . yyerror : " + s + " ; parse failed " ) ; }
the name of the ncd .
a string representation of the params .
a FileDSP from a byte array .
( LatLonRect llbb , int horizStride ) { synchronized ( this ) { if ( edges == null ) edges = new Edges ( ) ; } return edges . computeBounds ( llbb , horizStride ) ; }
the minimum and maximum value of the slider .
unlimited chunks .
a watcher for the given dir .
a list of all watched keys .
the reference date .
a feature dataset .
the given feature type .
the feature type of the given feature .
( NetcdfFile ncd ) { return null ; }
a catalog to the response .
Catalog to HTML .
the user stylesheet .
the user head .
a Catalog for the given path .
global services to the catalog .
the global credentials provider .
the content of the given HTTPSession .
the content to the specified location .
a FrontPage .
a catalog for the given configPath .
Geospatial coverage from the group .
a GribCollectionImmutable . Dataset .
nearlyEquals ( VertCoordValue other ) { return Misc . nearlyEquals ( value1 , other . value1 ) && Misc . nearlyEquals ( value2 , other . value2 ) ; }
a new UnitID for the given name .
a GradsAttribute from a string .
the top of the file .
shortsToInt ( short s1 , short s2 , boolean swapBytes ) { if ( swapBytes ) { return shortsToInt ( s1 , s2 , swapBytes ) ; } if ( swapBytes ) { return shortsToInt ( s1 , s2 , swapBytes ) ; } if ( swapBytes ) { return shortsToInt ( s1 , s2 , swapBytes ) ; } if ( swapBytes ) { return shortsToInt ( s1 , s2 , swapBytes ) ; } return shortsToInt ( s1 , s2 , swapBytes ) ; }
a byte array to an int .
a java . util . Date .
a valid NetCDF object name .
whether the given name is a Netcdf3 object .
( ) { return this ; }
record data .
record data subset .
( ) throws IOException { for ( Variable v : ncfile . getVariables ( ) ) { if ( v . isUnlimited ( ) ) continue ; try { writeData ( v , v . getShapeAsSection ( ) , makeConstantArray ( v ) ) ; } catch ( InvalidRangeException e ) { e . printStackTrace ( ) ; } } }
a time struct .
a new GradsTimeStruct .
the time template for the given template .
a server side function .
( String name ) throws NoSuchFunctionException { if ( ! boolFunctions . containsKey ( name ) ) { loadNewFunction ( name ) ; } return boolFunctions . get ( name ) ; }
the BTFunction for the given name .
a new function .
the level name of the grid record .
the level description of the record .
the level unit for the given grid record .
( GridDefRecord gds ) { String name = getProjectionName ( gds ) ; switch ( name ) { case " MERC " : return Mercator ; case " CONF " : return LambertConformal ; case " PS " : return PolarStereographic ; default : return - 1 ; } }
the vertical coordinate of the grid record .
the layer from the grid .
a CoordinateTransform .
a dummy transform variable .
Projection from GridCoordTransform .
a Thredds DatasetChooser .
the info window bounds .
public final Chronology withZone ( DateTimeZone zone ) { if ( zone . equals ( DateTimeZone . UTC ) ) return this . withUTC ( ) ; throw new UnsupportedOperationException ( " Not supported yet . " ) ; }
a count to a buffer .
( DapType daptype ) { this . daptype = daptype ; }
the length of a byte array .
bytes to the output file .
the initialization of the ProjectionPanel .
a CalendarDateRange .
factory ( int template ) { return new Grib2Gds ( ) ; }
parse ( String text ) throws ParseException { return dapparse ( text , dds , null , null ) ; }
( String text , DAS das ) throws ParseException { return dapparse ( text , null , das , null ) ; }
( int [ ] gh ) { McIDASUtil . flip ( gh , 0 , 5 ) ; McIDASUtil . flip ( gh , 7 , 7 ) ; McIDASUtil . flip ( gh , 9 , 10 ) ; McIDASUtil . flip ( gh , 12 , 14 ) ; McIDASUtil . flip ( gh , 32 , 51 ) ; }
the data from the McIDAS grid .
the grid records from the specified file .
a constraint to a file .
( ) { fileOutput += " < wfs : WFS _ Capabilities xsi : schemaLocation = " + WFSXMLHelper . encQuotes ( " http : // www . opengis . net / wfs / 2.0 http : // schemas . opengis . net / wfs / 2.0 / wfs . xsd " ) + " xmlns : xsi = " + WFSXMLHelper . encQuotes ( " http : // www . w3 . org / 2001 / XMLSchema - instance " ) + " xmlns : xlink = " + WFSXMLHelper . encQuotes ( " http : // www . w3 . org / 1999 / xlink " ) + " xmlns : gml = " + WFSXMLHelper . encQuotes ( " http : // opengis . net / gml " ) + " xmlns : fes = " + WFSXMLHelper . encQuotes ( " http : // www . opengis . net / fes
the operation metadata to a file .
all files from the given directory .
the log file .
the grid packing type .
the GempakGridRecord for the given parameter .
the data from the given word .
Grib1 data .
( int [ ] idata , int kxky , int nbits , float qmin , float scale , boolean misflg , int decimalScale ) throws IOException { float scaleFactor = ( decimalScale == 0 ) ? 1.f : ( float ) Math . pow ( 10.0 , - decimalScale ) ; if ( ( kxky <= 1 ) || ( kxky > 31 ) ) { return new float [ kxky ] ; } if ( ( kxky <= 1 ) || ( kxky > 31 ) ) { return new float [ kxky ] ; } if ( ( kxky <= 1 ) || ( kxky > 31 ) ) { return new float [ kxky ] ; } if ( ( kxky <= 1 ) || ( kxky > 31 ) ) { return new float [ kxky ] ; } if ( scaleFactor == 0 ) { scaleFactor = 1 ; }
( int iiword , int nword , int kxky , int nbits , float ref , float scale , boolean miss , int decimalScale ) throws IOException { float [ ] values = new float [ kxky ] ; bitBuf = 0 ; next = 0 ; ch1 = 0 ; ch2 = 0 ; ch3 = 0 ; ch4 = 0 ; for ( int i = 0 ; i < kxky ; i ++ ) { values [ i ] = ( ref + scale * i ) * scaleFactor ; } return values ; }
( int iiword , int lendat , int [ ] iarray , float [ ] rarray ) throws IOException { long start = getOffset ( iiword ) ; rf . seek ( start ) ; Grib2Record gr = makeGribRecord ( rf , start ) ; float [ ] data = gr . readData ( rf ) ; if ( ( ( iarray [ 3 ] >> 6 ) & 1 ) == 0 ) { data = gb2_ornt ( iarray [ 1 ] , iarray [ 2 ] , iarray [ 3 ] , rarray ) ; } else { data = gb2_ornt ( iarray [ 1 ] , iarray [ 2 ] , iarray [ 3 ] , rarray ) ; } return data ; }
all the grid records .
( ) throws IOException { if ( next == 1 ) { bitBuf = ch1 ; } else if ( next == 2 ) { bitBuf = ch2 ; } else if ( next == 3 ) { bitBuf = ch3 ; } else if ( next == 4 ) { bitBuf = ch4 ; } else if ( next == 5 ) { bitBuf = ch5 ; } else if ( next == 6 ) { bitBuf = ch6 ; } else if ( next == 7 ) { bitBuf = ch7 ; } else if ( next == 8 ) { bitBuf = ch8 ; } else if ( next == 9 ) { bitBuf = ch9 ; } else if ( next == 10 ) { bitBuf = ch10 ; } else if ( next == 11 ) { bitBuf = ch11 ; } else if ( next == 12 ) { bitBuf = ch12 ; } else if ( next == 13 ) { bitBuf = ch13
a CalendarDate of the given year .
a CalendarDate .
of ( long msecs ) { DateTime dt = new DateTime ( msecs , DateTimeZone . UTC ) ; return new CalendarDate ( dt ) ; }
of ( Calendar cal ) { if ( cal == null ) { return new CalendarDate ( cal ) ; } return new CalendarDate ( cal ) ; }
( String calendarName , String udunits ) { int pos = udunits . indexOf ( ' ' ) ; if ( pos < 0 ) return null ; String valString = udunits . substring ( 0 , pos ) . trim ( ) ; String unitString = udunits . substring ( pos + 1 ) . trim ( ) ; CalendarDateUnit cdu = CalendarDateUnit . of ( calendarName , unitString ) ; return cdu . makeCalendarDate ( val ) ; }
the difference of a CalendarDate .
a CDMArrayAtomic ( DataCursor data ) throws DapException { CDMArrayAtomic array = new CDMArrayAtomic ( data ) ; return array ; }
the download parameters .
a string to a string .
slices from rangelist .
a NetcdfFile into a NetcdfDataset .
boolean containsVLEN ( List < Dimension > dimset ) { if ( dimset == null ) return false ; for ( Dimension dim : dimset ) if ( dim . isVariableLength ( ) ) return true ; return false ; }
the effective shape of the given dimset .
a date to the Calendar .
multiplyBy ( final Unit that ) { return that instanceof ScaledUnit ? new ScaledUnit ( getScale ( ) * ( ( ScaledUnit ) that ) . getScale ( ) , getUnit ( ) . multiplyBy ( ( ( ScaledUnit ) that ) . getUnit ( ) ) ) : new ScaledUnit ( getScale ( ) , getUnit ( ) . multiplyBy ( that ) ) ; }
( final Unit that ) throws OperationException { return that instanceof ScaledUnit ? new ScaledUnit ( getScale ( ) / ( ( ScaledUnit ) that ) . getScale ( ) , getUnit ( ) . divideBy ( ( ( ScaledUnit ) that ) . getUnit ( ) ) ) : new ScaledUnit ( getScale ( ) , getUnit ( ) . divideBy ( that ) ) ; }
( final Unit that ) throws OperationException { if ( that instanceof ScaledUnit ) { return new ScaledUnit ( ( ( ScaledUnit ) that ) . getScale ( ) / getScale ( ) , getUnit ( ) . divideInto ( ( ( ScaledUnit ) that ) . getUnit ( ) ) ) ; } else { return new ScaledUnit ( 1 / getScale ( ) , getUnit ( ) . divideInto ( that ) ) ; } }
the unit .
the amount to a derived unit .
a float [ ] to a DerivableUnit .
the amount to a derived unit .
the scale of a DerivedUnit .
the data from the given vindex .
the data from the given vindex .
( List < String > stationNames , CalendarDateRange dateRange ) throws IOException { if ( ( stationNames == null ) || ( stationNames . size ( ) == 0 ) ) return new StationTimeSeriesCollectionFlattened ( new StationSubset ( this , dateRange ) , dateRange ) ; return new StationTimeSeriesCollectionFlattened ( new StationSubset ( this , dateRange ) , dateRange ) ; }
an InvService for a given name .
the Gate size for the given datatype .
the Gate start .
the Gate count for the given datatype .
XML to a NetcdfDataset .
the preferred layout size of the target .
descendant dataset from given path .
( CrawlableDataset catalogCrDs , ProxyDatasetHandler pdh ) throws IOException { throw new UnsupportedOperationException ( " This method not supported by SimpleCatalogBuilder . " ) ; }
of ( String calendarName ) { Calendar calt = Calendar . get ( calendarName ) ; if ( calt == null ) calt = Calendar . getDefault ( ) ; return new CalendarDateUnit ( calt ) ; }
a new CalendarDateUnit .
of ( Calendar calt ) { if ( calt == null ) calt = Calendar . getDefault ( ) ; return new CalendarDateUnit ( calt , periodField , baseDate ) ; }
( CalendarDate date ) { if ( date . equals ( baseDate ) ) return 0.0 ; return date . getDifference ( baseDate , periodField ) ; }
makeCalendarDate ( double value ) { if ( isCalendarField ) return baseDate . add ( CalendarPeriod . of ( ( int ) value , periodField ) ) ; else return baseDate . add ( value , periodField ) ; }
a QuantityDimension .
if a file is valid .
the stn names from a file .
the data .
( LayoutRegular index , Variable v2 ) throws IOException { int [ ] var = ( int [ ] ) ( v2 . read ( ) . get1DJavaArray ( v2 . getDataType ( ) ) ) ; int [ ] data = new int [ ( int ) index . getTotalNelems ( ) ] ; while ( index . hasNext ( ) ) { Layout . Chunk chunk = index . next ( ) ; System . arraycopy ( var , chunk . getSrcPos ( ) / 4 , data , ( int ) chunk . getDestElem ( ) , chunk . getNelems ( ) ) ; } return Array . factory ( v2 . getDataType ( ) , new int [ ] { ( int ) index . getTotalNelems ( ) } , data ) ; }
the data from the file .
( short angle ) { if ( angle < 0 ) angle = - angle ; if ( angle > maxval ) angle = maxval ; if ( angle < 0 ) angle = - angle ; if ( angle < maxval ) angle = - angle ; if ( angle < maxval ) angle = - angle ; if ( angle < maxval ) angle = - angle ; if ( angle < maxval ) angle = - angle ; if ( angle < maxval ) angle = - angle ; if ( angle < maxval ) angle = - angle ; if ( angle < maxval ) angle = - angle ; if ( angle < maxval ) angle = - angle ; if ( angle < maxval ) angle = - angle ; return angle ; }
the step of the range .
azim0 and azim1 .
the vNyq of the data .
the Nyquist of a given wave .
( NetcdfDataset ds ) { return builder . makeMathTransform ( ds , timeDim , this ) ; }
the debug flags .
the index file mode .
the data from the grid .
true if the given value is missing from the given value .
getLatLonBoundingBox ( ) { if ( llbb == null ) { if ( ( getXHorizAxis ( ) instanceof CoordinateAxis2D ) && ( getYHorizAxis ( ) instanceof CoordinateAxis2D ) ) { return null ; } CoordinateAxis horizXaxis = getXHorizAxis ( ) ; CoordinateAxis horizYaxis = getYHorizAxis ( ) ; double startLat = horizXaxis . getMinValue ( ) ; double startLon = horizYaxis . getMinValue ( ) ; LatLonPoint llpt = new LatLonPointImpl ( startLat , startLon ) ; llbb = new LatLonRect ( llpt , deltaLat , deltaLon ) ; } return llbb ; }
the structure .
the length of the string .
a string to the specified width .
static String i ( int v , int width ) { return pad ( Integer . toString ( v ) , width , true ) ; }
( long v , int width ) { return pad ( v , width , true ) ; }
the size of the bytes .
a double .
dfrac ( double d , int dec_places ) { System . out . println ( " dfrac ( " + d + " , " + dec_places + " ) = = " + Format . dfrac ( d , dec_places ) ) ; }
the shape of the given shape .
finish ( ) throws DapException { if ( this . first == UNDEFINED ) this . first = 0 ; if ( this . stride == UNDEFINED ) this . stride = 1 ; if ( this . stop == UNDEFINED && this . maxsize != UNDEFINED ) this . stop = this . maxsize ; return this ; }
the length of the array to a string .
a Slice from a Slice .
a Slice to a long .
bytes of the given buffer .
bytes to the buffer .
the type of the EarthEllipsoid .
the type of the EarthEllipsoid .
( NcStreamProto . DataCol dproto ) throws IOException { if ( dproto . getSection ( ) == null ) { return null ; } if ( dproto . getVlensList ( ) . size ( ) == 0 ) { return null ; } if ( dproto . getVlensList ( ) . size ( ) == 0 ) { return null ; } if ( dproto . getVlensList ( ) . size ( ) == 0 ) { return null ; } if ( dproto . getVlensList ( ) . size ( ) == 0 ) { return null ; } if ( dproto . getVlensList ( ) . size ( ) == 0 ) { return null ; } if ( dproto . getVlensList ( ) . size ( ) == 0 ) { return null ; } return dproto . getVlensList ( ) ; }
( NcStreamProto . DataCol dproto , Section parentSection ) throws IOException { if ( parentSection == null ) { parentSection = dproto . getSection ( ) . removeFirst ( parentSection ) ; } if ( parentSection == null ) { parentSection = dproto . getSection ( ) . removeFirst ( parentSection ) ; } if ( parentSection == null ) { parentSection = dproto . getSection ( ) . removeFirst ( parentSection ) ; } if ( parentSection == null ) { parentSection = dproto . getSection ( ) . removeFirst ( parentSection ) ; } if ( parentSection == null ) { parentSection = dproto . getSection ( ) . removeFirst ( parentSection ) ; } return parentSection ; }
URLs from the given URL .
the text content from the given URL .
out meta tags .
the data into a byte channel .
public void addAll ( Iterable < Attribute > atts ) { for ( Attribute att : atts ) addAttribute ( att ) ; }
the attribute from the attribute list .
removeAttributeIgnoreCase ( String attName ) { Attribute att = findAttributeIgnoreCase ( attName ) ; return att != null && atts . remove ( att ) ; }
offsets in time units .
an ActionSourceListener to the ActionCoordinator .
the standard date from the given text .
the standard date from the given text .
the origin of a TimeScaleUnit .
the date of the given value .
a new Date from the given value .
the value of the given date .
the standard date string .
the grid spacing for the given type .
dimensions to the netcdf file .
a coordinate axis to the netcdf file .
a projection for the given grid table .
a GDS param to a variable .
a coordinate system variable to the netcdf file .
a Lambert conformal .
a polar stereographic .
the mercator .
the latitude and longitude of the earth .
( double startx , double starty , ProjectionImpl proj ) { double Lo2 = gds . getDouble ( GridDefRecord . LO2 ) ; double La2 = gds . getDouble ( GridDefRecord . LA2 ) ; if ( Double . isNaN ( Lo2 ) || Double . isNaN ( La2 ) ) { return ; } LatLonPointImpl startLL = new LatLonPointImpl ( startx , starty ) ; ProjectionPointImpl start = ( ProjectionPointImpl ) proj . latLonToProj ( startLL ) ; ProjectionPointImpl startLL = new ProjectionPointImpl ( startx , starty ) ; ProjectionPointImpl start = ( ProjectionPointImpl ) proj . latLonToProj ( startLL ) ; ProjectionPointImpl end = ( ProjectionPointImpl ) proj . latLonToProj ( startLL ) ; ProjectionPointImpl endLL = new ProjectionPointImpl ( start
a dataset .
dataset scan .
metadata content from a URL .
the level type of the grib level .
if a file is valid .
a byte array .
the clear name .
the coordinate name .
the coordinate name from the dataset .
the XML response .
a DapException .
( NetcdfDataset ds , Variable levelVar ) throws IOException { if ( debugBreakup ) parseInfo . format ( " breakupLevels = % s % n " , levelVar . getShortName ( ) ) ; return null ; }
a Z Coordinate Axis .
a new variable .
a time coordinate axis .
the shave of a float value .
a GribToNetcdf file .
a NetcdfFile into a NetcdfDataset .
openFile ( String location ) throws IOException { DatasetUrl durl = DatasetUrl . findDatasetUrl ( location ) ; return openOrAcquireFile ( null , null , durl , - 1 , cancelTask , null ) ; }
the coordinate systems .
the coordinate axis .
the coordinate axis for a given name .
the coordinate system for a given name .
the coordinate transform for the given name .
enhance ( Set < Enhance > want ) throws IOException { if ( want == null ) return false ; for ( Enhance mode : want ) { if ( ! this . enhanceMode . contains ( mode ) ) return true ; } return false ; }
the data of the given variable .
the values of the Variable .
( DataType dtype , List < String > stringValues ) throws NumberFormatException { return Array . makeArray ( dtype , stringValues ) ; }
the offset of the index .
a MFileOS7 object .
the list of features .
the d array .
a ThreddsMetadata to a ThreddsMetadata .
( String type , String content ) { if ( content == null ) { removeDocumentation ( type ) ; return ; } content = content . trim ( ) ; for ( InvDocumentation doc : getDocumentation ( ) ) { String dtype = doc . getType ( ) ; if ( ( dtype != null ) && dtype . equalsIgnoreCase ( type ) ) { doc . setInlineContent ( content ) ; return ; } } addDocumentation ( new InvDocumentation ( null , null , null , type , content ) ) ; }
the documentation from the specified type .
( long start ) { if ( start >= segMax [ segno ] ) segno ++ ; return ( int ) ( segMax [ segno ] - start ) ; }
whether a given coordinate is within a given dimension .
a file to the dataset .
( String convAttValue ) { if ( convAttValue . indexOf ( ' , ' ) > 0 ) { StringTokenizer stoke = new StringTokenizer ( convAttValue , " , " ) ; while ( stoke . hasMoreTokens ( ) ) { String name = stoke . nextToken ( ) ; names . add ( name . trim ( ) ) ; } } else if ( convAttValue . indexOf ( ' ; ' ) > 0 ) { StringTokenizer stoke = new StringTokenizer ( convAttValue , " , ; " ) ; while ( stoke . hasMoreTokens ( ) ) { String name = stoke . nextToken ( ) ; names . add ( name . trim ( ) ) ; } } else if ( convAttValue . indexOf ( ' / ' ) > 0 ) { StringTokenizer stoke = new StringTokenizer ( convAttValue , " / " ) ; while ( stoke . hasMoreTokens ( ) ) { String name = stoke . nextToken ( ) ; names . add
a convention attribute .
coordinate systems .
( List < VarProcess > varList ) { for ( VarProcess vp : varList ) { if ( vp . coordAxes != null ) findCoordinateAxes ( vp , vp . coordAxes ) ; if ( vp . coordinates != null ) findCoordinateAxes ( vp , vp . coordinates ) ; } }
coordSystems in the dataset .
( ) { for ( VarProcess vp : varList ) { if ( vp . isCoordinateSystem ) { vp . makeCoordinateSystem ( ) ; } } }
a maximal CoordSystem for a given variable .
the coordinate axis for the given variable .
coordinate variable to coordVarMap .
a subset of a dataset .
( Dataset topDataset ) { this . topDataset = topDataset ; }
a dataset .
the specified dataset .
the TDS Context .
the count of the given name .
a new symbol to the given name .
a table row with another table row .
( TableRow other , int col , boolean b1 , boolean b2 ) { if ( b1 == b2 ) return compareTie ( other , col ) ; if ( b2 == b1 ) return compareTie ( other , col ) ; if ( b2 == b1 ) return compareTie ( other , col ) ; return compareTie ( other , col ) ; }
the group scope .
a value to a DapAttributeMap .
a valid date range .
the index of the slice .
a new DSP class .
a class to the registry .
the registered DSP class .
the dsp class .
a Grib2Tables from a given Grib2TablesId .
( Grib2Pds pds ) { if ( pds == null ) return GribNumbers . UNDEFINEDD ; if ( pds . getTimeIntervals ( ) . size ( ) == 0 ) return GribNumbers . UNDEFINEDD ; if ( pds . getTimeIntervals ( ) . size ( ) == 0 ) return GribNumbers . UNDEFINEDD ; if ( pds . getTimeIntervals ( ) . size ( ) == 0 ) return GribNumbers . UNDEFINEDD ; if ( pds . getTimeIntervals ( ) . size ( ) == 0 ) return GribNumbers . UNDEFINEDD ; return GribNumbers . UNDEFINEDD ; }
( Grib2Record gr ) { TimeCoordIntvDateValue tinvd = getForecastTimeInterval ( gr ) ; if ( tinvd == null ) return null ; Grib2Pds pds = gr . getPDS ( ) ; int unit = convertTimeUnit ( pds . getTimeUnit ( ) ) ; TimeCoordIntvValue tinv = tinvd . convertReferenceDate ( gr . getReferenceDate ( ) , Grib2Utils . getCalendarPeriod ( unit ) ) ; return tinv ; }
getVertUnit ( int code ) { if ( code == 0 ) { return new VertCoordType ( code , null , null , true ) ; } if ( code == 1 ) { return new VertCoordType ( code , null , null , true ) ; } if ( code == 2 ) { return new VertCoordType ( code , null , null , true ) ; } if ( code == 3 ) { return new VertCoordType ( code , null , null , true ) ; } if ( code == 4 ) { return new VertCoordType ( code , null , null , true ) ; } if ( code == 5 ) { return new VertCoordType ( code , null , null , true ) ; } if ( code == 6 ) { return new VertCoordType ( code , null , null , true ) ; } if ( code == 7 ) { return new VertCoordType ( code , null , null , true ) ; } if ( code ==
all nodes .
a list of DapNodes .
( int partno ) { try ( GribCollectionImmutable gc = part . getGribCollection ( ) ) { return gc . getDataRaf ( fileno ) ; } }
variable with attribute .
variable with attribute value .
the name of a variable in a NetcdfDataset .
( Structure struct , String attName ) { for ( Variable v : struct . getVariables ( ) ) { Attribute att = v . findAttributeIgnoreCase ( attName ) ; if ( ( att != null ) && att . getStringValue ( ) . equals ( attValue ) ) return v ; } return null ; }
( Structure s ) { for ( Variable v : s . getVariables ( ) ) { if ( v instanceof Structure ) return ( Structure ) v ; } return null ; }
whether a netcdf3 record structure is present .
the literal for the given key .
the feature type of the given dataset .
the variable name from the dataset .
the value of the given coordinate .
to a double .
getCoordValues ( ) { if ( coords == null ) doRead ( ) ; if ( ! isNumeric ( ) ) throw new UnsupportedOperationException ( " CoordinateAxis2D . getCoordValues ( ) on non - numeric " ) ; return coords . get1DJavaArray ( DataType . DOUBLE ) ; }
a CoordinateAxis2D section .
( ArrayDouble . D2 boundsForRun , double target ) { double minDiff = Double . MAX_VALUE ; int idxFound = - 1 ; int n = boundsForRun . getShape ( ) [ 0 ] ; for ( int i = 0 ; i < n ; i ++ ) { double midpoint = ( boundsForRun . get ( i , 0 ) + boundsForRun . get ( i , 1 ) ) / 2.0 ; double diff = Math . abs ( midpoint - target ) ; if ( diff < minDiff ) { minDiff = diff ; idxFound = i ; } } return idxFound ; }
the name of the attribute .
addAction ( String menuName , Action act ) { act . putValue ( Action . NAME , menuName ) ; super . add ( act ) ; return act ; }
match ( String path ) { SortedMap < String , Match > tail = treeMap . tailMap ( path ) ; if ( tail . isEmpty ( ) ) return null ; String after = tail . firstKey ( ) ; if ( path . startsWith ( after ) ) return treeMap . get ( after ) ; for ( String key : tail . keySet ( ) ) if ( path . startsWith ( key ) ) return treeMap . get ( key ) ; for ( String key : tail . keySet ( ) ) { if ( path . startsWith ( key ) ) return treeMap . get ( key ) ; if ( StringUtil2 . match ( path , key ) == 0 ) break ; } return null ; }
a new ProjectionManager object .
the index of the matching byte array .
a picture to the cache .
the cache contents .
( ) { Enumeration e = cacheLoadsInProgress . elements ( ) ; while ( e . hasMoreElements ( ) ) { ( ( SourcePicture ) e . nextElement ( ) ) . stopLoading ( ) ; } }
background loading .
( HTTPSession session , String legalurl ) throws HTTPException { return makemethod ( HTTPSession . Methods . Get , session , legalurl ) ; }
a new HTTPMethod .
( ) throws DapException { TypeSort atomtype = basetype . getTypeSort ( ) ; switch ( atomtype ) { case Float32 : return new float [ ] { random . nextFloat ( ) } ; case Float64 : return new double [ ] { random . nextDouble ( ) } ; default : throw new DapException ( " Unexpected type : " + atomtype ) ; } }
. nextCount ( int max ) throws DapException { Random random = new Random ( ) ; if ( max < min || min < 1 ) throw new DapException ( " bad range " ) ; int range = ( max + 1 ) - min ; int n = random . nextInt ( range ) ; n = n + min ; if ( DEBUG ) System . err . println ( " RandomValue . nextCount : " + n ) ; return n ; }
the data for the given variable .
the provider for the given URI .
station table .
( T gr ) { Integer result = valMap . get ( extract ( gr ) ) ; return ( result == null ) ? 0 : result ; }
the data variable .
the height of the hgt2 meter .
all data from the given section .
the number of colors .
calcTransform ( Rectangle2D screen ) { return new AffineTransform ( ) ; }
uriToAuthScope ( URI uri ) { return new AuthScope ( uri . getHost ( ) , uri . getPort ( ) , AuthScope . ANY_REALM , uri . getScheme ( ) ) ; }
a list of HorizCoordSyss .
boolean isReciprocalOf ( final Factor that ) { return getBase ( ) . equals ( that . getBase ( ) ) && getExponent ( ) == that . getExponent ( ) ; }
( File directory , String filterPattern , boolean sortInIncreasingOrder , boolean addDatasetSize ) { return ( this . getDirCatalog ( directory , filterPattern , sortInIncreasingOrder , null , addDatasetSize , null , null ) ) ; }
the index of the given value .
metadata content from URL .
( InvDataset dataset ) { log . debug ( " readMetadataContent ( ) : . " ) ; return readMetadataContentJdom ( dataset ) ; }
metadata content to the mdataJdom element .
metadata content .
the CatalogGenConfig element .
the dataset source element .
a DatasetNamer element .
a DatasetFilter element .
the result service element .
a catalogGenConfig element .
a dataset source element .
a datasetNamer element .
a dataset filter element .
a result service element .
the flag value from the store .
a JMenu .
a menu to the prefs .
parameters to the template .
a GempakParameter .
getParameter ( String name ) { GempakParameter param = paramMap . get ( name ) ; if ( param == null ) { Set < String > keys = templateParamMap . keySet ( ) ; if ( ! keys . isEmpty ( ) ) { for ( String key : keys ) { Pattern p = Pattern . compile ( key ) ; Matcher m = p . matcher ( name ) ; if ( m . matches ( ) ) { String value = m . group ( 1 ) ; GempakParameter match = templateParamMap . get ( key ) ; param = new GempakParameter ( match . getNumber ( ) , name , match . getDescription ( ) + " ( " + value + " hour ) " , match . getUnit ( ) , match . getDecimalScale ( ) ) ; paramMap . put ( name , param ) ; break ; } } } } return param ; }
the contents of the file .
the content of the InputStream .
( String filespec , int ensIndex ) { return filespec . replaceAll ( ENS_TEMPLATE_ID , getEnsembleNames ( ) . get ( ensIndex ) ) ; }
the station info .
the edited value .
the format information of the JTextField .
the bitmap for the given bitMapIndicator .
data from netcdf file .
the debug flags .
parseName ( String name ) { NamePieces pieces = new NamePieces ( ) ; pieces . name = name ; pieces . prefix = null ; pieces . var = null ; pieces . name = null ; pieces . name = null ; pieces . name = null ; pieces . name = null ; pieces . name = null ; pieces . name = null ; pieces . name = null ; pieces . name = null ; pieces . name = null ; pieces . name = null ; pieces . name = null ; pieces . name = null ; pieces . name = null ; pieces . name = null ; pieces . name = null ; pieces . name = null ; pieces . name = null ; pieces . name = null ; pieces . name = null ; pieces . name = null ; pieces . name = null ; pieces . name = null ; pieces . name = null ; pieces . name = null ; pieces . name = null ; pieces . name = null ; pieces . name
if a DStructure is a group .
( DODSVariable das ) { if ( das == null ) return null ; opendap . dap . Attribute table = das . getAttributeTableN ( v . getFullName ( ) ) ; if ( table == null ) return null ; opendap . dap . Attribute dodsAtt = table . getAttribute ( " DODS " ) ; if ( dodsAtt == null ) return null ; AttributeTable dodsTable = dodsAtt . getContainerN ( ) ; if ( dodsTable == null ) return null ; opendap . dap . Attribute att = dodsTable . getAttribute ( " strlen " ) ; if ( att == null ) return null ; String strlen = att . getValueAtN ( 0 ) ; opendap . dap . Attribute att2 = dodsTable . getAttribute ( " dimName " ) ; if ( att2 == null ) return null ;
( Group group ) { if ( group == null ) group = rootGroup ; for ( Dimension sd : group . getDimensions ( ) ) if ( sd . getShortName ( ) . equals ( d . getShortName ( ) ) && sd . getLength ( ) == d . getLength ( ) ) return sd ; }
( Group group , opendap . dap . DArray dodsArray ) { if ( dodsArray == null || dodsArray . getDimensions ( ) == null || dodsArray . getDimensions ( ) . size ( ) == 0 || dodsArray . getDimensions ( ) . size ( ) == 0 || dodsArray . getDimensions ( ) . size ( ) == 0 || dodsArray . getDimensions ( ) . size ( ) == 0 || dodsArray . getDimensions ( ) . size ( ) == 0 || dodsArray . getDimensions ( ) . size ( ) == 0 || dodsArray . getDimensions ( ) . size ( ) == 0 || dodsArray . getDimensions ( ) . size ( ) == 0 || dodsArray . getDimensions ( ) . size ( ) == 0 ) return null ;
isUnsigned ( opendap . dap . BaseType dtype ) { return ( dtype instanceof DByte ) || ( dtype instanceof DUInt16 ) || ( dtype instanceof DUInt32 ) ; }
readDataDDSfromServer .
the icon of the given class .
getImage ( String fullImageName ) { Image image = null ; java . net . URL url = cl . getResource ( fullImageName ) ; if ( url != null ) image = Toolkit . getDefaultToolkit ( ) . createImage ( url ) ; if ( image == null ) System . out . println ( " ERROR : Resource . getImageResource failed on " + fullImageName ) ; return image ; }
a custom cursor .
the data .
the data .
the data from the layout .
a primitive array .
( byte [ ] byteArray ) { Charset c = CDM . utf8Charset ; CharBuffer output = c . decode ( ByteBuffer . wrap ( byteArray ) ) ; return output . array ( ) ; }
a string to a byte array .
a byte to a char array .
a section from a ParsedSectionSpec .
the array structure of the specified section .
( int recnum , StructureMembers . Member m ) { Array data = m . getDataArray ( ) ; return ( String ) data . getObject ( recnum ) ; }
the scalar structure data .
a ucar . ma2 . Array array .
( DapVariable var ) { if ( var instanceof DapStructure ) { return computemembers ( ( DapStructure ) var ) ; } return computemembers ( var ) ; }
dimensions to NetcdfFile .
a new CrawlableDataset .
the path .
an explicit dataset .
a directory scan to the crawlable dataset .
( CancelTask cancelTask ) throws IOException { this . cancelTask = cancelTask ; }
all datasets in the aggregation .
the nested datasets from the given dataset .
a new dataset .
a resource control .
a point to the list of points .
the bounding box for the given point .
the bounding box .
a DatasetFilter .
true if the dataset matches the given pattern .
a point to the dataset .
( ReqState rs ) throws ParseException { parseConstraint ( rs . getConstraintExpression ( ) , rs . getRequestURL ( ) . toString ( ) ) ; }
a clause .
( PrintWriter pw ) { if ( pw == null ) { pw = new PrintWriter ( ) ; } else { pw = new PrintWriter ( pw ) ; } }
( NetcdfFile ncfile ) throws IOException { String smeta = getStructMetadata ( eosGroup ) ; if ( smeta == null ) { return false ; } HdfEos fixer = new HdfEos ( ) ; fixer . fixAttributes ( ncfile . getRootGroup ( ) ) ; fixer . amendFromODL ( ncfile ) ; }
shared dimensions for a variable .
the length of the given dimension .
findGroupNested ( Group parent , String name ) { for ( Group g : parent . getGroups ( ) ) { if ( g . getShortName ( ) . equals ( name ) ) { return g ; } } return null ; }
the Xlink content .
the standard URI for the given dataset .
the projection of the Projection class .
a constraint to the layout component .
( ) { if ( debug ) System . out . println ( name + " invalidateLayout " ) ; invalidateLayout ( ) ; }
( Component comp ) { if ( debug ) System . out . println ( " removeLayoutComponent " ) ; constraintMap . remove ( comp ) ; }
of a Container .
the container .
isRadialCoordSys ( Formatter parseInfo , CoordinateSystem cs ) { return ( cs . getAzimuthAxis ( ) != null ) && ( cs . getRadialAxis ( ) != null ) && ( cs . getElevationAxis ( ) != null ) ; }
( ) { if ( maxRadial == null ) { try { Array radialData = getRadialAxisDataCached ( ) ; maxRadial = MAMath . getMaximum ( radialData ) ; String units = getRadialAxis ( ) . getUnitsString ( ) ; SimpleUnit radialUnit = SimpleUnit . factory ( units ) ; maxRadial = radialUnit . convertTo ( maxRadial , SimpleUnit . kmUnit ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } catch ( IllegalArgumentException e ) { e . printStackTrace ( ) ; } } return maxRadial ; }
a URL .
the earth from the given geographic lat .
the latitude and longitude of the earth .
GOES to GEOS ( double lamda_goes ) { return GOES_to_GEOS ( lamda_goes ) ; }
the sweep angle axis .
the sweep angle axis .
the coordinates of the runtimes .
a point obs dataset to a file .
pointFeatureDataset ( String fileIn , String fileOut , boolean inMemory ) throws IOException { System . out . println ( " Rewrite pointFeatureDataset ( " + fileIn + " , " + fileOut + " inMemory = " + inMemory + " ) " ) ; }
getArraySequence ( String memberName ) { StructureMembers members = this . members ; if ( memberName == null ) throw new IllegalArgumentException ( " illegal member name = " + memberName ) ; return getArraySequence ( members . findMember ( memberName ) ) ; }
the name of the parent .
the unique ID for the given authority .
getAccess ( ) { return getAccess ( ) ; }
a dataset by name .
( ) { if ( catalog != null ) return catalog ; return null ; }
a list of metadata for a given type .
the given service name .
the variables for the given vocab .
< InvCatalogRef > findAllCatRefsInDatasetTree ( List < InvDataset > datasets , StringBuilder log , boolean onlyRelativeUrls ) { List < InvCatalogRef > catRefList = new ArrayList < InvCatalogRef > ( ) ; for ( InvDataset invds : datasets ) { if ( invds instanceof InvDatasetScan ) catRefList . addAll ( findAllCatRefsInDatasetTree ( invds , log , onlyRelativeUrls ) ) ; } return catRefList ; }
the path for a URL .
a stagger to an array .
a double array into a double array .
computeRho ( double lat ) { return earth_radius * Math . sqrt ( C - 2 * Math . sin ( lat ) ) / n ; }
the detail info .
a structure for a given part .
a missing variable .
a variable for the given GempakParameter .
global attributes to the NetCDF file .
the stnVar size of the given name .
( DataType type , int len ) { if ( type . equals ( DataType . FLOAT ) ) { varArray = new ArrayFloat . D1 ( len ) ; } else if ( type . equals ( DataType . DOUBLE ) ) { varArray = new ArrayDouble . D1 ( len ) ; } else if ( type . equals ( DataType . INT ) ) { varArray = new ArrayInt . D1 ( len ) ; } else if ( type . equals ( DataType . LONG ) ) { varArray = new ArrayLong . D1 ( len ) ; } else if ( type . equals ( DataType . DOUBLE ) ) { varArray = new ArrayDouble . D1 ( len ) ; } else if ( type . equals ( DataType . FLOAT ) ) { varArray = new ArrayFloat . D1 ( len ) ; } else if ( type . equals ( DataType . DOUBLE ) ) { varArray = new ArrayDouble . D1 ( len ) ; }
the state of the yystate .
( int yystate ) { if ( yystate == yylast_ ) return " syntax error " ; if ( yystate == yylast_ ) return " syntax error " ; if ( yystate == yylast_ ) return " syntax error " ; if ( yystate == yylast_ ) return " syntax error " ; }
stack by rule .
DMR data .
the error document .
databuffer .
the header .
isoStringToDate ( String iso ) throws IllegalArgumentException { CalendarDate dt = isoStringToCalendarDate ( null , iso ) ; return dt . toDate ( ) ; }
a table from a URL .
( NetcdfFile ds , NetcdfDataset targetDs , Group srcGroup , ReplaceVariableCheck replaceCheck ) { if ( null == srcGroup ) { srcGroup = new Group ( ds , targetDs , srcGroup . getShortName ( ) ) ; targetGroup . addGroup ( srcGroup ) ; } if ( null == targetGroup ) { targetGroup = new Group ( ds , targetDs , srcGroup . getShortName ( ) ) ; targetGroup . addGroup ( srcGroup ) ; } if ( null == targetGroup ) { targetGroup = new Group ( ds , targetDs , srcGroup . getShortName ( ) ) ; targetGroup . addGroup ( srcGroup ) ; } if ( null == targetGroup ) { targetGroup = new Group ( ds , targetDs , srcGroup . getShortName ( ) ) ; targetGroup . addGroup ( srcGroup ) ; } if ( null == targetGroup ) { targetGroup = new Group ( ds , targetDs
the stn file from the given location .
a new file .
the beginning of the node .
the end of the node .
all runtime collections .
the value of the input field .
the DataType for the given format .
ECFtoLLA ( double latitude , double longitude ) { return ECFtoLLA ( latitude , longitude ) ; }
the unit .
the name .
if a unit is less than one .
a new Notes object .
( VarNotes note ) { return getVarId ( note . gid , note . id , note . fieldIndex ) ; }
( DAS das ) throws IOException { Enumeration tableNames = das . getTableNames ( ) ; while ( tableNames . hasMoreElements ( ) ) { if ( tableNames . hasMoreElements ( ) ) { String tableName = ( String ) tableNames . nextElement ( ) ; AttributeTable attTable = das . getAttributeTable ( tableName ) ; if ( tableName . equals ( " NC _ GLOBAL " ) || tableName . equals ( " HDF _ GLOBAL " ) ) { addAttributeTable ( this , attTable , tableName , true ) ; } else if ( tableName . equals ( " DODS _ EXTRA " ) || tableName . equals ( " EXTRA _ DIMENSION " ) ) { addAttributeTable ( this , attTable , tableName , true ) ; } else if ( tableName . equals ( " DODS _ DIMENSION " ) ) { addAttributeTable ( this , attTable , tableName , true ) ; } else if ( tableName . equals ( " DODS _ DIMENSION
findDodsV ( String name , boolean useDone ) { for ( DodsV dodsV : children ) { if ( useDone && dodsV . isDone ) continue ; if ( ( name == null ) || ( dodsV == null ) || ( dodsV . bt == null ) ) { logger . warn ( " Corrupted structure " ) ; continue ; } if ( name . equals ( dodsV . bt . getEncodedName ( ) ) ) return dodsV ; } return null ; }
( DodsV ddsV ) { if ( ddsV . parent . bt != null ) { DodsV parentV = findDataV ( ddsV . parent ) ; if ( parentV == null ) return findDodsV ( ddsV . bt . getEncodedName ( ) , true ) ; return parentV . findDodsV ( ddsV . bt . getEncodedName ( ) , true ) ; } return null ; }
findByIndex ( int index ) { if ( children . size ( ) <= index ) return null ; return children . get ( index ) ; }
getParentGroup ( ) { Group g = getParentGroup ( ) ; if ( g == null ) { g = ncfile . getRootGroup ( ) ; super . setParentGroup ( g ) ; } return g ; }
the dimensions of the given dimension .
the dimension index of the given name .
the units of a given attribute .
the shape as section .
slice ( int dim , int value ) throws InvalidRangeException { if ( dim < 0 ) || ( dim >= shape . length ) throw new InvalidRangeException ( " Slice dim invalid = " + dim + " for dimension " + dim ) ; if ( value < 0 ) throw new InvalidRangeException ( " Slice value invalid = " + value + " for dimension " + dim ) ; return slice ( dim , value ) ; }
the enum typedef .
an array of ranges .
( ) throws IOException { if ( dataType == DataType . STRING ) return ( String ) data . getObject ( Index . scalarIndexImmutable ) ; else if ( dataType == DataType . CHAR ) { ArrayChar dataC = ( ArrayChar ) data ; return dataC . getString ( ) ; } else throw new IllegalArgumentException ( " readScalarString not STRING or CHAR " + dataType ) ; }
the data from the cache .
a section from the cache .
a CDL file .
the name of the variable .
the dataType to be immutable .
the dimensions of the given shape .
the shape .
the dimensions of a given variable .
dimensions .
the dimensions of the given shape .
the cached data .
a list of all dimensions .
the bounding box .
the grid .
< Dataset > getAllDatasets ( ) { return allDatasets ; }
if the given path is a dsp file .
a CDMDSP .
the DMR .
( Variable cdmvar ) throws DapException { if ( cdmvar . getDataType ( ) == DataType . SEQUENCE ) { buildseqtypes ( cdmvar ) ; } if ( cdmvar . getDataType ( ) == DataType . STRUCTURE || cdmvar . getDataType ( ) == DataType . SEQUENCE ) { buildseqtypes ( cdmvar ) ; } }
( DapVariable dapvar , List < Dimension > cdmdims ) throws DapException { if ( cdmdims == null || cdmdims . size ( ) == 0 ) return ; for ( Dimension cdmdim : cdmdims ) { DapDimension dapdim = null ; if ( cdmdim . isShared ( ) ) { Dimension declareddim = finddimdecl ( cdmdim ) ; if ( declareddim == null ) throw new DapException ( " Unprocessed cdm dimension : " + cdmdim ) ; dapdim = ( DapDimension ) this . nodemap . get ( declareddim ) ; assert dapdim != null ; } else if ( cdmdim . isVariableLength ( ) ) { continue ; } else { dapdim = builddim ( cdmdim ) ; } assert ( dapdim != null ) : " Failed to builddimrefs
the matching enum type .
the core dimset from the given dimset .
( String filename , int indent ) throws Exception { int count = 0 ; try ( RandomAccessFile raf = new RandomAccessFile ( filename , " r " ) ) { MessageScanner scan = new MessageScanner ( raf ) ; while ( scan . hasNext ( ) ) { Message m = scan . next ( ) ; if ( m == null ) continue ; try { if ( showMess ) out . format ( " % sMessage % d header = % s % n " , indent , count , m . getHeader ( ) ) ; count ++ ; Counter counter = new Counter ( ) ; processBufrMessageAsDataset ( scan , m , counter ) ; if ( showMess ) out . format ( " % scount = % d miss = % d % n " , indent , counter . nvals , counter . nmiss ) ; total . add ( counter ) ; } catch ( Exception e ) { if ( showMess ) out . format ( "
( MessageScanner scan , Message m , Counter counter ) throws Exception { byte [ ] mbytes = scan . getMessageBytes ( m ) ; NetcdfFile ncfile = NetcdfFile . openInMemory ( " test " , mbytes , " ucar . nc2 . iosp . bufr . BufrIosp " ) ; Sequence obs = ( Sequence ) ncfile . findVariable ( BufrIosp2 . obsRecord ) ; StructureDataIterator sdataIter = obs . getStructureIterator ( - 1 ) ; processSequence ( obs , sdataIter , counter ) ; }
a file to the server .
the transform .
the map .
a ProjectionRect .
the world to a Point2D .
the map area .
the image .
( ) { if ( debugRecalc ) { System . out . println ( " Navigation recalcFromBoundingBox " ) ; } }
a listener to the list of listeners .
the listener from the list of listeners .
the event to the ListenerManager .
the event to the specified source .
the command to stdout .
a NetcdfFile .
variable data .
variable data section .
the structure data .
( Array ma , PrintWriter out ) { if ( ma . hasNext ( ) ) { out . print ( ma . next ( ) ) ; out . print ( ' ' ) ; } }
( Array array ) { printArray ( array , null , null , pw , new Indent ( 2 ) , null , true ) ; }
a NcML file .
( AttributeContainer v , String attname , double defValue ) { Attribute att = v . findAttributeIgnoreCase ( attname ) ; if ( att == null ) return defValue ; if ( att . isString ( ) ) return Double . parseDouble ( att . getStringValue ( ) ) ; else return att . getNumericValue ( ) . doubleValue ( ) ; }
a parameter to the CoordTransBuilder .
the log file and parses it .
a slice of a DapType .
true if the given level is greater than the given level .
if a unit is compatible with another unit .
a label for the quantityID .
( int bitOffset ) { if ( bitOffset % 8 == 0 ) { raf . seek ( startPos + bitOffset / 8 ) ; bitPos = 0 ; bitBuf = 0 ; } else { raf . seek ( startPos + bitOffset / 8 ) ; bitPos = 8 - ( bitOffset % 8 ) ; bitBuf = ( byte ) raf . read ( ) ; bitBuf &= 0xff >> ( 8 - bitPos ) ; } }
the bits from a byte array .
bits2UInt ( int nb ) throws IOException { long result = bits2UInt ( nb ) ; if ( getBit ( result , nb ) ) { result = setBit ( result , nb , false ) ; result = ~ result & LONG_BITMASK ; result = result + 1 ; } return result ; }
the given URL .
the das from the given path .
the dds of the given CE .
the complete CE .
projToLatLon ( LatLonPointImpl result ) { if ( result == null ) { result = new LatLonPointImpl ( ) ; } return result ; }
the idv dataset catalog .
a new DateRange .
if the file is valid .
satellite information .
the number of samples per band .
the root element from the specified location .
the text .
a string .
a URL query .
a URL query .
a string to a string .
the backslash encoded string .
a lightning global attribute to a Netcdf file .
( byte [ ] b , int offset ) { int low = b [ offset ] & 0xff ; int high = b [ offset + 1 ] & 0xff ; return ( short ) ( high << 8 | low ) ; }
( byte [ ] b , int offset ) { int accum = 0 ; for ( int shiftBy = 0 , i = offset ; shiftBy < 32 ; shiftBy += 8 , i ++ ) { accum |= ( b [ i ] & 0xff ) << shiftBy ; } return accum ; }
( byte [ ] b , int offset ) { long accum = 0 ; long shiftedval ; for ( int shiftBy = 0 , i = offset ; shiftBy < 64 ; shiftBy += 8 , i ++ ) { shiftedval = ( ( long ) ( b [ i ] & 0xff ) ) << shiftBy ; accum |= shiftedval ; } return Double . longBitsToDouble ( accum ) ; }
( float v ) { int l = swapInt ( Float . floatToIntBits ( v ) ) ; return ( Float . intBitsToFloat ( l ) ) ; }
( double v ) { long l = swapLong ( Double . doubleToLongBits ( v ) ) ; return ( Double . longBitsToDouble ( l ) ) ; }
a byte array of short values .
intToBytes ( int v ) { byte [ ] b = new byte [ 4 ] ; int allbits = 255 ; for ( int i = 0 ; i < 4 ; i ++ ) { b [ 3 - i ] = ( byte ) ( ( v & ( allbits << i * 8 ) ) >> i * 8 ) ; } return b ; }
longToBytes ( long v ) { byte [ ] b = new byte [ 8 ] ; long allbits = 255 ; for ( int i = 0 ; i < 8 ; i ++ ) { b [ 7 - i ] = ( byte ) ( ( v & ( allbits << i * 8 ) ) >> i * 8 ) ; } return b ; }
VerticalTransform subset ( Range t_range ) throws ucar . ma2 . InvalidRangeException { return new VerticalTransformSubset ( this , t_range , z_range , y_range , x_range ) ; }
a new XML document .
a new ArrayDouble . D1 .
the schema .
features to a file .
a level to the list .
dimensions to the netcdf file .
a new variable to the netcdf file .
the coordinate transform for a given grid level type .
the index of the record .
DiskCache2 .
the file from the given location .
( String fileLocation ) { File f = new File ( fileLocation ) ; if ( f . exists ( ) ) return f ; return null ; }
the cache files .
the cache .
Bearing ( Earth e ) { return calculateBearing ( e , pt1 . getLatitude ( ) , pt1 . getLongitude ( ) , result ) ; }
( LatLonPoint pt1 , LatLonPoint pt2 ) { return calculateBearing ( pt1 . getLatitude ( ) , pt1 . getLongitude ( ) , pt2 ) ; }
Bearing from a given LatLonPoint .
( Earth e , LatLonPoint pt1 ) { return findPoint ( e , pt1 . getLatitude ( ) , pt1 . getLongitude ( ) , az , dist , result ) ; }
( LatLonPoint pt1 ) { return findPoint ( pt1 . getLatitude ( ) , pt1 . getLongitude ( ) ) ; }
( double lat1 , double lon1 , double az , double dist , LatLonPointImpl result ) { return findPoint ( defaultEarth , lat1 , lon1 , az , dist , result ) ; }
a picture from a URL .
a picture .
Picture .
the loading .
the loading of the image .
the size of the sourcePictureBufferedImage .
void setSourceBufferedImage ( BufferedImage img ) { sourcePictureBufferedImage = img ; setStatus ( READY , statusMessage ) ; }
the standard URI for the given URL .
an associated field .
info from list to list .
the number of bits in the data descriptor .
boolean equals ( Object o ) { if ( this == o ) return true ; if ( o == null || getClass ( ) != o . getClass ( ) ) return false ; if ( getClass ( ) != o . getClass ( ) ) return false ; DataDescriptor that = ( DataDescriptor ) o ; if ( fxy != that . fxy ) return false ; if ( replication != that . replication ) return false ; if ( type != that . type ) return false ; if ( subKeys != null ? ! subKeys . equals ( that . subKeys ) : that . subKeys != null ) return false ; return true ; }
the header .
the data .
( String Name ) { for ( int i = 0 ; i < nfields ; i ++ ) { if ( FieldDesc [ i ] . Name . equals ( Name ) ) return data [ i ] ; } return null ; }
a double [ ] from a DbaseData .
a string from a field .
the booleans from a field .
the name of the field .
the field names .
the Dbase file .
a Map < String , DapAttribute > .
the attribute of the given DapAttribute .
the attributes of the given attribute .
the group of the given sort .
the parent container .
( String shortName ) { this . shortName = shortName ; }
the container path .
the group path .
for a given FQN .
whether the parent is a DATASET or GROUP .
a D4DataCompiler .
( String key , Collection newValue ) { Object oldValue = getBean ( key , null ) ; if ( ( oldValue == null ) || ! oldValue . equals ( newValue ) ) keyValues . put ( key , new Bean . Collection ( newValue ) ) ; }
getList ( String key ) { try { Object bean = getBean ( key , def ) ; return ( List ) bean ; } catch ( Exception e ) { e . printStackTrace ( ) ; return null ; } }
the object from the specified key .
the data from the file .
the given dataset .
a compound instance from a data cursor .
the element to a StringWriter .
to a file .
a stream to the specified element .
the document to the writer .
a private dimension element .
makeCoordinateTransform ( AttributeContainer ctv ) { int [ ] area = getIntArray ( ctv , McIDASAreaProjection . ATTR_AREADIR ) ; int [ ] nav = getIntArray ( ctv , McIDASAreaProjection . ATTR_NAVBLOCK ) ; int [ ] aux = null ; if ( ctv . findAttributeIgnoreCase ( McIDASAreaProjection . ATTR_AUXBLOCK ) != null ) { aux = getIntArray ( ctv , McIDASAreaProjection . ATTR_AUXBLOCK ) ; } McIDASAreaProjection proj = new McIDASAreaProjection ( area , nav , aux ) ; return proj ; }
an array of integers from a given attribute .
a new unit from the given name .
du ( final String name , final String symbol , final Unit definition ) throws NameException { return definition . clone ( UnitName . newUnitName ( name , null , symbol ) ) ; }
a unit to the database .
a derived UnitDB .
a new instance of SI .
( double [ ] target , boolean bounded ) { switch ( axis . getSpacing ( ) ) { case regularInterval : return findCoordElementRegularInterval ( ( target [ 0 ] + target [ 1 ] ) / 2 , bounded ) ; case contiguousInterval : return findCoordElementContiguousInterval ( ( target [ 0 ] + target [ 1 ] ) / 2 , bounded ) ; case discontiguousInterval : return findCoordElementDiscontiguousInterval ( ( target [ 0 ] + target [ 1 ] ) / 2 , bounded ) ; } throw new IllegalStateException ( " unknown spacing " + axis . getSpacing ( ) ) ; }
( double target ) { double minDiff = Double . MAX_VALUE ; double useValue = Double . MIN_VALUE ; int idxFound = 0 ; for ( int i = 0 ; i < axis . getNcoords ( ) ; i ++ ) { double coord = axis . getCoordMidpoint ( i ) ; double diff = Math . abs ( coord - target ) ; if ( diff < minDiff || ( diff == minDiff && coord > useValue ) ) { minDiff = diff ; idxFound = i ; useValue = coord ; } } return idxFound ; }
a subset of all points in the given axis .
openFeatureDataset ( Dataset , ucar . nc2 . util . CancelTask task ) throws IOException { return openFeatureDataset ( null , Dataset , task , new Result ( ) ) ; }
a FeatureDataset .
a Dataset .
the data from the file .
the URI of the given format .
a string to a canonical string .
the units .
a DapDataset .
metadata content from the given xlinkHref .
the value of the given key .
the value to the specified key .
the date of the given month .
XML attributes .
XML attribute value .
if a given attribute is special .
the dimensions of the given variable .
if a file is valid .
( String [ ] dirBlock , String [ ] ad ) { if ( ( dirBlock == null ) || ( ad == null ) ) { return ; } for ( int i = 1 ; i < 14 ; i ++ ) { if ( i == 7 ) { continue ; } v . addAttribute ( new Attribute ( getADDescription ( i ) , dirBlock [ i ] ) ) ; } }
( Variable v ) { if ( navBlock == null ) { return ; } v . addAttribute ( new Attribute ( " navigation _ type " , McIDASUtil . intBitsToString ( navBlock [ 0 ] ) ) ) ; }
getCalType ( String calName ) { int calTypeOut = Calibrator . CAL_NONE ; if ( calName . trim ( ) . equals ( " ALB " ) ) { calTypeOut = Calibrator . CAL_ALB ; } else if ( calName . trim ( ) . equals ( " BRIT " ) ) { calTypeOut = Calibrator . CAL_BRIT ; } else if ( calName . trim ( ) . equals ( " RAD " ) ) { calTypeOut = Calibrator . CAL_RAD ; } else if ( calName . trim ( ) . equals ( " RAW " ) ) { calTypeOut = Calibrator . CAL_RAW ; } else if ( calName . trim ( ) . equals ( " TEMP " ) ) { calTypeOut = Calibrator . CAL_TEMP ; } return calTypeOut ; }
the cal type attribute for the image .
the coordinates of a given axis .
( NetcdfDataset ds , AxisType atype ) { CoordinateAxis coordAxis = findCoordByType ( ds , atype ) ; return coordAxis == null ? null : coordAxis . getFullName ( ) ; }
( NetcdfDataset ds , AxisType atype ) { return findCoordByType ( ds , atype , null ) ; }
( NetcdfDataset ds , AxisType atype , Predicate p ) { CoordinateSystem use = findBestCoordinateSystem ( ds ) ; if ( use == null ) return null ; CoordinateAxis result = findCoordByType ( use . getCoordinateAxes ( ) , atype , p ) ; if ( result != null ) return result ; return findCoordByType ( ds . getCoordinateAxes ( ) , atype ) ; }
( NetcdfDataset ds , AxisType atype ) { CoordinateAxis axis = findCoordByType ( ds , atype ) ; if ( axis == null ) return null ; if ( axis . isScalar ( ) ) return null ; return axis . getDimension ( 0 ) ; }
( NetcdfDataset ds ) { CoordinateSystem use = null ; for ( CoordinateSystem cs : ds . getCoordinateSystems ( ) ) { if ( use == null ) use = cs ; else if ( cs . getCoordinateAxes ( ) . size ( ) > use . getCoordinateAxes ( ) . size ( ) ) use = cs ; } return use ; }
the CoverageCoordAxis1D for the independent axis .
the variable from the given name .
the deserialized data .
the marker .
( DataOutputStream sink , byte marker ) throws IOException { sink . writeByte ( marker ) ; sink . writeByte ( ( byte ) 0 ) ; sink . writeByte ( ( byte ) 0 ) ; }
a SAXParseException .
a new TimeSeries .
a single axis chart .
a String array .
a DoradePARM .
( java . util . List stns ) { stnRender . setStations ( stns ) ; redraw ( true ) ; }
the selected station .
a rectangle to the screen .
the rect of the object .
the x and y coordinates of the rectangle .
a new UnitDBImpl to the existing UnitDBImpl .
a unit to a given name .
a symbol to the alias .
a unit from a given id .
a new unit .
a new unit to the given symbol .
a new unit to the map .
a JMenuItem to the menu .
( RandomAccessFile raf , long drsPos ) throws IOException { if ( raf . getFilePointer ( ) > drsPos ) return null ; if ( raf . getFilePointer ( ) > drsPos ) return null ; if ( raf . getFilePointer ( ) > drsPos ) return null ; if ( raf . getFilePointer ( ) > drsPos ) return null ; if ( raf . getFilePointer ( ) > drsPos ) return null ; if ( raf . getFilePointer ( ) > drsPos ) return null ; if ( raf . getFilePointer ( ) > drsPos ) return null ; if ( raf . getFilePointer ( ) > drsPos ) return null ; if ( raf . getFilePointer ( ) > drsPos ) return null ; if ( raf . getFilePointer ( ) > drsPos ) return null ; if ( raf . getFilePointer ( ) > drsPos ) return null ; return null ; }
a structure .
the given dataset .
the values from the given data .
a new VerticalPerspectiveView .
( InvDataset invDataset , ucar . nc2 . util . CancelTask task ) throws IOException { return openFeatureDataset ( null , invDataset , task , new Result ( ) ) ; }
a feature dataset .
a Netcdf dataset .
the given dataset .
all occurrences of a given property .
a partition for a given variable .
a GribCollectionMutable from the given index .
a RegExpAndDurationTimeCoverageEnhancer .
a RegExpAndDurationTimeCoverageEnhancer .
an XML file to a directory .
the structure data .
the picture from the given filename .
the image to the specified size .
( ) { if ( sclPic . getStatusCode ( ) == sclPic . LOADED ) { sclPic . createScaledPictureInThread ( Thread . MAX_PRIORITY ) ; } }
( Graphics g ) { int WindowWidth = getSize ( ) . width ; int WindowHeight = getSize ( ) . height ; if ( Dragging == false ) { setCursor ( new Cursor ( Cursor . WAIT_CURSOR ) ) ; } else if ( Dragging == true ) { setCursor ( new Cursor ( Cursor . WAIT_CURSOR ) ) ; } else if ( Dragging == true ) { setCursor ( new Cursor ( Cursor . WAIT_CURSOR ) ) ; } }
the number of seconds in the given time .
the gdattim from the intdtf .
the date and time from the idtarr .
the day of the month .
( int ivcord ) { String vcoord = " " ; if ( ( ivcord >= 0 ) && ( ivcord < vertCoords . length ) ) { vcoord = vertCoords [ ivcord ] ; } else if ( ivcord > 100 ) { vcoord = ST_ITOC ( ivcord ) ; } return vcoord ; }
( int [ ] values , int startIndex , int number ) { for ( int i = startIndex ; i < startIndex + number ; i ++ ) { values [ i ] = Integer . reverseBytes ( values [ i ] ) ; } return values ; }
the grid packing type .
the datatype of the given type .
data from the server .
dods data .
the tag for the given code .
( boolean forward ) { if ( forward ) { this . time ++ ; if ( this . time >= this . ntimes ) this . time = 0 ; } }
the size of a DapType .
the sum of all array values .
the grid width and height of the bounding box .
the scale of the overlap .
the grid array .
the given rect .
the intersection of the rect .
intersection of a point in a grid .
( Point2D pt , int offsetX , int offsetY ) { if ( pt == null ) return null ; int indexX = ( int ) ( ( pt . getX ( ) - offsetX ) / gridWidth ) ; int indexY = ( int ) ( ( pt . getY ( ) - offsetY ) / gridHeight ) ; if ( debugClosest ) System . out . println ( " findClosest " + pt + " " + indexX + " " + indexY ) ; if ( ( indexX < 0 ) || ( indexX >= countX ) || ( indexY < 0 ) || ( indexY >= countY ) ) return null ; GridCell gwant = gridArray [ indexY ] [ indexX ] ; if ( gwant . used ) return gwant . o ; return null ; }
the distance from the given point .
a new base unit .
for the given fragment .
the service type for the given URL .
the service type of the given path .
the service type for the given location .
the service type for the given location .
the data to the specified section .
the fqn suffix of the specified struct .
the fqn prefix .
the path of the current file .
a file relative to a given path .
a byte [ ] from a ByteBuffer .
the structure path of a DapVariable .
nullify ( String path ) { return ( path != null && path . length ( ) == 0 ? null : path ) ; }
a string with a separator .
if the given path is a drive letter .
a list of all protocols .
toSlices ( Index indices , DapVariable template ) throws dap4 . core . util . DapException { List < DapDimension > dims = template . getDimensions ( ) ; List < Slice > slices = indexToSlices ( indices , dims ) ; return slices ; }
to slices .
whether a slice is contiguous or not .
a single point from a list of slices .
slices to index .
the data from the netcdf file .
the station information .
( String latVName , String lonVName , String altVName , String obsTimeVName , String nomTimeVName ) { this . latVName = latVName ; this . lonVName = lonVName ; this . altVName = altVName ; }
the config from the catalog .
a new decl to a DapGroup .
groups .
a variable in a group .
the axis type for the given variable .
the GribStatType for the given timeRangeIndicator .
lon axis .
the ranges of the axis .
the default properties .
the session id .
( int n ) { if ( n < 0 ) throw new IllegalArgumentException ( " setMaxRedirects " ) ; localsettings . put ( Prop . MAX_REDIRECTS , n ) ; return this ; }
setUseSessions ( boolean tf ) { localsettings . put ( Prop . USESESSIONS , tf ) ; this . cachevalid = false ; return this ; }
the connection .
( String scope , Map < String , String > localcreds , Map < String , String > globalcredfactories ) throws HTTPException { if ( authcontrols . containsKey ( AuthProp . SSLFACTORY ) ) this . sessioncontext . setSSLSocketFactory ( ( SSLConnectionSocketFactory ) authcontrols . get ( AuthProp . SSLFACTORY ) ) ; else this . sessioncontext . setCredentialsProvider ( new BasicCredentialsProvider ( ) ) ; }
a session .
static void setGlobalCredentialsProvider ( AuthScope scope , CredentialsProvider provider ) throws HTTPException { setGlobalCredentialsProvider ( provider , scope ) ; }
a URL .
a new Index from the given shape .
the strides of the shape .
the index of the given range .
the index .
the given dimension .
( int index1 , int index2 )
the index .
getIndexIterator ( Array maa ) { if ( fastIterator ) return new IteratorFast ( size , maa ) ; else return new IteratorImpl ( maa ) ; }
the value of the current element .
the index .
the dimension of the current array .
the dimensions of the index .
the time interval name .
makeCalendarDateRange ( ucar . nc2 . time . Calendar cal ) { CalendarDateUnit cdu = CalendarDateUnit . of ( cal , timeUnit . getField ( ) , refDate ) ; return cdu ; }
a list of dates for a given date .
gemparms for the given part .
a list of all the stations of a given station .
a new GempakStation .
the list of station keys .
the dates from a list of dates .
the index of the station .
the type of the file .
indent ( int depth ) { if ( depth < 0 ) depth = 0 ; else if ( depth > MAXDEPTH ) depth = MAXDEPTH ; if ( depth > MAXDEPTH ) depth = MAXDEPTH ; if ( depth > MAXDEPTH ) depth = MAXDEPTH ; if ( depth > MAXDEPTH ) depth = MAXDEPTH ; return depth ; }
the depth of the current line .
the index from the given file .
a directory scan .
if a scan is needed .
first time .
the debug flags .
a new variable .
a file to a Netcdf file .
a valid XmlObject .
a Slice to a String .
original variable .
StructureDS data .
the data from the specified section .
a StructureDS to a StructureDS .
the array to a structure .
( StructureMembers wrapperSm ) { for ( StructureMembers . Member m : wrapperSm . getMembers ( ) ) { Variable orgVar = findVariableFromOrgName ( m . getName ( ) ) ; if ( orgVar != null ) { m . setVariableInfo ( orgVar . getShortName ( ) , orgVar . getDescription ( ) , orgVar . getDataType ( ) ) ; } } }
the variable from the given orgName .
if a variable has data .
enhance ( ) { for ( Variable v : getVariables ( ) ) { VariableEnhanced ve = ( VariableEnhanced ) v ; ve . enhance ( mode ) ; } return this ; }
the resource control for the given path .
an empty sequence .
makeArraySequence ( Sequence seq , List < GempakParameter > params , float [ ] values ) { if ( params == null || params . isEmpty ( ) ) { return makeEmptySequence ( seq ) ; } int numLevels = values . length / params . size ( ) ; StructureMembers members = seq . makeStructureMembers ( ) ; int offset = ArrayStructureBB . setOffsets ( members ) ; int size = offset * numLevels ; byte [ ] bytes = new byte [ size ] ; ByteBuffer buf = ByteBuffer . wrap ( bytes ) ; ArrayStructureBB abb = new ArrayStructureBB ( members , new int [ ] { numLevels } , buf , 0 ) ; int var = 0 ; for ( int i = 0 ; i < numLevels ; i ++ ) { for ( GempakParameter param : params ) { if ( members . findMember ( param . getName ( ) ) != null ) { buf . putFloat ( values [ var ]
a sequence of the given Gempak parameters .
a vertical coordinate attribute to a GempakSoundingFileReader .
( String uriString , CatalogSetCallback callback ) { InvCatalogImpl cat = readXML ( uriString ) ; callback . setCatalog ( cat ) ; }
( String catAsString , URI baseUri ) { return readXML ( new StringReader ( catAsString ) , baseUri ) ; }
an XML file from a URI .
XML to the catalog .
( String key ) { if ( key == null ) return null ; return metadataConverters . get ( key ) ; }
a new UnitName for the given ID .
by the dimension .
by the given dimension .
a float [ ] to a float [ ] .
final boolean isCompatible ( final Unit that ) { final DerivedUnit unit = that . getDerivedUnit ( ) ; return equals ( unit ) || isReciprocalOf ( unit ) ; }
( SimpleGeometry geom ) { if ( geom instanceof Point ) return writePoint ( ( Point ) geom ) ; else if ( geom instanceof Line ) return writeLine ( ( Line ) geom ) ; else if ( geom instanceof Polygon ) return writePolygon ( ( Polygon ) geom ) ; else return null ; }
a point to a gml file .
a LineString .
a polygon to an xml file .
the attributes from the node .
< Node > getSubnodes ( Node parent ) { List < Node > subs = new ArrayList < > ( ) ; NodeList nodes = parent . getChildNodes ( ) ; for ( int i = 0 ; i < nodes . getLength ( ) ; i ++ ) { Node n = nodes . item ( i ) ; if ( n . getNodeType ( ) == Node . ELEMENT_NODE ) subs . add ( n ) ; } return subs ; }
the response root .
a reserved attribute to the node .
getSubsetString ( Variable var , int beginInd , int endInd ) { if ( var == null ) return null ; String subStr = " " ; List < Dimension > dimList = var . getDimensions ( ) ; if ( dimList . size ( ) > 2 || dimList . size ( ) < 1 ) { return null ; } for ( int i = 0 ; i < dimList . size ( ) ; i ++ ) { Dimension dim = dimList . get ( i ) ; if ( dim == null ) continue ; if ( ! CF . TIME . equalsIgnoreCase ( dim . getShortName ( ) ) && ! CF . TIME . equalsIgnoreCase ( dim . getFullName ( ) ) && ! CF . TIME . equalsIgnoreCase ( dim . getFullNameEscaped ( ) ) && ! CF . TIME . equalsIgnoreCase ( dim . getFullNameEscaped ( ) ) && ! CF . TIME . equalsIgnoreCase ( dim . getFullNameEscaped ( ) ) ) { subStr += dim .
a new ArrayStructureMA .
the member array .
a new ArrayStructureMA from the given structure .
the geometry type .
makeStationTimeSeriesFeature ( ) { return new StandardStationTimeSeriesFeatureImpl ( ) ; }
the given CEAST .
filter for the given expression .
a dimension redef to the given node .
public Array createView ( ) { return ArrayObject . factory ( dataType , elementType , isVlen , index , storage ) ; }
true if the bounding box is contained in the bounding box .
a LatLonPoint .
a LatLonRect .
a LatLonRect .
a double array to a double array .
( Array a ) { return conformable ( a . getShape ( ) , b . getShape ( ) ) ; }
whether a shape is conformable to another shape .
an Array to a DataType .
the array .
a boolean array to a boolean array .
the array to a new array .
getMinMax ( Array a ) { IndexIterator iter = a . getIndexIterator ( ) ; double max = - Double . MAX_VALUE ; double min = Double . MAX_VALUE ; while ( iter . hasNext ( ) ) { double val = iter . getDoubleNext ( ) ; if ( Double . isNaN ( val ) ) continue ; if ( val < min ) min = val ; if ( val > max ) max = val ; if ( val < min ) min = val ; if ( val > max ) max = val ; if ( val < min ) min = val ; } return new MinMax ( min , max ) ; }
( Array result , double val ) { IndexIterator iter = result . getIndexIterator ( ) ; while ( iter . hasNext ( ) ) { iter . setDoubleNext ( val ) ; } }
makeCatalogBuilder ( ) { return new CatalogBuilder ( this ) ; }
static ProjectionImpl factory ( Projection proj ) { if ( proj instanceof ProjectionImpl ) { return ( ProjectionImpl ) proj ; } return new ProjectionAdapter ( proj ) ; }
( String id ) { String s ; try { s = unescapeString ( id ) ; } catch ( Exception e ) { s = null ; } return s ; }
a string to a URL .
the URL .
the backslash escape character .
the backslash .
( String escapedName ) { List < String > result = new ArrayList < > ( ) ; if ( escapedName . startsWith ( sep ) ) { result . add ( escapedName . substring ( sep . length ( ) ) ) ; return result ; } if ( escapedName . startsWith ( sep ) ) { result . add ( escapedName . substring ( sep . length ( ) ) ) ; return result ; } if ( escapedName . startsWith ( sep ) ) { result . add ( escapedName . substring ( sep . length ( ) ) ) ; return result ; } return result ; }
the index of the escaped name .
a string to a DAP .
atomic scalar .
the path of the cursor .
the UIDefaults of the given class .
the class of the component .
the data buffer .
a structure array .
a structure .
( DapVariable var , D4Cursor container ) throws DapException { DapSequence dapseq = ( DapSequence ) var . getBaseType ( ) ; D4Cursor seqarray = new D4Cursor ( Scheme . SEQARRAY , this . dsp , var , container ) . setOffset ( getPos ( this . databuffer ) ) ; List < DapDimension > dimset = new ArrayList < DapDimension > ( ) ; dimset . addAll ( var . getDimensions ( ) ) ; dimset . addAll ( var . getDimensions ( ) ) ; dimset . addAll ( var . getDimensions ( ) ) ; dimset . addAll ( var . getDimensions ( ) ) ; dimset . addAll ( var . getDimensions ( ) ) ; dimset . addAll ( var . getDimensions ( ) ) ; dimset . addAll ( var . getDimensions ( ) ) ; dimset . addAll (
a sequence .
( ) throws IOException { readFully ( w , 0 , 8 ) ; return ( long ) ( w [ 7 ] & 0xff ) << 56 | ( long ) ( w [ 6 ] & 0xff ) << 48 | ( long ) ( w [ 5 ] & 0xff ) << 40 | ( long ) ( w [ 4 ] & 0xff ) << 32 | ( long ) ( w [ 3 ] & 0xff ) << 24 | ( long ) ( w [ 2 ] & 0xff ) << 16 | ( long ) ( w [ 1 ] & 0xff ) << 8 | ( long ) ( w [ 0 ] & 0xff ) ; }
the specified field .
the value of the field .
setFieldValue ( String name , Object value ) { Field fld = getField ( name ) ; if ( fld == null ) throw new IllegalArgumentException ( " no field named " + name ) ; fld . setValue ( value ) ; return fld ; }
a field to the cursor .
a CheckBoxField .
a date field .
a double field .
a new field .
a password field .
a TextField to a Field .
addTextComboField ( String fldName , String label , java . util . Collection defValues , int nKeep , boolean editable ) { Field . TextCombo fld = new Field . TextCombo ( fldName , label , defValues , nKeep , storeData ) ; fld . setEditable ( editable ) ; return fld ; }
a TextAreaField .
a heading to the layout .
a LayoutComponent to the layout .
a new LayoutComponent to the layout .
( ) { return findActiveFrame ( ) ; }
the cell spacing .
the factors of a given factor .
[ ] mult ( final Factor [ ] factors1 , final Factor [ ] factors2 ) { if ( factors1 . length == factors2 . length ) { return factors1 ; } if ( factors2 . length == factors1 . length ) { return factors2 ; } if ( factors1 . length == factors2 . length ) { return factors1 ; } if ( factors2 . length == factors1 . length ) { return factors1 ; } if ( factors1 . length == factors2 . length ) { return factors2 ; } if ( factors2 . length == factors1 . length ) { return factors1 ; } if ( factors2 . length == factors1 . length ) { return factors1 ; } if ( factors1 . length == factors2 . length ) { return factors2 ; } if ( factors1 . length == factors2 . length ) { return factors1 ; } if ( factors1 . length == factors2 . length ) { return factors1 ;
the factors of the given power .
whether a given dimension is reciprocal of a given dimension .
whether a factor is dimensionless .
a Grib1ParamTables instance .
factory ( Element paramTableElem ) { if ( paramTableElem == null ) return new Grib1ParamTables ( ) ; return new Grib1ParamTables ( null , new Grib1ParamTableReader ( paramTableElem ) ) ; }
a new lookup table .
a Grib1ParamTableReader to the standard table .
myRaiseTo ( final int power ) throws RaiseException { if ( power == 0 ) { return this ; } if ( power == 1 ) { return this ; } throw new RaiseException ( this ) ; }
a float [ ] to a float [ ] .
the unit table .
a vertical coordinate system .
the name of the file .
( byte [ ] bytes ) { int ndx0 = offset + ( littleEndianData ? 1 : 0 ) ; int ndx1 = offset + ( littleEndianData ? 0 : 1 ) ; return ( short ) ( bytes [ ndx0 ] << 8 | bytes [ ndx1 ] & 0xff ) ; }
an integer from a byte array .
a float from a byte array .
a double from a byte array .
a new unit to the alias .
a new symbol .
public static Converter create ( Unit fromUnit , Unit toUnit ) throws ConversionException { return fromUnit . getConverterTo ( toUnit ) ; }
the structure data .
the point feature data .
a rectangle .
the shape of the GisFeatureRenderer .
the stream .
buffer at the end of the stream .
the number of bytes in the file .
a byte array .
the number of bytes remaining to skip .
dimensions to the netcdf file .
the coord index of the record .
if a file is valid .
a netcdf file .
the data from the file .
one row data .
a new variable from the netcdf dataset .
a scalar variable .
a map area event .
( ProjectionRect ma ) { if ( debugBB ) System . out . println ( " NP . setMapArea " + ma ) ; navigate . setMapArea ( ma ) ; }
( LatLonRect llbb ) { if ( debugBB ) System . out . println ( " NP . setMapArea ( ll ) " + llbb ) ; navigate . setMapArea ( project . latLonToProjBB ( llbb ) ) ; }
latLonCenterMapArea ( double lat , double lon ) { ProjectionPoint center = project . latLonToProj ( lat , lon ) ; ProjectionRect ma = getMapArea ( ) ; ma . setX ( center . getX ( ) - ma . getWidth ( ) / 2 ) ; ma . setY ( center . getY ( ) - ma . getHeight ( ) / 2 ) ; setMapArea ( ma ) ; }
( ProjectionImpl p ) { if ( geoSelection != null ) { LatLonRect geoLL = project . projToLatLonBB ( geoSelection ) ; setGeoSelection ( p . latLonToProjBB ( geoLL ) ) ; } project = p ; }
actions to the menu .
a redraw timer .
newScreenSize ( Rectangle b ) { boolean sameSize = ( b . width == myBounds . width ) && ( b . height == myBounds . height ) ; if ( debugBounds ) System . out . println ( " NavigatedPanel newScreenSize old = " + myBounds ) ; if ( sameSize && ( b . x == myBounds . x ) && ( b . y == myBounds . y ) ) return ; if ( sameSize && ( b . x == myBounds . x ) && ( b . y == myBounds . y ) ) return ; if ( sameSize ) return ; if ( debugBounds ) System . out . println ( " newBounds = " + b ) ; if ( ( b . width > 0 ) && ( b . height > 0 ) ) { bImage = new BufferedImage ( b . width , b . height , BufferedImage . TYPE_INT_RGB ) ; } else { bImage = null ; }
a variable from the tree .
getDouble ( int offset ) { DapVariable d4var = ( DapVariable ) getTemplate ( ) ; long [ ] dimsizes = d4var . getDimensions ( ) ; return getDouble ( DapUtil . offsetToIndex ( offset , dimsizes ) ) ; }
the value of the given index .
the object from the given data .
( int ent_id ) { String name = null ; if ( ent_id == 0 || ent_id == 1 || ent_id == 2 || ent_id == 3 || ent_id == 4 || ent_id == 5 || ent_id == 6 || ent_id == 7 || ent_id == 8 || ent_id == 9 ) { return name ; } if ( ent_id == 0 || ent_id == 4 || ent_id == 5 || ent_id == 6 || ent_id == 7 ) { return name ; } if ( ent_id == 1 || ent_id == 5 || ent_id == 6 || ent_id == 7 ) { return name ; } if ( ent_id == 2 || ent_id == 3 || ent_id == 4 || ent_id == 5 || ent_id == 6 || ent_id == 7 ) { return name ; } if ( ent_id
( ByteBuffer buf ) { if ( buf . hasRemaining ( ) ) { return readScaledInt ( buf ) ; } if ( buf . hasRemaining ( ) ) { return readScaledInt ( buf ) ; } }
the name of the parameter .
hasNext ( ) { if ( this . current >= odomset . size ( ) ) return false ; Odometer ocurrent = odomset . get ( this . current ) ; if ( ocurrent . hasNext ( ) ) return true ; this . current ++ ; return hasNext ( ) ; }
( ) { String arch = System . getProperty ( " os . arch " ) ; if ( arch . equals ( " x86" ) || arch . equals ( " arm " ) || arch . equals ( " x86_64" ) || arch . equals ( " alpha " ) ) { bigEndian = true ; } else if ( arch . equals ( " x86_64" ) || arch . equals ( " arm64" ) ) { bigEndian = false ; } else if ( arch . equals ( " x86_64" ) ) { bigEndian = true ; } else if ( arch . equals ( " x86_64" ) ) { bigEndian = true ; } else if ( arch . equals ( " x86_64" ) ) { bigEndian = true ; } else if ( arch . equals ( " arm64" ) ) { bigEndian = true ; } else if ( arch . equals ( " x86_64" ) ) { bigEndian = true ; } else if ( arch
the time steps per file .
the name of the data file .
the file names from the given data file .
( String ddFile ) { String pathToDDF = null ; if ( ddFile != null && ddFile . length ( ) > 0 ) { pathToDDF = ddFile . substring ( 0 , ddFile . length ( ) - 1 ) ; } else if ( ddFile != null && ddFile . length ( ) > 0 ) { pathToDDF = ddFile . substring ( 0 , ddFile . length ( ) - 1 ) ; } return pathToDDF ; }
the full path of the given filename .
a new Chsub .
the reference date to a TimeCoordIntvValue .
a WMO file .
a byte array of uncompdata .
a special graphic symbol for the given code .
the radius of the circle .
the message header .
the length of the vector arrow .
a text string .
Vector Packet .
the levels of a given level .
the levels of a given short array .
a variable to the netcdf file .
a new variable to the netcdf file .
the uncompressed data .
unsignedByte2Short to unsignedShort .
a byte array to an int .
a byte array to a char array .
the DMR of the given DapRequest .
getRequestState ( HttpServletRequest rq , HttpServletResponse rsp ) throws IOException { if ( getRequestState ( rq , rsp ) != null ) { return getRequestState ( rq , rsp ) ; } return null ; }
an error to the server .
whether the anchor point is stretched .
the stretched point .
a Rectangle containing the stretchedPt .
a Rectangle containing the last point .
dateOnlyFormat ( String text ) throws ParseException { if ( text == null ) text = " " ; dateOnlyFormat ( ) ; return dateOnlyFormat . parse ( text ) ; }
all data variables in the given structure .
that the array size is greater than the size of the attribute .
int2 ( RandomAccessFile raf ) throws IOException { int a = raf . read ( ) ; int b = raf . read ( ) ; return int2 ( a , b ) ; }
the uint value from the file .
int3 ( RandomAccessFile raf ) throws IOException { int a = raf . read ( ) ; int b = raf . read ( ) ; int c = raf . read ( ) ; return int3 ( a , b , c ) ; }
uint2 ( RandomAccessFile raf ) throws IOException { return uint2 ( raf . readInt ( ) , raf . readInt ( ) ) ; }
uint3 ( RandomAccessFile raf ) throws IOException { int a = raf . read ( ) ; int b = raf . read ( ) ; return uint3 ( a , b , c ) ; }
float4 ( ) throws IOException { int a = raf . read ( ) ; int b = raf . read ( ) ; int c = raf . read ( ) ; int d = raf . read ( ) ; return float4 ( a , b , c , d ) ; }
float4 ( int a , int b , int c , int d ) { if ( a < 0 ) { return 0.0f ; } if ( b < 0 ) { return 0.0f ; } if ( c < 0 ) { return 0.0f ; } if ( d < 0 ) { return 0.0f ; } if ( c < 0 ) { return 0.0f ; } if ( d < 0 ) { return 0.0f ; } if ( c < 0 ) { return 0.0f ; } if ( d < 0 ) { return 0.0f ; } if ( c < 0 ) { return 0.0f ; } if ( d < 0 ) { return 0.0f ; } if ( d < 0 ) { return 0.0f ; } if ( c < 0 ) { return 0.0f ; } if ( d < 0 ) { return 0.0f ; } if ( d < 0 ) { return 0.0f ; } if ( d < 0 ) { return 0.0f ; } if (
a long int8 ( RandomAccessFile raf ) throws IOException { int a = raf . read ( ) ; int b = raf . read ( ) ; int c = raf . read ( ) ; int d = raf . read ( ) ; int e = raf . read ( ) ; int f = raf . read ( ) ; int g = raf . read ( ) ; int h = raf . read ( ) ; raf . read ( ) ; raf . read ( ) ; raf . read ( ) ; raf . read ( ) ; raf . read ( ) ; raf . read ( ) ; raf . read ( ) ; }
the number of bits in the bitmap .
a new LambertConformal object .
String toWKS ( ) { StringBuilder sbuff = new StringBuilder ( ) ; sbuff . append ( " PROJCS [ \" " ) . append ( getName ( ) ) . append ( " \" , " ) ; if ( true ) { sbuff . append ( " GEOGCS [ \" WGS 84 \" , " ) ; sbuff . append ( " SPHEROID [ \" WGS 84 \" , 6378137,298.257223563 ] , " ) ; } else { sbuff . append ( " GEOGCS [ \" WGS 84 \" , " ) ; sbuff . append ( " SPHEROID [ \" WGS 84 \" , 6378137,298.257223563 ] , " ) ; } }
a string .
the backslash .
the path of the given string .
makeFmrcInv ( ) { return null ; }
the service for the given path .
the projected components of the array .
the reference time .
new ArrayStructureBBsection ( ArrayStructureBB org ) { if ( org == null || section . computeSize ( ) == org . getSize ( ) ) return org ; return new ArrayStructureBBsection ( org . getStructureMembers ( ) , org . getShape ( ) , org . getByteBuffer ( ) , section ) ; }
the index to a directory .
a Grib1Record .
static boolean isMine ( NetcdfFile ncfile ) { return ( null != ncfile . findGlobalAttribute ( " XORIG " ) ) && ( null != ncfile . findGlobalAttribute ( " YORIG " ) ) && ( null != ncfile . findGlobalAttribute ( " XCELL " ) ) && ( null != ncfile . findGlobalAttribute ( " YCELL " ) ) && ( null != ncfile . findGlobalAttribute ( " NCOLS " ) ) ; }
a UTM projection .
( ) { try { areaReader . af = new AreaFile ( location ) ; } catch ( Throwable e ) { throw new IOException ( e ) ; } }
boolean isBefore ( Date d ) { if ( d == null ) return false ; return date . isBefore ( CalendarDate . of ( d ) ) ; }
true if the given date is before the given date .
true if the given date is after the given date .
the value of the template .
a CoordinateSystem to a var .
the units string .
the units string .
the read mode .
the catalog from the given path .
all datasets .
all Cats in the given directory .
true if the given lon is within the given lon .
the lat string .
lon to lat string .
int compareTo ( final BaseQuantity that ) { int comp ; if ( this == that ) { comp = 0 ; } else { comp = getName ( ) . compareToIgnoreCase ( that . getName ( ) ) ; if ( comp == 0 && getSymbol ( ) != null ) { comp = getSymbol ( ) . compareTo ( that . getSymbol ( ) ) ; } } return comp ; }
the selected dataset .
the selected dataset .
the path of the node .
all catalogs .
the catalog from the specified location .
the selected catalog .
alias for a variable in a NetcdfDataset .
the number of bytes written to the output stream .
characters to the output stream .
the characters from the buffer .
the debug flags .
a member to the list .
the member from the list .
a list of member names .
a member from a list of members .
the bitmap from the given file .
the column widths .
the selected rows .
the model index from the table .
the array of members .
( StructureMembers . Member m ) { Array data = getArray ( m ) ; return data . getDouble ( Index . scalarIndexImmutable ) ; }
( StructureMembers . Member m ) { Array data = getArray ( m ) ; return getJavaArrayDouble ( data ) ; }
( StructureMembers . Member m ) { Array data = getArray ( m ) ; return data . getFloat ( Index . scalarIndexImmutable ) ; }
( StructureMembers . Member m ) { Array data = getArray ( m ) ; return ( float [ ] ) data . getStorage ( ) ; }
( StructureMembers . Member m ) { Array data = getArray ( m ) ; return data . getByte ( Index . scalarIndexImmutable ) ; }
( StructureMembers . Member m ) { Array data = getArray ( m ) ; return ( byte [ ] ) data . getStorage ( ) ; }
( StructureMembers . Member m ) { Array data = getArray ( m ) ; return data . getInt ( Index . scalarIndexImmutable ) ; }
( StructureMembers . Member m ) { Array data = getArray ( m ) ; return ( int [ ] ) data . getStorage ( ) ; }
( StructureMembers . Member m ) { Array data = getArray ( m ) ; return data . getShort ( Index . scalarIndexImmutable ) ; }
( StructureMembers . Member m ) { Array data = getArray ( m ) ; return ( short [ ] ) data . getStorage ( ) ; }
( StructureMembers . Member m ) { Array data = getArray ( m ) ; return data . getLong ( Index . scalarIndexImmutable ) ; }
( StructureMembers . Member m ) { Array data = getArray ( m ) ; return ( long [ ] ) data . getStorage ( ) ; }
( StructureMembers . Member m ) { Array data = getArray ( m ) ; return data . getChar ( Index . scalarIndexImmutable ) ; }
( StructureMembers . Member m ) { Array data = getArray ( m ) ; return ( char [ ] ) data . getStorage ( ) ; }
a dataset to a file .
whether a dataset is useable .
( DatasetNode parent ) { return copyDataset ( parent ) ; }
metadata to a ThreddsMetadata .
the ThreddsMetadata inheritable .
a new record to the database .
the missing record for the given name .
the summary of the record tracker .
the record for the given time .
the records .
the long name of the given parameter .
subsetByIntervals only for longitude .
true if a byte array is equal to another byte array .
the DMR document .
all attributes of a DapDataset .
a new coordinate to the list .
( float [ ] gaussLats ) { log . debug ( " gaussLats { } " , gaussLats ) ; }
parseVariableSelector ( Object parent , String selector ) throws InvalidRangeException { String varNameEsc = null ; String indexSelect = null ; if ( selector != null && selector . length ( ) > 0 ) { varNameEsc = selector . substring ( 0 , selector . length ( ) - 1 ) ; indexSelect = selector . substring ( selector . length ( ) - 1 ) ; } else if ( selector != null && selector . length ( ) > 0 ) { varNameEsc = selector . substring ( 0 , selector . length ( ) - 1 ) ; indexSelect = selector . substring ( selector . length ( ) - 1 ) ; } if ( debugSelector ) System . out . println ( " parseVariableSection < " + selector + " > = < " + varNameEsc + " > , < " + indexSelect + " > " ) ; if ( selector != null && selector . length ( ) > 0 ) { varNameEsc = selector . substring ( selector . length
a section spec string .
whether box9 is within the given rectIndex .
the method stream .
the HTTP method .
( NetcdfDataset ds , EncodingInfo info ) { if ( info . time . getRank ( ) == 0 ) { info . set ( Encoding . single , null , null ) ; return true ; } if ( info . lat . getRank ( ) == 0 ) { info . set ( Encoding . single , null , null ) ; return true ; } if ( info . lat . getRank ( ) == 1 ) { info . set ( Encoding . single , null , null ) ; return true ; } if ( info . lat . getRank ( ) == 1 ) { info . set ( Encoding . single , null , null ) ; return true ; } if ( info . lat . getRank ( ) == 2 ) { info . set ( Encoding . single , null , null ) ; return true ; } if ( info . lat . getRank ( ) == 3 ) { info . set ( Encoding . single , null , null ) ; return true ;
( final CoordinateAxis axis , final Dimension outer ) { if ( axis == null ) return null ; if ( outer == null ) return null ; if ( outer . equals ( axis . getDimension ( 0 ) ) ) return true ; if ( outer . equals ( axis . getDimension ( 1 ) ) ) return true ; if ( outer . equals ( axis . getDimension ( 2 ) ) ) return true ; if ( outer . equals ( axis . getDimension ( 3 ) ) ) return true ; if ( outer . equals ( axis . getDimension ( 4 ) ) ) return true ; if ( outer . equals ( axis . getDimension ( 5 ) ) ) return true ; if ( axis . getParentStructure ( ) != null ) { Structure parent = axis . getParentStructure ( ) ; if ( ( outer != null ) && ( parent . getRank ( ) == 1 ) && ( outer . equals ( parent . getDimension ( 0 ) ) ) ) return true ; } return false ; }
the block CRC .
the current character from the stream .
the progress monitor .
a new URI from the given string .
a new URI from the given URI .
nullify ( String s ) { if ( s != null && s . length ( ) == 0 ) s = null ; return s ; }
the prefix and suffix .
the last modified date .
info to a GribCollectionMutable .
< String > getFilenames ( ) { List < String > result = new ArrayList < > ( ) ; for ( MFile file : fileMap . values ( ) ) result . add ( file . getPath ( ) ) ; Collections . sort ( result ) ; return result ; }
the index filename .
the index file path in the cache .
indexRaf ( ) throws IOException { if ( indexRaf != null ) { indexRaf . close ( ) ; indexRaf = null ; } }
the number of nested counters .
( String name , String value ) { return addGlobalAttribute ( new Attribute ( name , value ) ) ; }
( String name , Array values ) { return addGlobalAttribute ( new Attribute ( name , values ) ) ; }
the global attribute .
a global attribute .
( String varName , String attName ) { addVariableAttribute ( varName , new Attribute ( attName ) ) ; }
a variable attribute .
a variable attribute .
a variable attribute to a new attribute .
a SubType for the GempakStation .
the bounds of the geometries .
the geometry information to a file .
( ) { XMLOutputter fmt = new XMLOutputter ( Format . getPrettyFormat ( ) ) ; return fmt . outputString ( makeStationObsDatasetDocument ( ) ) ; }
( ) throws IOException { XMLOutputter fmt = new XMLOutputter ( Format . getPrettyFormat ( ) ) ; return fmt . outputString ( makeStationCollectionDocument ( ) ) ; }
a DSR to a file .
DXR data to the server .
the error body .
the output stream .
the DXR data .
a new projection .
true if the given number is greater than the given number .
the first element of the array .
( int origin , int stride ) throws InvalidRangeException { if ( origin < 0 ) throw new InvalidRangeException ( origin ) ; if ( origin > stride ) throw new InvalidRangeException ( origin ) ; if ( origin < 0 ) throw new InvalidRangeException ( origin ) ; if ( origin > stride ) throw new InvalidRangeException ( origin ) ; if ( origin < 0 ) throw new InvalidRangeException ( origin ) ; if ( origin > stride ) throw new InvalidRangeException ( origin ) ; if ( origin < stride ) throw new InvalidRangeException ( origin ) ; if ( origin > stride ) throw new InvalidRangeException ( origin ) ; if ( origin < stride ) throw new InvalidRangeException ( origin ) ; if ( origin > stride ) throw new InvalidRangeException ( origin ) ; if ( origin < stride ) throw new InvalidRangeException ( origin ) ; if ( origin > stride ) throw new InvalidRangeException ( origin ) ; if ( origin < stride
the data .
the data .
a BooleanPrimitiveVector .
a list of all catalogs .
DatasetTrackerChronicle .
the values from the given array .
( Section want , int nChunkDim ) throws IOException { return new DataChunkIteratorNoFilter ( want , nChunkDim ) ; }
a double array .
the dataset boundaries .
if a variable is not contained in the requested dataset .
the structure of a given name .
the resource path from the given location .
vertical dimensions to the netcdf file .
a file first header .
a list of all public metadata for a given dataset .
( InvDatasetImpl parent ) { if ( parent == null ) return ; logger . debug ( " inheritFromParent = " + parent . getID ( ) ) ; transfer2PublicMetadata ( parent . getLocalMetadataInheritable ( ) , true ) ; }
metadata to the given dataset .
( InvDatasetImpl fromDs , ThreddsMetadata target ) { if ( fromDs == null ) return ; logger . debug ( " transferInheritedMetadata = " + fromDs . getName ( ) ) ; target . add ( fromDs . getLocalMetadataInheritable ( ) , true ) ; if ( copyInheritedMetadataFromParents ) transferInheritableMetadata ( ( InvDatasetImpl ) fromDs . getParent ( ) , target ) ; }
a list of Contributors .
a new dataset .
a dataset from the catalog .
the existing dataset with the new one .
a service to the list of services .
( InvService service ) { services . remove ( service ) ; for ( InvService nested : service . getServices ( ) ) { services . remove ( nested ) ; } }
the services local .
local metadata .
( Object key ) { if ( userMap == null ) return null ; return userMap . get ( key ) ; }
a valid datasetNamer .
a list of descriptors .
a server path .
and DescribeFeatureTypes .
getFeature ( PrintWriter out , HttpServletRequest hsreq , SimpleGeometryCSBuilder sgcs , String ftName ) { if ( ftName == null ) { return new WFSExceptionWriter ( " Feature Type of " + fullFtName + " not found . " , " GetFeature " , " OperationProcessingFailed " ) ; } return null ; }
a WFSExceptionWriter for the specified request .
the request type .
a document from a given URL .
the length of the object summary .
the lastModified of the object .
the top variables of a DapDataset .
a file from the given path .
a string .
the length of the response .
the request URI .
the request path .
the requested request .
the parameter of the request .
the contents of the catListBox .
a directory to the response .
( DataDescriptor dkey ) { if ( bitPosition == null ) bitPosition = new HashMap < DataDescriptor , Integer > ( 2 * parent . getSubKeys ( ) . size ( ) ) ; bitPosition . put ( dkey , bitOffset ) ; bitOffset += dkey . getBitWidth ( ) ; }
a new BitCounterUncompressed .
the number of bits from the given startBit .
line to TextHistoryPane .
a StationTimeSeriesFeatureCollection document .
the capabilities of the feature dataset .
a record for a given coordinate .
the coordinate of the group .
a new item to the list .
uncaught exception .
slice ( int i ) { if ( i < 0 || i >= this . rank ) throw new IllegalArgumentException ( ) ; return this . slices . get ( i ) ; }
the first position of the slice .
NCEP Table 1 .
the feature type from the endpoint .
( int sw , int type , int set , int val ) { if ( debug ) { System . out . println ( " sw = " + ( char ) sw + " ; type = " + type + " ; set = " + set + " ; val = " + val ) ; } }
factory ( int center ) { if ( center == 7 ) { return factoryNCEP ( gridNumber ) ; } else throw new IllegalArgumentException ( " Dont have predefined GDS " + gridNumber + " from " + center ) ; }
the contents of the input stream to the output stream .
the contents of the file .
the contents of the file .
contents to the file .
the contents of the file .
RafB to RafB .
a directory tree to a new directory .
the contents of the given filename .
a string from a file .
contents to a file .
the contents to a file .
a file out to the specified directory .
( ParseException pe , HttpServletResponse response ) { if ( Debug . isSet ( " showException " ) ) { log . error ( pe . toString ( ) ) ; printThrowable ( pe ) ; } try { BufferedOutputStream eOut = new BufferedOutputStream ( response . getOutputStream ( ) ) ; response . setHeader ( " Content - Description " , " dods - error " ) ; response . setHeader ( " Content - Encoding " , " " ) ; String msg = pe . getMessage ( ) . replace ( ' \n ' , ' \n ' ) . replace ( ' ' , ' \n ' ) . replace ( ' ' , ' \n ' ) . replace ( ' ' , ' \n ' ) . replace ( ' ' , ' \n ' ) . replace ( ' ' , ' \n ' ) . replace ( ' ' , ' \n ' ) . replace ( ' ' , ' \n ' ) . replace ( ' ' , ' \
the dods exception .
a bad URL page .
the dods catalog .
the catalog for this server .
the status of the request .
a list of all OPeNDAP extensions .
( ) { return getReferenceDate ( ) ; }
Vlen data .
the NetcdfDataset NcML .
the netcdf dataset .
the characters in the given string .
a byte array .
the given string .
the given string .
a valid CdmObjectName .
the index of the matched string .
the padded string .
the padded string .
a substring from a string .
the first character from the string .
the last character from the string .
( String s ) { if ( s . isEmpty ( ) ) { return s ; } if ( s . charAt ( s . length ( ) - 1 ) == ' ' ) { return s ; } if ( s . charAt ( s . length ( ) - 1 ) == ' ' ) { return s ; } if ( s . charAt ( s . length ( ) - 1 ) == ' ' ) { return s ; } if ( s . charAt ( s . length ( ) - 1 ) == ' ' ) { return s ; } if ( s . charAt ( s . length ( ) - 1 ) == ' ' ) { return s ; } if ( s . charAt ( s . length ( ) - 1 ) == ' ' ) { return s ; } if ( s . charAt ( s . length ( ) - 1 ) == ' ' ) { return s ; } return s ; }
all occurrences of a given string .
all occurrences of a character in a string .
the string with the given pattern .
the original string .
the original string .
a string from a StringBuilder .
a string with a given character .
a string with a given character .
a string from a given string .
the string .
the collection .
if the state has been updated .
the collection .
Unique GDS and PDS templates .
a list of datasets .
the datasets .
StructureDataDeep copy ( StructureData sdata ) { return new StructureDataDeep ( sdata ) ; }
ArrayStructureBB copyToArrayBB ( ArrayStructure as , ByteOrder bo ) throws IOException { if ( as . getClass ( ) . equals ( ArrayStructureBB . class ) ) { ArrayStructureBB abb = new ArrayStructureBB ( as , as . getShape ( ) ) ; abb . setOffsets ( as . getStructureOffsets ( ) ) ; return abb ; } if ( as . getClass ( ) . equals ( ArrayStructureBB . class ) ) { ArrayStructureBB abb = new ArrayStructureBB ( as , as . getShape ( ) ) ; abb . setOffsets ( as . getStructureOffsets ( ) ) ; return abb ; } if ( as . getClass ( ) . equals ( ArrayStructureBB . class ) ) { ArrayStructureBB abb = new ArrayStructureBB ( as , as . getShape ( ) ) ; abb . setOffsets ( as . getStructureOffsets ( ) ) ; return abb ; } return
( Structure s , ArrayStructure as ) throws IOException { if ( s == null ) return null ; if ( as == null ) return new ArrayStructureBB ( s , as . getShape ( ) ) ; if ( as . getStructureDataIterator ( ) . hasNext ( ) ) return new ArrayStructureBB ( s , as . getShape ( ) ) ; if ( as . getStructureDataIterator ( ) . hasNext ( ) ) return new ArrayStructureBB ( s , as . getShape ( ) ) ; if ( as . getStructureDataIterator ( ) . hasNext ( ) ) return new ArrayStructureBB ( s , as . getShape ( ) ) ; if ( as . getStructureDataIterator ( ) . hasNext ( ) ) return new ArrayStructureBB ( s , as . getShape ( ) ) ; return new ArrayStructureBB ( s , as . getShape ( ) ) ; }
( StructureData sdata ) { return copyToArrayBB ( sdata , new StructureMembers ( sdata . getStructureMembers ( ) ) , ByteOrder . BIG_ENDIAN ) ; }
( StructureData sdata ) { return copyToArrayBB ( sdata , new int [ ] { 1 } ) ; }
( Grib2Pds pds ) { Grib2Pds . PdsInterval pdsIntv = ( Grib2Pds . PdsInterval ) pds ; boolean needOverride = false ; for ( Grib2Pds . TimeInterval ti : pdsIntv . getTimeIntervals ( ) ) { needOverride = ( ti . timeRangeUnit == 255 ) ; } if ( needOverride ) return super . getForecastTimeIntervalSizeInHours ( pds ) ; return super . getForecastTimeIntervalSizeInHours ( pds ) ; }
a CoordinateAxis1D .
a table analyzer .
getFirstFeatureType ( ) { for ( NestedTable nt : leaves ) if ( nt . hasCoords ( ) ) return nt . getFeatureType ( ) ; return null ; }
a table to the dataset .
the grid index .
( String type , int start , int num ) throws IllegalArgumentException { if ( type . equalsIgnoreCase ( GAUST62 ) ) { baseArray = gltst62 ; } else if ( type . equalsIgnoreCase ( GAUST30 ) ) { baseArray = gltst30 ; } else if ( type . equalsIgnoreCase ( GAUST40 ) ) { baseArray = gltst40 ; } else if ( type . equalsIgnoreCase ( GAUSR15 ) ) { baseArray = glts15 ; } else if ( type . equalsIgnoreCase ( GAUSR20 ) ) { baseArray = glts20 ; } else if ( type . equalsIgnoreCase ( GAUSR30 ) ) { baseArray = glts30 ; } else if ( type . equalsIgnoreCase ( GAUSR40 ) ) { baseArray = glats ; } else { throw new IllegalArgumentException ( " Unsupported type : " + type ) ; } return baseArray ; }
( byte [ ] b , int offset ) { long accum = 0 ; long shiftedval ; for ( int shiftBy = 0 , i = offset ; shiftBy < 64 ; shiftBy += 8 , i ++ ) { shiftedval = ( ( long ) ( b [ i ] & 0xff ) ) << shiftBy ; accum |= shiftedval ; } return accum ; }
( byte [ ] b , int offset ) { int accum = 0 ; for ( int shiftBy = 0 , i = offset ; shiftBy < 32 ; shiftBy ++ ) accum |= ( b [ i ] & 0xff ) << shiftBy ; return Float . intBitsToFloat ( accum ) ; }
( byte [ ] b , int offset ) { int low = b [ offset ] & 0xff ; int high = b [ offset + 1 ] & 0xff ; return ( char ) ( high << 8 | low ) ; }
( NetcdfDataset ds ) { for ( VarProcess vp : varList ) { if ( vp . coordAxes == null ) { String coordsString = ds . findAttValueIgnoreCase ( vp . v , CF . COORDINATES , null ) ; if ( coordsString != null ) { vp . coordinates = coordsString ; } } } }
a parameter to the CSMConvention .
commonParent ( Group other ) { if ( other . isParent ( this ) ) return other ; while ( other . isParent ( this ) ) other = other . getParentGroup ( ) ; return other ; }
the parent group .
the parent group .
a dimension to a group .
a dimension to a group .
a new Group .
a new EnumTypedef .
a variable to a group .
the given dimension .
a new group from the given path .
( String attribute ) throws MalformedAliasException { String prefix = " " ; Vector aNames = tokenizeAliasField ( attribute ) ; String topName = ( String ) aNames . get ( 1 ) ; boolean foundIt = false ; Enumeration e = getVariables ( ) ; while ( e . hasMoreElements ( ) ) { BaseType bt = ( BaseType ) e . nextElement ( ) ; String normName = normalize ( bt . getEncodedName ( ) ) ; if ( topName . equals ( normName ) ) foundIt = true ; } return prefix + attribute ; }
a DAS object .
the base type of the given variable .
a grid to a file .
missing values .
( IsMissingEvaluator grid , Array dataMinMax ) { if ( grid . isMissing ( dataMinMax . min ) ) { return null ; } if ( grid . isMissing ( dataMinMax . min ) ) { return null ; } if ( grid . isMissing ( dataMinMax . min ) ) { return null ; } if ( grid . isMissing ( dataMinMax . min ) ) { return null ; } return null ; }
LatLonPoint ( Array lon ) { if ( lon == null ) { return new LatLonPointImpl ( 0 , 0 ) ; } if ( lon == null ) { return new LatLonPointImpl ( 0 , 0 ) ; } if ( lon == null ) { return new LatLonPointImpl ( 0 , 0 ) ; } if ( lon == null ) { return new LatLonPointImpl ( 0 , 0 ) ; } if ( lon == null ) { return new LatLonPointImpl ( 0 , 0 ) ; } if ( lon == null ) { return new LatLonPointImpl ( 0 , 0 ) ; } LatLonPoint p0 = new LatLonPointImpl ( 0 , lon . getFloat ( lonShape [ 0 ] - 1 ) ) ; xlon = p0 . getLongitude ( ) ; while ( lonIter . hasNext ( ) ) { float l = lonIter . getFloatNext ( ) ; LatLonPoint pn = new LatLonPointImpl
data to a GeoReferencedArray .
the exception report .
the nc _ inq _ libvers .
a top index file from the config .
the type of the Grib2CollectionWriter .
the GribCollection .
the GribCdmIndex . updateDirectoryPartition .
( RandomAccessFile raf , FeatureCollectionConfig config , CollectionUpdateType updateType , org . slf4j . Logger logger ) throws IOException { GribCollectionImmutable result ; boolean isGrib1 = false ; boolean isGrib2 = Grib2RecordScanner . isValidFile ( raf ) ; if ( ! isGrib2 ) isGrib1 = Grib1RecordScanner . isValidFile ( raf ) ; if ( isGrib1 || isGrib2 ) { result = openGribCollectionFromDataFile ( isGrib1 , raf , config , updateType , null , logger ) ; raf . close ( ) ; } else { result = openGribCollectionFromIndexFile ( raf , config , logger ) ; } return result ; }
GribCollectionImmutable openGribCollectionFromDataFile ( boolean isGrib1 , RandomAccessFile dataRaf , FeatureCollectionConfig config , CollectionUpdateType updateType , Formatter errlog , org . slf4j . Logger logger ) throws IOException { String filename = dataRaf . getLocation ( ) ; File dataFile = new File ( filename ) ; return openGribCollectionFromDataFile ( isGrib1 , dataFile , updateType , config , errlog , logger ) ; }
( boolean isGrib1 , MFile mfile , CollectionUpdateType updateType , FeatureCollectionConfig config , Formatter errlog , org . slf4j . Logger logger ) throws IOException { MCollection dcm = new CollectionSingleFile ( mfile , logger ) ; dcm . putAuxInfo ( FeatureCollectionConfig . AUX_CONFIG , config ) ; if ( isGrib1 ) { Grib1CollectionBuilder builder = new Grib1CollectionBuilder ( dcm . getCollectionName ( ) , dcm , logger ) ; builder . createIndex ( FeatureCollectionConfig . PartitionType . file , errlog ) ; } else { Grib2CollectionBuilder builder = new Grib2CollectionBuilder ( dcm . getCollectionName ( ) , dcm , logger ) ; builder . createIndex ( FeatureCollectionConfig . PartitionType . file , errlog ) ; builder . createIndex ( FeatureCollectionConfig . PartitionType . file , errlog ) ;
true if the URL matches the given pattern .
a new Triple .
the value of the given key .
the value of the given triple .
the rc file .
a triple into the triplestore .
the list of datasets .
a dataset by its name .
the projection of the project .
the geometry of the given feature set .
the shape of the given feature .
( String string ) { if ( string == null ) { return 0 ; } return getID ( ) . compareToIgnoreCase ( string . substring ( 0 , getID ( ) . length ( ) ) ) ; }
the progress monitor task .
the collection index file .
normalize ( EnsCoord result ) { List < EnsCoord > extra = new ArrayList < > ( ) ; for ( EnsCoord ec : ecList ) { if ( ! result . equalsData ( ec ) ) { extra . add ( ec ) ; } } return result ; }
a new StructureData object .
the structure data .
the structure .
( int recno ) { return getScalarObject ( recno , m ) ; }
scalar to double .
scalar int to int .
( int recnum ) { if ( m . getDataType ( ) != DataType . FLOAT ) throw new IllegalArgumentException ( " Type is " + m . getDataType ( ) + " , must be float " ) ; Array data = m . getDataArray ( ) ; return data . getFloat ( recnum * m . getSize ( ) ) ; }
( int recnum , StructureMembers . Member m ) { if ( ! ( m . getDataType ( ) . getPrimitiveClassType ( ) == byte . class ) ) throw new IllegalArgumentException ( " Type is " + m . getDataType ( ) + " , must be byte " ) ; Array data = m . getDataArray ( ) ; return data . getByte ( recnum * m . getSize ( ) ) ; }
( int recnum , StructureMembers . Member m ) { if ( ! ( m . getDataType ( ) . getPrimitiveClassType ( ) == short . class ) ) throw new IllegalArgumentException ( " Type is " + m . getDataType ( ) + " , must be short " ) ; Array data = m . getDataArray ( ) ; return data . getShort ( recnum * m . getSize ( ) ) ; }
( int recnum , StructureMembers . Member m ) { if ( m . getDataType ( ) != DataType . CHAR ) throw new IllegalArgumentException ( " Type is " + m . getDataType ( ) + " , must be char " ) ; Array data = m . getDataArray ( ) ; return data . getChar ( recnum * m . getSize ( ) ) ; }
a scalar string .
getArrayStructure ( int recnum , StructureMembers m ) { if ( m . getDataType ( ) != DataType . STRUCTURE ) throw new IllegalArgumentException ( " Type is " + m . getDataType ( ) + " , must be Structure or Sequence " ) ; if ( m . getDataType ( ) == DataType . STRUCTURE ) return getArrayStructure ( recnum , m ) ; if ( m . getDataType ( ) == DataType . SEQUENCE ) return getArraySequence ( recnum , m ) ; if ( m . getDataType ( ) == DataType . STRUCTURE ) return getArrayStructure ( recnum , m ) ; if ( m . getDataType ( ) == DataType . STRUCTURE ) return getArrayStructure ( recnum , m ) ; if ( m . getDataType ( ) == DataType . SEQUENCE ) return getArraySequence ( recnum , m ) ; if ( m . getDataType ( ) == DataType . STRUCTURE ) return getArrayStructure ( recnum , m ) ; if ( m . getDataType ( ) == DataType .
getArraySequence ( int recnum ) { if ( m . getDataType ( ) != DataType . SEQUENCE ) throw new IllegalArgumentException ( " Type is " + m . getDataType ( ) + " , must be Sequence " ) ; ArrayObject array = ( ArrayObject ) m . getDataArray ( ) ; return ( ArraySequence ) array . getObject ( recnum ) ; }
an ArrayObject .
if a value is less than or equal to another value .
the value of an expression .
the constraints to a string .
whether a DapNode references a DapDimension or a DapDimension .
a boolean value from a DapVariable .
the expansion count of a DapStructure .
the enums of a given variable .
( ) { for ( int i = 0 ; i < variables . size ( ) ; i ++ ) { List < DapGroup > path = variables . get ( i ) . getGroupPath ( ) ; for ( DapGroup group : path ) { if ( ! this . groups . contains ( group ) ) this . groups . add ( group ) ; } } }
a constraint .
( RandomAccessFile raf ) { return true ; }
the debug flags .
the byte order of the kmachn .
the byte order of the file .
the key for the given name .
the file header info .
the file header of the given name .
a list of parts .
the data pointer for the given part .
the DM _ RFLT file .
DM _ RSTR from a file .
DM_UNPK ( int [ ] ibitst ) { if ( ibitst == null ) { return null ; } if ( ibitst . length == 0 ) { return null ; } if ( ibitst . length == 1 ) { return new PackingInfo ( ) ; } if ( ibitst . length == 2 ) { return new PackingInfo ( ) ; } if ( ibitst . length == 3 ) { return new PackingInfo ( ) ; } return new PackingInfo ( ) ; }
the number of bits in the given integer .
data to the channel .
new BaseType element .
a Grid element .
Aliases .
the key descriptors .
the tree .
( ) { return getEncodedName ( ) ; }
the feature type from the GempakSurfaceFileReader .
true if a and b are equal .
whether a DapNode is a DapNode or a DapNode .
( final String spec ) throws NoSuchUnitException { synchronized ( MUTEX ) { return parse ( spec , UnitDBManager . instance ( ) ) ; } }
static void probeObject ( Object o ) { if ( o == null ) return ; if ( o . getClass ( ) . getSuperclass ( ) . equals ( c . getSuperclass ( ) ) ) return ; if ( o . getClass ( ) . getSuperclass ( ) . equals ( c . getSuperclass ( ) ) ) return ; if ( o . getClass ( ) . getSuperclass ( ) . equals ( c . getSuperclass ( ) ) ) return ; if ( o . getClass ( ) . getSuperclass ( ) . equals ( c . getSuperclass ( ) ) ) return ; if ( o . getClass ( ) . getSuperclass ( ) . equals ( c . getSuperclass ( ) ) ) return ; if ( o . getClass ( ) . getSuperclass ( ) . equals ( c . getSuperclass ( ) ) ) return ; if ( o . getClass ( ) . getSuperclass ( ) . equals ( c . getSuperclass ( ) ) ) return ; if ( o . getClass ( ) . getSuperclass ( ) . equals ( c . getSuperclass ( ) )
if a variable is Tiled .
the best from the given time .
[ ] latLonToProjRect ( LatLonRect latlonR ) { double centerLon = latlonR . getLowerLeftPoint ( ) . getLatitude ( ) ; double height = Math . abs ( latlonR . getUpperRightPoint ( ) . getLatitude ( ) - lat0 ) ; double width = latlonR . getWidth ( ) ; double lon0 = LatLonPointImpl . lonNormal ( latlonR . getLowerLeftPoint ( ) . getLongitude ( ) , centerLon ) ; double lon1 = LatLonPointImpl . lonNormal ( latlonR . getUpperRightPoint ( ) . getLongitude ( ) , centerLon ) ; ProjectionRect [ ] rects = new ProjectionRect [ ] { new ProjectionRect ( ) , new ProjectionRect ( ) } ; if ( lon0 < lon1 ) { rects [ 0 ] . setRect ( lon0 , lat0 , width , height )
a series of logs .
< String , Attribute > makeMap ( List < Attribute > atts ) { int size = ( atts == null ) ? 1 : atts . size ( ) ; Map < String , Attribute > result = new HashMap < > ( size ) ; if ( atts == null ) return result ; for ( Attribute att : atts ) result . put ( att . getShortName ( ) , att ) ; return result ; }
the values .
the numeric value of the given index .
a CDL file .
the value of the attribute .
the type of the attribute .
the values from the array .
a proxy dataset for the current level .
proxyDs resolver catalog .
( Message m ) { if ( ! isScheduled . getAndSet ( true ) ) { executor . submit ( this ) ; } }
for the given dataset .
( thredds . client . catalog . Access invAccess ) { if ( invAccess == null ) { return ; } thredds . client . catalog . Service s = invAccess . getService ( ) ; if ( s . getType ( ) == ServiceType . HTTPServer ) { downloadFile ( invAccess . getStandardUrlName ( ) ) ; return ; } if ( s . getType ( ) == ServiceType . WMS ) { openWMSDataset ( invAccess . getStandardUrlName ( ) ) ; return ; } if ( s . getType ( ) == ServiceType . CdmrFeature ) { openCoverageDataset ( invAccess . getWrappedUrlName ( ) ) ; return ; } thredds . client . catalog . Dataset ds = invAccess . getDataset ( ) ; if ( ds . getFeatureType ( ) == null ) { if ( threddsDataFactory == null ) {
.
the netcdf file .
the GUI .
a new frame .
the name of the axis .
the rank of the coordinate axis .
a coordinate axis .
getProjectionCT ( ) { for ( CoordinateTransform ct : coordTrans ) { if ( ct instanceof ProjectionCT ) return ( ProjectionCT ) ct ; } return null ; }
boolean isGeoXY ( ) { if ( ( xAxis == null ) || ( yAxis == null ) ) return false ; return null != getProjection ( ) && ! ( projection instanceof LatLonProjection ) ; }
if a coordinate axis is regular .
static boolean isSubset ( Collection < Dimension > subset , Collection < Dimension > set ) { for ( Dimension d : subset ) { if ( ! ( set . contains ( d ) ) ) return false ; } return true ; }
whether or not contains a given coordinate axis .
whether a coordinate axis contains a given axis name .
whether the domain contains the given dimension .
a list of AxisTypes from a list of AxisTypes .
the axis type of the coordinate axis .
a DAPNode .
the selected bean .
the selected beans from the JTable .
the selected cells from the JTable .
the selected bean .
state from the preferences file .
a new UnknownUnit from the given name .
the underlying stream .
public boolean isExtra ( Variable v ) { return v != null && extras != null && extras . contains ( v ) ; }
if a coordinate is in the given axis .
( Table . CoordName coordName , Table t , int nestingLevel ) { if ( coordName == null ) return null ; if ( nestingLevel == 0 ) return findCoordinateAxis ( coordName , t . parent , nestingLevel + 1 ) ; if ( nestingLevel == 1 ) return findCoordinateAxis ( coordName , t . parent , nestingLevel + 1 ) ; if ( nestingLevel == 2 ) return findCoordinateAxis ( coordName , t . parent , nestingLevel + 1 ) ; if ( nestingLevel == 3 ) return findCoordinateAxis ( coordName , t . parent , nestingLevel + 2 ) ; if ( nestingLevel == 2 ) return findCoordinateAxis ( coordName , t . parent , nestingLevel + 1 ) ; if ( nestingLevel == 3 ) return findCoordinateAxis ( coordName , t . parent , nestingLevel + 2 ) ; if ( nestingLevel == 2 ) return findCoordinateAxis ( coordName , t . parent , nesting
a list of variables to the table .
a parent join to the cursor .
makeStation ( StructureData stationData ) { if ( stnVE . isMissing ( stationData ) ) return null ; String stationName = stnVE . getCoordValueAsString ( stationData ) ; String stationDesc = ( stnDescVE == null ) ? " " : stnDescVE . getCoordValueAsString ( stationData ) ; String stnWmoId = ( wmoVE == null ) ? " " : wmoVE . getCoordValueAsString ( stationData ) ; return new StationFeatureImpl ( stationName , stationDesc , stnWmoId ) ; }
a new NodeMap for the given CDMNode .
a factory for the given name .
a new SimpleUnit from the given name .
a new unit from the given name .
( String unitString1 ) throws UnitException { UnitFormat format = UnitFormatManager . instance ( ) ; Unit uu1 = format . parse ( unitString1 ) ; Unit uu2 = format . parse ( unitString2 ) ; return uu1 . isCompatible ( uu2 ) ; }
if a date is compatible with a given unit .
boolean isTimeUnit ( String unitString ) { SimpleUnit su = factory ( unitString ) ; return su != null && isTimeUnit ( su . getUnit ( ) ) ; }
( String inputUnitString , String outputUnitString ) { SimpleUnit inputUnit = SimpleUnit . factory ( inputUnitString ) ; SimpleUnit outputUnit = SimpleUnit . factory ( outputUnitString ) ; return inputUnit . convertTo ( 1.0 , outputUnit ) ; }
a double value to a SimpleUnit .
if a given unit is unknown .
the value of a ScaledUnit .
newRelOpClause ( int operator , SubClause lhs , List rhs ) throws DAP2ServerSideException { return new RelOpClause ( operator , lhs , rhs ) ; }
a BoolFunctionClause .
a new BTFunctionClause .
( Array ma , IsMissingEvaluator missEval ) { if ( ma . getRank ( ) < 2 ) return null ; if ( ma . getRank ( ) == 3 ) ma = ma . slice ( 0 , 0 ) ; if ( ma . getRank ( ) == 2 ) ma = ma . slice ( 1 , 0 ) ; if ( ma . getRank ( ) == 2 ) ma = ma . slice ( 2 , 0 ) ; if ( ma . getRank ( ) == 2 ) ma = ma . slice ( 3 , 0 ) ; if ( ma . getRank ( ) == 2 ) ma = ma . slice ( 1 , 0 ) ; if ( ma . getRank ( ) == 2 ) ma = ma . slice ( 0 , 0 ) ; if ( ma . getRank ( ) == 2 ) ma = ma . slice ( 1 , 0 ) ; if ( ma . getRank ( ) == 2 ) ma = ma . slice
all datasetsets .
a dataset .
( InvDataset ds , CancelTask task , PrintWriter out , Object context , boolean release ) { if ( ds instanceof InvCatalogRef ) { InvCatalogRef catref = ( InvCatalogRef ) ds ; catref . release ( ) ; } }
( String fileLocation ) { File result = getExistingFileOrCache ( fileLocation ) ; if ( result != null ) return result ; return getDiskCache ( ) . getFile ( fileLocation ) ; }
( String fileLocation ) { result = getDiskCache2 ( ) . getExistingFileOrCache ( fileLocation ) ; if ( result == null && Grib . debugGbxIndexOnly && fileLocation . endsWith ( " . gbx9 . ncx4" ) ) { int length = fileLocation . length ( ) ; String maybeIndexAlreadyExists = fileLocation . substring ( 0 , length - 10 ) + " . ncx4" ; result = getDiskCache2 ( ) . getExistingFileOrCache ( maybeIndexAlreadyExists ) ; } return result ; }
debugLeaks to true .
< String > getAllFiles ( ) { return allFiles ; }
the file .
to the end of the file .
the buffer .
the data from the file .
readShort ( short [ ] pa ) throws IOException { for ( int i = 0 ; i < n ; i ++ ) { pa [ i ] = readShort ( ) ; } return pa ; }
( long pos ) throws IOException { byte [ ] bb = new byte [ 4 ] ; read_ ( pos , bb , 0 , 4 ) ; read_ ( pos , bb , 0 , 4 ) ; int ch1 = bb [ 0 ] & 0xff ; int ch2 = bb [ 1 ] & 0xff ; int ch3 = bb [ 2 ] & 0xff ; int ch4 = bb [ 3 ] & 0xff ; if ( ( ch1 | ch2 | ch3 | ch4 ) < 0 ) { throw new EOFException ( ) ; } if ( bigEndian ) { return ( ( ch1 << 24 ) + ( ch2 << 16 ) + ( ch3 << 8 ) + ( ch4 ) ) ; } else { return ( ( ch4 << 24 ) + ( ch3 << 16 ) + ( ch2 << 8 ) + ( ch1 ) ) ; } }
( int [ ] pa , int start , int n ) throws IOException { for ( int i = 0 ; i < n ; i ++ ) { pa [ start + i ] = readInt ( ) ; } return pa ; }
readLong ( ) throws IOException { long [ ] pa = new long [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { pa [ i ] = readLong ( ) ; } return pa ; }
( float [ ] pa ) throws IOException { for ( int i = 0 ; i < n ; i ++ ) { pa [ start + i ] = Float . intBitsToFloat ( readInt ( ) ) ; } }
( double [ ] pa ) throws IOException { for ( int i = 0 ; i < n ; i ++ ) { pa [ start + i ] = Double . longBitsToDouble ( readLong ( ) ) ; } }
a string from a byte array .
the length of the string .
( boolean [ ] pa , int start ) throws IOException { for ( int i = 0 ; i < n ; i ++ ) { writeBoolean ( pa [ start + i ] ) ; } }
( short [ ] pa , int start , int n ) throws IOException { writeShort ( pa , start , n ) ; writeShort ( pa , start , n ) ; writeShort ( pa , start , n ) ; writeShort ( pa , start , n ) ; writeShort ( pa , start , n ) ; writeShort ( pa , start , n ) ; writeShort ( pa , start , n ) ; }
( char [ ] pa ) throws IOException { for ( int i = 0 ; i < n ; i ++ ) { writeChar ( pa [ i ] ) ; } }
( int [ ] pa , int start ) throws IOException { writeInt ( pa [ start ] ) ; writeInt ( pa [ start + 1 ] ) ; writeInt ( pa [ start + 2 ] ) ; writeInt ( pa [ start + 3 ] ) ; writeInt ( pa [ start + 4 ] ) ; writeInt ( pa [ start + 5 ] ) ; writeInt ( pa [ start + 6 ] ) ; writeInt ( pa [ start + 7 ] ) ; }
( long [ ] pa ) throws IOException { for ( int i = 0 ; i < n ; i ++ ) { writeLong ( pa [ start + i ] ) ; } }
( float [ ] pa ) throws IOException { for ( int i = 0 ; i < pa . length ; i ++ ) { writeFloat ( pa [ i ] ) ; } }
( double [ ] pa ) throws IOException { for ( int i = 0 ; i < n ; i ++ ) { writeDouble ( pa [ start + i ] ) ; } }
( String s ) throws IOException { int len = s . length ( ) ; for ( int i = 0 ; i < len ; i ++ ) { write ( ( byte ) s . charAt ( i ) ) ; } }
( char b [ ] , int off , int len ) throws IOException { for ( int i = off ; i < len ; i ++ ) { write ( ( byte ) b [ i ] ) ; } }
true if a match is found .
( StringBuffer sbuff ) { if ( template != null ) appendQueryFromTemplate ( sbuff , values ) ; else appendQueryFromParamValue ( sbuff , values ) ; }
a new collection .
the index .
isLeaf ( Path dir ) throws IOException { if ( partitionStatus == PartitionStatus . isLeaf ) { int countDir = 0 , countFile = 0 , count = 0 ; try ( DirectoryStream < Path > dirStream = Files . newDirectoryStream ( dir ) ) { Iterator < Path > iterator = dirStream . iterator ( ) ; while ( iterator . hasNext ( ) && count ++ < 100 ) { Path p = iterator . next ( ) ; BasicFileAttributes attr = Files . readAttributes ( p , BasicFileAttributes . class ) ; if ( attr . isDirectory ( ) ) countDir ++ ; else countFile ++ ; } } return partitionStatus ; }
a list of children from the index .
all the children of the given directory .
the files from the index .
the gridsets of the given gridset .
( FileFactory factory , DatasetUrl durl ) throws IOException { return acquire ( factory , durl , - 1 ) ; }
the CacheElement . CacheFile .
the given hash key .
the file cache .
the integer value of the given integer .
the element in the shadowCache .
the cache .
Vertical Transform .
the latitude and longitude of a coordinate axis .
whether the vertZaxis is positive or negative .
( CoordinateAxis1D horizXaxis , CoordinateAxis1D horizYaxis ) { if ( horizXaxis instanceof CoordinateAxis2D ) { if ( horizYaxis instanceof CoordinateAxis2D ) { if ( g2d == null ) g2d = new GridCoordinate2D ( ( CoordinateAxis2D ) horizYaxis , ( CoordinateAxis2D ) horizXaxis ) ; return g2d . findXYindexFromCoord ( x_coord , y_coord ) ; } return null ; } }
( double x_coord , double y_coord , int [ ] result ) { if ( result == null ) result = new int [ 2 ] ; if ( ( horizXaxis instanceof CoordinateAxis1D ) && ( horizYaxis instanceof CoordinateAxis1D ) ) { if ( g2d == null ) g2d = new GridCoordinate1D ( ( CoordinateAxis1D ) horizYaxis , ( CoordinateAxis1D ) horizXaxis ) ; int [ ] result2 = new int [ 2 ] ; g2d . findCoordElementBounded ( y_coord , x_coord , result2 ) ; result [ 0 ] = result2 [ 1 ] ; result [ 1 ] = result2 [ 0 ] ; return result ; } throw new IllegalStateException ( " GridCoordSystem . findXYindexFromCoord " ) ; }
( double lat , double lon ) { Projection dataProjection = getProjection ( ) ; ProjectionPoint pp = dataProjection . latLonToProj ( new LatLonPointImpl ( lat , lon ) , new ProjectionPointImpl ( ) ) ; return findXYindexFromCoord ( pp . getX ( ) , pp . getY ( ) , result ) ; }
( double lat , double lon , int [ ] result ) { Projection dataProjection = getProjection ( ) ; ProjectionPoint pp = dataProjection . latLonToProj ( new LatLonPointImpl ( lat , lon ) , new ProjectionPointImpl ( ) ) ; return findXYindexFromCoordBounded ( pp . getX ( ) , pp . getY ( ) , result ) ; }
the index of the selected item .
the item of the given pixel .
over MFileCollection .
the list of remote log files .
the name of the subcenter .
a string to a CalendarPeriod . Field .
the CalendarPeriod of the given value .
the CalendarPeriod of the given udunit .
a CalendarDate from a CalendarDate .
a CalendarPeriod to a CalendarPeriod .
the value in millisecs .
the offset of the start and end date .
the file .
the grid parameters .
a dateRootExt to the treeSet .
the longest path match .
the data root for the given path .
the data root to a data root .
( Calendar cal ) { if ( cal == null ) return null ; if ( cal . equals ( Calendar . getDefault ( ) ) ) return dateRange ; return makeCalendarDateRange ( cal ) ; }
the index of the given coordinate .
a new NetcdfFileWriter ( Version version , String location ) throws IOException { return new NetcdfFileWriter ( version , location , false , chunker ) ; }
a new Group .
a typedef to a group .
a group attribute .
a group attribute .
a record structure .
the spiw file .
( Object o ) throws IOException { if ( p == null ) p = BeanParser . getParser ( o . getClass ( ) ) ; p . writeProperties ( o , out ) ; }
metadata from thredds dataset .
( final Unit that ) throws OperationException { return that instanceof OffsetUnit ? getUnit ( ) . divideInto ( ( ( OffsetUnit ) that ) . getUnit ( ) ) : getUnit ( ) . divideInto ( that ) ; }
toDerivedUnit ( final double amount ) throws ConversionException { if ( _unit instanceof DerivableUnit ) { throw new ConversionException ( this , getDerivedUnit ( ) ) ; } return ( ( DerivableUnit ) getUnit ( ) ) . toDerivedUnit ( amount ) ; }
the amount to a derived unit .
a nested variable to an array .
the top variable to an array .
a darray to an array .
all databases .
the database .
to Joda Period .
the capacity of the StringArray .
a string from an array .
a catalog for a directory .
InvCatalogImpl makeProxyDsResolverCatalog ( String path ) { if ( path == null ) return null ; if ( path . endsWith ( " / " ) ) return null ; String dsDirPath = translatePathToLocation ( path ) ; if ( dsDirPath == null ) { log . error ( " makeProxyDsResolverCatalog ( ) : Requesting path < " + path + " > must start with a slash . " ) ; return null ; } if ( dsDirPath . endsWith ( " / " ) ) { log . error ( " makeProxyDsResolverCatalog ( ) : Requesting path < " + path + " > must end with a slash . " ) ; return null ; } if ( dsDirPath . endsWith ( " / " ) ) { log . error ( " makeProxyDsResolverCatalog ( ) : Requesting path < " + path + " > must end with a slash . " ) ; return null ; } if ( dsDirPath . endsWith ( " /
the type of the nested dataset .
a Grib2Pds factory for the given template .
a CalendarDate .
( int scale , int value ) { return ( ( scale == 0 ) || ( scale == 255 ) ) ? value : value * Math . pow ( 10 , - scale ) ; }
( String filename ) throws IOException { try ( InputStream is = new FileInputStream ( filename ) ) { addLocalConcept ( is , conceptName ) ; } }
a local concept to the database .
the line .
the value of the parameter in the table .
a grib1 table .
a lookup table file .
local concepts .
a Grib1 table .
the type of the given name .
( ) throws IOException { this . resultingCatalog = this . createSkeletonCatalog ( prefixUrlPath ) ; }
( ) throws IOException { logger . debug ( " fullExpand ( ) : expanding DatasetSource named ' { } ' . . . " , this . getName ( ) ) ; InvDataset topDs = this . expand ( ) ; InvCatalog generatedCat = topDs . getParentCatalog ( ) ; for ( Iterator it = this . getDatasetEnhancerList ( ) . iterator ( ) ; it . hasNext ( ) ; ) { DatasetEnhancer1 dsE = ( DatasetEnhancer1 ) it . next ( ) ; dsE . addMetadata ( topDs ) ; } logger . debug ( " fullExpand ( ) : naming the datasets . " ) ; this . nameDatasets ( ( InvDatasetImpl ) topDs ) ; logger . debug ( " fullExpand ( ) : sorting the datasets . " ) ; this . sortDatasets ( topDs ) ; return ( generatedCat ) ; }
( InvDatasetImpl datasetContainer ) { if ( datasetContainer . getDatasets ( ) . isEmpty ( ) ) return ; if ( this . isFlatten ( ) ) { logger . debug ( " nameDatasets ( ) : structure is FLAT calling nameDatasetList ( ) " ) ; this . nameDatasetList ( datasetContainer ) ; } }
( InvDatasetImpl dataset ) { InvDatasetImpl namedDs = new InvDatasetImpl ( dataset , " nameDatastList ( ) temp dataset " , null , null , null ) ; dataset . addDataset ( namedDs ) ; DatasetNamer curNamer = null ; for ( int i = 0 ; i < this . datasetNamerList . size ( ) ; i ++ ) { curNamer = ( DatasetNamer ) this . datasetNamerList . get ( i ) ; logger . debug ( " nameDatasetList ( ) : trying namer ( { } ) " , curNamer . getName ( ) ) ; InvDatasetImpl addLevelDs = null ; if ( curNamer . getAddLevel ( ) ) { addLevelDs = new InvDatasetImpl ( null , curNamer . getName ( ) , null , null , null ) ; } dataset . addDataset ( addLevelDs ) ; } }
the dataset tree .
a picture from a URL .
( URL url ) { if ( sourcePicture != null ) { boolean isCurrentlyLoading = sourcePicture . stopLoadingExcept ( url ) ; if ( ! isCurrentlyLoading ) { } PictureCache . stopBackgroundLoadingExcept ( url ) ; } }
the status of the source picture .
( int statusCode , int percentage ) { if ( scalablePictureStatusListeners != null ) { for ( ScalablePictureListener listener : scalablePictureStatusListeners ) { listener . sourceLoadProgressNotification ( statusCode , percentage ) ; } } }
a scaled picture .
the size of the scaled picture .
the size of the scaled picture .
MergedParts ( ) { List < String > list = new ArrayList < > ( ) ; list . add ( SNDT ) ; return list ; }
a header for the given GempakStation .
the types of the given SN_CKUA .
if the given group is valid .
the root directory of the cache .
a root directory .
a new cache file .
the cache files .
the cache .
isBufrTable ( short fxy ) { int f = ( fxy & 0xC000 ) >> 14 ; int x = ( fxy & 0x3F00 ) >> 8 ; int y = ( fxy & 0xFF ) ; return ( f == 0 ) && ( x == 0 ) && ( y < 13 ) ; }
a CoordinateAxis .
the coordinate axis .
boolean isNumeric ( ) { return ( getDataType ( ) != DataType . CHAR ) && ( getDataType ( ) != DataType . STRING ) ; }
the name and dimensions of the axis .
the calendar from the specified attribute .
the list .
the selected row .
the selected row .
the model index of the column .
the index of the z axis .
a sorted string .
( String a [ ] , int i , int j ) { String T ; T = a [ i ] ; a [ i ] = a [ j ] ; a [ j ] = T ; }
a new MFileOS from the given filename .
lonlat .
a new XMLStore .
a new XMLStore from the input stream .
a new XMLStore from the specified resource .
a standard filename for the given appName .
the preferences to a file .
the preferences .
( DataCursor data , SerialWriter dst ) throws IOException { DapVariable template = ( DapVariable ) data . getTemplate ( ) ; assert ( this . ce . references ( template ) ) ; DapType basetype = template . getBaseType ( ) ; List < Slice > slices = ce . getConstrainedSlices ( template ) ; if ( slices == null ) throw new DapException ( " Unknown variable : " + template . getFQN ( ) ) ; Object values = data . read ( slices ) ; dst . writeAtomicArray ( basetype , values ) ; }
a structure to the output stream .
a structure to the output stream .
a sequence .
a record to a DapSequence .
if the file is valid .
the wmo id .
the row number .
the data for the given type .
the data of the Grib2Drs . Type0 .
the data of the Grib2Drs . Type0 .
a scalar object .
a file from the given location .
the size of the grid .
a file .
the stations .
( String name ) { StationUI sui = ( StationUI ) stationHash . get ( name ) ; if ( sui != null ) { setSelectedStation ( name ) ; } }
a station .
the closest station .
the selected station .
( int type ) { String projName ; switch ( type ) { case PSEUDO_MERCATOR : projName = " MERC " ; break ; case PS_OR_LAMBERT_CONIC : projName = ( vals [ 38 ] == vals [ 39 ] ) ? " PS " : " CONF " ; break ; case LAMBERT_CONFORMAL : projName = ( vals [ 38 ] == vals [ 39 ] ) ? " LAMBERT " : " CONF " ; break ; case LAMBERT_CONFORMAL_TANGENT : projName = ( vals [ 38 ] == vals [ 39 ] ) ? " LAMBERT " : " CONF " ; break ; default : projName = " NAV " + type ; } return projName ; }
getStations ( ) throws IOException { return typical . getStations ( ) ; }
the Station for the given name .
( ) throws IOException { return new StationDataIterator ( ) ; }
( ) { return new GetDataIterator ( ) ; }
the data from the file .
the dot of a MAVector .
the norm of the element .
( ) { double norm = norm ( ) ; if ( norm <= 0.0 ) return ; for ( int k = 0 ; k < nelems ; k ++ ) { double val = getDouble ( k ) ; setDouble ( k , norm ) ; } }
the services for the given dataset .
the Grib1 parameter .
( int id ) { if ( parameters == null ) { parameters = readParameterTable ( ) ; } return parameters . get ( id ) ; }
a prefix to the given name .
a symbol to the symbolSet .
the prefix of the given string .
the email of the given source .
the value of the parameter .
the CRC32 of the predefined grid definition .
isThin ( ) { if ( rawData == null ) return false ; int octet5 = getOctet ( 5 ) ; int nv = getOctet ( 4 ) ; return ( octet5 != 255 ) && ( nv == 0 || nv == 255 ) ; }
field index on compound object .
the time range of the forecast product .
the time coord .
the next polygon .
( Polygon prev ) { if ( prev instanceof CFPolygon ) { setPrev ( ( CFPolygon ) prev ) ; } else this . prev = prev ; }
the value of the given property .
the current projection .
a TimeOffsetAxis from a given run date .
( String className ) { this . className = className ; }
a new IOServiceProvider .
a new IOServiceProvider .
true if the iosp class is registered .
( Class iospClass ) { for ( int i = 0 ; i < registeredProviders . size ( ) ; i ++ ) { IOServiceProvider spi = registeredProviders . get ( i ) ; if ( spi . getClass ( ) == iospClass ) { registeredProviders . remove ( i ) ; return true ; } } return false ; }
the location of the file .
( String name , byte [ ] data ) throws IOException , ClassNotFoundException , IllegalAccessException , InstantiationException { ucar . unidata . io . InMemoryRandomAccessFile raf = new ucar . unidata . io . InMemoryRandomAccessFile ( name , data ) ; return new NetcdfFile ( spi , raf , name , null ) ; }
an InMemoryRandomAccessFile .
( String filename ) throws IOException { ByteArrayOutputStream bos = new ByteArrayOutputStream ( ( int ) file . length ( ) ) ; try ( InputStream in = new BufferedInputStream ( new FileInputStream ( filename ) ) ) { IO . copy ( in , bos ) ; } }
( URI uri ) throws IOException { if ( uri . getScheme ( ) . equalsIgnoreCase ( " file " ) ) { return openInMemory ( uri . toString ( ) ) ; } return openInMemory ( uri . toString ( ) ) ; }
( String name ) { for ( Attribute a : gattributes ) { if ( name . equalsIgnoreCase ( a . getShortName ( ) ) ) return a ; } return null ; }
to NcML file .
a CDL file .
a CDL string to the output file .
a CDL file .
addAttribute ( Group parent , Attribute att ) { if ( immutable ) throw new IllegalStateException ( " Cant modify " ) ; if ( parent == null ) parent = rootGroup ; parent . addAttribute ( att ) ; return att ; }
a new attribute to the root group .
a group to the root group .
a dimension to the root group .
a dimension from a group .
a variable to the root group .
a new variable to the given group .
a string variable to the given group .
a variable from a group .
a message to the root group .
a record structure .
the group .
a section .
to ByteChannel .
a list of arrays .
the variable section .
the full name of the node .
( String name ) { name = makeValidPathName ( name ) ; StringBuilder sbuff = new StringBuilder ( ) ; appendGroupName ( sbuff , parent , name ) ; return sbuff . toString ( ) ; }
whether a file includes a filter .
whether a file is excluded or not .
the given file .
a value to the attribute .
the type of the value .
the value to a string .
if the given string is a Byte value .
the short value .
the value of the attribute .
the value of the attribute .
a float value .
the value of the attribute .
the DataType of the attribute .
boolean isViewable ( Dataset ds ) { Access access = ds . getAccess ( ServiceType . WMS ) ; return access != null && ( ThreddsConfig . getBoolean ( " WMS . allow " , false ) ) ; }
if a string is valid .
a valid alphanumeric string .
if alphNumString is a valid alphanumeric string .
if the path is a file or directory .
unicode code point to a hex string .
the value of the given key .
the parameters of a GridDefRecord to a GridDefRecord .
the given input stream .
the message from the given buffer .
quotes from a string .
( Stack s ) { if ( s . size ( ) > 1 ) { s . push ( s . pop ( ) ) ; } }
a NcML file to the specified location .
the value from the ThreddsConfig .
a CDL file .
createStationHelper ( ) { return new StationHelper ( ) ; }
whether the access point header is valid .
the azimuth of the message .
the elevation of the message .
Latitudes from ASIBs .
the longitudes of the ASIB .
the altitude of an ASIB .
azimuths .
the elevations of myRYIBs .
a structure from a list of members .
all members of a given name .
a member variable .
member variables .
( Group group ) { if ( isImmutable ( ) ) throw new IllegalStateException ( " Cant modify " ) ; super . setParentGroup ( group ) ; if ( members != null ) { for ( Variable v : members ) { v . setParentGroup ( group ) ; } } }
the element size .
a structure from an array .
a vector structure .
( ) throws IOException { return getStructureIterator ( ) ; }
the data category from the table .
the name of the class .
void addParameter ( String name , String value ) { atts . add ( new Parameter ( name , value ) ) ; }
the header of the class .
latLonToProjBB2 ( LatLonRect latlonRect ) { ProjectionPoint llpt = latlonRect . getLowerLeftPoint ( ) ; ProjectionPoint urpt = latlonRect . getUpperRightPoint ( ) ; ProjectionPoint lrpt = latlonRect . getLowerRightPoint ( ) ; ProjectionPoint ulpt = latlonRect . getUpperLeftPoint ( ) ; return new ProjectionRect ( minx , miny , maxx , maxy ) ; }
the version of a given convName .
if the vertCoordUnits are positive .
the next file .
the color scale parameters .
.
if the given group is a child of the given group .
the type of the given name .
in all columns .
a CoinbaseBuilder with api key and api secret .
public static Label of ( String value ) { return new Label ( value , false , false , false , false , false , null , null ) ; }
the lines of the given text .
public static Label html ( String value ) { return new Label ( value , true , false , false , false , null , null ) ; }
to Cloud SQL instance .
< String > listIpTypes ( String cloudSqlIpTypes ) { String [ ] rawTypes = cloudSqlIpTypes . split ( " , " ) ; ArrayList < String > result = new ArrayList < > ( rawTypes . length ) ; for ( int i = 0 ; i < rawTypes . length ; i ++ ) { if ( rawTypes [ i ] . trim ( ) . equalsIgnoreCase ( " PUBLIC " ) ) { result . add ( i , " PUBLIC " ) ; } else if ( rawTypes [ i ] . trim ( ) . equalsIgnoreCase ( " PRIMARY " ) ) { result . add ( i , " PRIMARY " ) ; } else { result . add ( i , rawTypes [ i ] . trim ( ) . toUpperCase ( ) ) ; } } return result ; }
the socket to the specified host .
the logger .
the source code .
a compiled class .
a source code to the compiled class .
( ) { read ( ) ; int packed = read ( ) ; header . currentFrame . dispose = ( packed & 0x1c ) >> 2 ; if ( header . currentFrame . dispose == 0 ) { header . currentFrame . dispose = 1 ; } header . currentFrame . transparency = ( packed & 1 ) != 0 ; int delayInHundredthsOfASecond = readShort ( ) ; if ( delayInHundredthsOfASecond < MIN_FRAME_DELAY ) { delayInHundredthsOfASecond = DEFAULT_FRAME_DELAY ; } header . currentFrame . delay = delayInHundredthsOfASecond * 10 ; header . currentFrame . transIndex = read ( ) ; read ( ) ; }
the next frame from the header .
< Person > selectablePersonsProperty ( ) { if ( selectablePersons == null ) { selectablePersons = new SelectableItemList < > ( FXCollections . observableArrayList ( repository . getPersons ( ) ) , person -> person . getFirstName ( ) + " " + person . getLastName ( ) ) ; } return selectablePersons ; }
the list events from the model .
( final int id ) { for ( Person person : persons ) { if ( id == person . getId ( ) ) { return person ; } } return null ; }
a validation message to the given validator .
the person to the welcome string .
a ViewModel into the view .
a ViewModel for the given view .
the list of countries .
the list of subdivisions .
a StringProperty field .
< M > immutableField ( StringGetter < M > getter ) { return addImmutable ( new ImmutableBeanPropertyField < > ( this :: propertyWasChanged , getter , immutableSetter , SimpleStringProperty :: new ) ) ; }
< ViewType , ViewModelType > javaView ( Class < ViewType > viewType ) { return new JavaViewStep < > ( viewType ) ; }
< ViewType , ViewModelType > fxmlView ( Class < ? extends ViewType > viewType ) { return new FxmlViewStep < > ( viewType ) ; }
the map .
the index of the selected item .
the member .
fxml view tuple .
a fxml path .
the style row for the given style mapping .
the pixel value from the image .
the pixel values from the image .
the image type .
a CoverageDataPngImage .
( Bitmap bitmap , CompressFormat format , int quality ) throws IOException { byte [ ] tileData = BitmapConverter . toBytes ( bitmap , format , quality ) ; setTileData ( tileData ) ; }
Cursor rawQuery ( String sql , String [ ] args ) { return db . rawQuery ( sql , args ) ; }
wrapQuery ( String sql , String [ ] selectionArgs ) { return new CursorResult ( rawQuery ( sql ) ) ; }
the result of the previous query .
query ( UserQuery query ) { String sql = query . getSql ( ) ; if ( sql != null ) { cursor = database . rawQuery ( sql , selectionArgs ) ; } return cursor ; }
Cursor to TResult .
the feature row from the given geometry index .
a cursor to a table .
( int x , int y , int zoom ) { return tileDao . queryForTileRow ( x , y ) ; }
Gridded Coverage data .
< ? > getCoverageData ( GeoPackage geoPackage , TileDao tileDao ) { return getCoverageData ( geoPackage , tileDao , null , null ) ; }
( GeoPackage geoPackage , TileDao tileDao , Projection requestProjection ) { return getCoverageData ( geoPackage , tileDao , null , requestProjection ) ; }
getResults ( CoverageDataRequest request , BoundingBox requestProjectedBoundingBox , int overlappingPixels ) { TileMatrix tileMatrix = getTileMatrix ( request ) ; CoverageDataTileMatrixResults results = null ; if ( tileMatrix != null ) { results = getResults ( requestProjectedBoundingBox , tileMatrix , overlappingPixels ) ; if ( results == null ) { results = getResultsZoom ( requestProjectedBoundingBox , tileMatrix , overlappingPixels ) ; if ( results == null ) { results = getResultsZoom ( requestProjectedBoundingBox , tileMatrix , overlappingPixels ) ; } } } return results ; }
the results zoom in and zoom out .
getResultsZoomIn ( BoundingBox requestProjectedBoundingBox , TileMatrix tileMatrix , int overlappingPixels ) { CoverageDataTileMatrixResults results = null ; for ( long zoomLevel = tileMatrix . getZoomLevel ( ) + 1 ; zoomLevel <= tileDao . getMaxZoom ( ) ; zoomLevel ++ ) { TileMatrix zoomTileMatrix = tileDao . getTileMatrix ( zoomLevel ) ; if ( zoomTileMatrix != null ) { results = getResultsZoomIn ( requestProjectedBoundingBox , zoomTileMatrix , overlappingPixels ) ; if ( results != null ) { break ; } } } return results ; }
getResultsZoomOut ( BoundingBox requestProjectedBoundingBox , TileMatrix tileMatrix , int overlappingPixels ) { CoverageDataTileMatrixResults results = null ; for ( long zoomLevel = tileMatrix . getZoomLevel ( ) - 1 ; zoomLevel >= tileDao . getMinZoom ( ) ; zoomLevel -- ) { TileMatrix zoomTileMatrix = tileDao . getTileMatrix ( zoomLevel ) ; if ( zoomTileMatrix != null ) { results = getResultsZoomOut ( requestProjectedBoundingBox , zoomTileMatrix , overlappingPixels ) ; if ( results != null ) { break ; } } } return results ; }
getTileMatrix ( CoverageDataRequest request ) { BoundingBox coverageBoundingBox = request . getCoveringBoundingBox ( ) ; if ( coverageBoundingBox != null ) { TileMatrix tileMatrix = tileDao . getTileMatrix ( coverageBoundingBox ) ; return tileMatrix ; } return null ; }
the value of the gridded tile .
setIcon ( IconRow iconRow , GeometryType geometryType ) { if ( iconRow != null ) { icons . put ( geometryType , iconRow ) ; } else { icons . remove ( geometryType ) ; } }
getIcon ( GeometryType geometryType ) { IconRow iconRow = null ; if ( geometryType != null && ! icons . isEmpty ( ) ) { List < GeometryType > geometryTypes = GeometryUtils . parentHierarchy ( geometryType ) ; geometryTypes . add ( 0 , geometryType ) ; for ( GeometryType type : geometryTypes ) { iconRow = icons . get ( type ) ; if ( iconRow != null ) { break ; } } } return iconRow ; }
the bindings database .
a byte array to a Bitmap .
the bitmap to a byte array .
a table metadata into the database .
the GeometryMetadataDataSource .
a new table with the given geoPackageId .
the id of the GeoPackageMetadataDataSource .
a TableMetadata from the cursor .
a new extension .
getFeatureRow ( UserCustomCursor cursor ) { return getFeatureRow ( cursor ) ; }
a UserCustomCursor .
query ( BoundingBox boundingBox , Projection projection ) { BoundingBox featureBoundingBox = projectBoundingBox ( boundingBox , projection ) ; return query ( featureBoundingBox ) ; }
query ( GeometryEnvelope envelope ) { return query ( envelope . getMinX ( ) , envelope . getMinY ( ) , envelope . getMaxX ( ) , envelope . getMaxY ( ) ) ; }
the count of the envelope .
query ( double minX , double minY , double maxX , double maxY ) { String where = buildWhere ( minX , minY ) ; String [ ] whereArgs = buildWhereArgs ( minX , minY , maxX , maxY ) ; return query ( where , whereArgs ) ; }
where for the RTreeIndexExtension .
the feature bounding box .
the feature bounding box .
query ( GeometryEnvelope envelope ) { return query ( envelope . getMinX ( ) , envelope . getMinY ( ) , envelope . getMaxX ( ) ) ; }
a ManualFeatureQueryResults .
( double minX , double minY , double maxX , double maxY ) { return query ( minX , minY ) . count ( maxX , maxY ) ; }
a bitmap with the given format .
a bitmap to a compressed format .
( ) { if ( options == null ) { options = new Options ( ) ; } options . inPreferredConfig = config ; return options ; }
the tile count for the given zoom .
the bounding box .
( ) { BoundingBox standardWgs84Box = new BoundingBox ( - ProjectionConstants . WGS84_HALF_WORLD_LON_WIDTH , ProjectionConstants . WEB_MERCATOR_MIN_LAT_RANGE , ProjectionConstants . WEB_MERCATOR_MAX_LAT_RANGE ) ; ProjectionTransform wgs84ToWebMercatorTransform = ProjectionFactory . getProjection ( ProjectionConstants . EPSG_WORLD_GEODETIC_SYSTEM ) . getTransformation ( ProjectionConstants . EPSG_WEB_MERCATOR ) ; tileGridBoundingBox = standardWgs84Box . transform ( wgs84ToWebMercatorTransform ) ; }
the WGS84 bounding box .
the bounds of the WebMercator .
getBoundingBox ( ) { BoundingBox boundingBox = null ; TileMatrix tileMatrix = getTileMatrix ( zoomLevel ) ; if ( tileMatrix != null ) { TileGrid tileGrid = queryForTileGrid ( zoomLevel ) ; if ( tileGrid != null ) { BoundingBox matrixSetBoundingBox = getBoundingBox ( ) ; boundingBox = TileBoundingBoxUtils . getBoundingBox ( matrixSetBoundingBox , tileMatrix , tileGrid ) ; } } return boundingBox ; }
getTileGrid ( long zoomLevel ) { TileGrid tileGrid = null ; TileMatrix tileMatrix = getTileMatrix ( zoomLevel ) ; if ( tileMatrix != null ) { tileGrid = new TileGrid ( 0 , 0 , tileMatrix . getMatrixWidth ( ) - 1 , tileMatrix . getMatrixHeight ( ) - 1 ) ; } return tileGrid ; }
the tile row from the database .
the zoom level of the tile .
the zoom level .
( double widths , double heights ) { Long zoomLevel = TileDaoUtils . getApproximateZoomLevel ( widths , heights , tileMatrices , length ) ; return zoomLevel ; }
the tile grid for the given zoom level .
a tile .
the count of the zoom level .
the google tiles for the given tile matrix .
the pixel value of the image .
the pixel values of a TIFF image .
the image type .
a CoverageDataTiffImage .
the first pixel value from the image .
a GeoPackage .
the current row from the table .
moveToNextInvalid ( ) { if ( invalidCursor == null && dao != null && hasInvalidPositions ( ) ) { invalidCursor = createInvalidCursor ( dao , getInvalidPositions ( ) , null ) ; } return invalidCursor ; }
a list of all StyleMapping rows .
the given geometry type .
the rect of the bounding box .
the rect of the bounding box .
( List < String > databases ) { for ( String database : databases ) { if ( exists ( database ) ) { deleteMissingDatabases ( database ) ; } } }
the GeoPackage connection .
a GeoPackage database .
( SQLiteDatabase sqliteDatabase , boolean validateHeader , boolean validateIntegrity ) { validateDatabase ( sqliteDatabase , validateHeader , validateIntegrity , true ) ; }
( SQLiteDatabase sqliteDatabase , boolean validateHeader , boolean validateIntegrity ) { validateDatabase ( sqliteDatabase , validateHeader , validateIntegrity , true ) ; }
the database .
a GeoPackage SQLite header .
whether the database header is valid .
internal databases to the database list .
external databases to the database .
GeoPackage database .
the GeoPackageMetadata for the given database .
the GeoPackageMetadata at the given path .
a geometry metadata .
a GeometryMetadata from a GeometryEnvelope .
the GeometryMetadata table .
( GeometryMetadata metadata ) { boolean success = false ; if ( exists ( metadata ) ) { success = update ( metadata ) ; } else { create ( metadata ) ; success = true ; } return success ; }
the GeometryMetadata table .
count ( String geoPackage , BoundingBox boundingBox ) { return count ( getGeoPackageId ( geoPackage ) , boundingBox ) ; }
a GeometryMetadata from a Cursor .
the values .
a tile .
a list of SimpleAttributes rows .
the integrity check of the cursor .
( String tableName ) { this . tableName = tableName ; }
getSimpleAttributesDao ( String tableName ) { SimpleAttributesDao simpleAttributesDao = new SimpleAttributesDao ( getUserDao ( tableName ) ) ; simpleAttributesDao . registerCursorWrapper ( getGeoPackage ( ) ) ; return simpleAttributesDao ; }
getMappingsForBase ( ExtendedRelation extendedRelation , long baseId ) { return getMappingsForBase ( extendedRelation . getMappingTableName ( ) , baseId ) ; }
getMappingsForRelated ( ExtendedRelation extendedRelation , long relatedId ) { return getMappingsForRelated ( extendedRelation . getMappingTableName ( ) , relatedId ) ; }
if a user has a mapping .
the count of the cursor .
( GeoPackage geoPackage ) { this . geoPackage = geoPackage ; }
a table from a GeoPackage .
a GeoPackageTile from a bounding box .
a tile .
( Bitmap tile , int requestedTileWidth , int requestedTileHeight , ProjectionTransform transformRequestToTiles , BoundingBox tilesBoundingBox ) { final double requestedWidthUnitsPerPixel = ( requestBoundingBox . getMaxLongitude ( ) - requestBoundingBox . getMinLongitude ( ) ) / requestedTileWidth ; final double requestedHeightUnitsPerPixel = ( requestBoundingBox . getMaxLatitude ( ) - requestBoundingBox . getMinLatitude ( ) ) / requestedTileHeight ; final double tilesDistanceWidth = tilesBoundingBox . getMaxLongitude ( ) - tilesBoundingBox . getMinLongitude ( ) ; final double tilesDistanceHeight = tilesBoundingBox . getMaxLatitude ( ) - tilesBoundingBox . getMinLatitude ( ) ; final int width = tile . getWidth ( ) ; final int height = tile . getHeight ( ) ; int [ ] pixels = new int [ width * height ] ; tile . getPixels ( pixels , 0 , width , 0 , 0 , width , height ) ; int [ ] projectedPixels = new int [ requested Tile
the tile results .
DrawOverlap for the pointIcon .
the density of the polygon .
a linePaint .
the polygonPaint .
a tile .
a tile query .
a tile query index .
( int x , int y ) { BoundingBox webMercatorBoundingBox = TileBoundingBoxUtils . getWebMercatorBoundingBox ( x , y , zoom ) ; long count = queryIndexedFeaturesCount ( webMercatorBoundingBox ) ; return count ; }
the number of indexed features .
( ) { BoundingBox webMercatorBoundingBox = TileBoundingBoxUtils . getWebMercatorBoundingBox ( x , y , zoom ) ; return queryIndexedFeatures ( webMercatorBoundingBox ) ; }
indexed features .
a tile .
the points .
getPointPaint ( FeatureStyle featureStyle ) { Paint paint = getFeatureStylePaint ( featureStyle ) ; if ( paint == null ) { paint = pointPaint ; } return paint ; }
getLinePaint ( FeatureStyle featureStyle ) { Paint paint = getFeatureStylePaint ( featureStyle ) ; if ( paint == null ) { paint = linePaint ; } return paint ; }
the polygon paint .
( ) { return polygonFillPaint ; }
getStylePaint ( FeatureStyle featureStyle , FeatureDrawType drawType ) { Paint paint = null ; if ( featureStyle != null ) { StyleRow style = featureStyle . getStyle ( ) ; if ( style != null && style . hasColor ( ) ) { paint = getStylePaint ( style , drawType ) ; } } return paint ; }
getStylePaint ( StyleRow style , FeatureDrawType drawType ) { Paint paint = featurePaintCache . getPaint ( style , drawType ) ; if ( paint == null ) { paint = featurePaintCache . getPaint ( style , drawType ) ; } return paint ; }
getPaint ( StyleRow styleRow , FeatureDrawType type ) { return getPaint ( styleRow . getId ( ) , type ) ; }
the Paint of the given style .
Bitmap put ( IconRow iconRow , Bitmap bitmap ) { return put ( iconRow . getId ( ) , bitmap ) ; }
a Bitmap for the given icon .
a single quote into the database .
a bitmap for the given layer .
the bitmap .
( int layer ) { if ( layeredBitmap [ layer ] == null ) { createBitmapAndCanvas ( layer ) ; bitmap = layeredBitmap [ layer ] ; } return bitmap ; }
( int layer ) { Canvas canvas = layeredCanvas [ layer ] ; if ( canvas == null ) { createCanvas ( layer ) ; canvas = layeredCanvas [ layer ] ; } return canvas ; }
a bitmap and canvas .
the StyleMappingDao for the given table .
getStyleDao ( ) { StyleDao styleDao = null ; if ( geoPackage . isTable ( StyleTable . TABLE_NAME ) ) { AttributesDao attributesDao = getGeoPackage ( ) . getAttributesDao ( StyleTable . TABLE_NAME ) ; styleDao = new StyleDao ( attributesDao ) ; relatedTables . setContents ( styleDao . getTable ( ) ) ; } return styleDao ; }
the iconDao for the given table .
the feature styles from the table .
the table styles from the feature table .
the style of the feature table .
the table icons for the feature table .
the icon of the feature table .
getFeatureStyles ( FeatureRow featureRow ) { return getFeatureStyles ( featureRow . getTable ( ) . getTableName ( ) ) ; }
getFeatureStyles ( String featureTable , long featureId ) { return getFeatureStyles ( featureTable , featureId ) ; }
getStyles ( ) { return getStyles ( featureRow . getTable ( ) . getTableName ( ) , featureRow . getId ( ) ) ; }
the icons of the feature row .
the styles for the given feature .
icons for the given feature .
( String featureTable ) { if ( featureTable != null ) { setTableStyles ( featureTable , featureStyles . getStyles ( ) ) ; setTableIcons ( featureTable , featureStyles . getIcons ( ) ) ; } }
the table styles .
the table icon for the feature table .
( FeatureRow featureRow , FeatureStyles featureStyles ) { setFeatureStyles ( featureRow . getTable ( ) . getTableName ( ) , featureRow . getId ( ) , featureStyles ) ; }
( String featureTable , long featureId , FeatureStyles featureStyles ) { if ( featureStyles != null ) { setStyles ( featureTable , featureId , featureStyles . getStyles ( ) ) ; setIcons ( featureTable , featureId , featureStyles . getIcons ( ) ) ; } else { deleteStyles ( featureTable , featureId ) ; deleteIcons ( featureTable , featureId ) ; } }
( FeatureRow featureRow , Styles styles ) { this . featureRow = featureRow ; this . styles = styles ; }
the styles of the feature table .
setStyle ( FeatureRow featureRow , Style style ) { setStyle ( featureRow , featureRow . getGeometryType ( ) , style ) ; return style ; }
( FeatureRow featureRow , StyleRow style ) { setStyle ( featureRow . getTable ( ) . getTableName ( ) , featureRow . getId ( ) , null , style ) ; }
setStyle ( String featureTable , long featureId , StyleRow style ) { setStyle ( featureTable , featureId , null , style ) ; return style ; }
( FeatureRow featureRow , Icons icons ) { setIcons ( featureRow . getTable ( ) . getTableName ( ) , featureRow . getId ( ) , icons ) ; }
icons from the feature table .
setIcon ( FeatureRow featureRow , Icon icon ) { setIcon ( featureRow , featureRow . getGeometryType ( ) , icon ) ; return icon ; }
( FeatureRow featureRow , Icon icon ) { setIcon ( featureRow . getTable ( ) . getTableName ( ) , featureRow . getId ( ) , null , icon ) ; }
( String featureTable , long featureId , IconRow icon ) { if ( icon != null ) { setIcon ( featureTable , featureId , icon ) ; } else { setIcon ( featureTable , featureId , null ) ; } }
a new style .
a new icon .
a style mapping row .
( String featureTable ) { deleteTableMapping ( getTableStyleMappingDao ( featureTable ) ) ; }
table icon mapping .
table mappings .
the table mapping .
mapping .
all table style ids .
all table icon ids .
all style ids from the feature table .
all icon ids for the given feature table .
the image bytes .
the output stream .
the pixel value from the pixels array .
the pixels from the image .
feature in tile .
a path to the canvas .
a polygon path .
a line string to the bounding box .
a ring to the polygon .
the feature cache for the given tableName .
the feature row from the table .
the cache .
the table styles .
the table icons .
getTableDao ( GeoPackage geoPackage ) { return new RTreeIndexTableDao ( this , geoPackage ) ; }
the width of the column .
the height of the column .
the dimensions of the image .
the density of the tile .
large blob value .
a table from a GeoPackageConnection .
the color of the given color .
the color .
a new color .
the GeoPackageManager .
( GeoPackageProgress progress ) { featureTableIndex . setProgress ( progress ) ; featureIndexer . setProgress ( progress ) ; rTreeIndexTableDao . setProgress ( progress ) ; }
the index of the given type .
the index of the row .
the index .
the index .
the index .
the index .
if a feature is indexed .
indexed types .
the FeatureIndexResults .
the count of the feature table indexes .
getBoundingBox ( ) { BoundingBox bounds = null ; switch ( getIndexedType ( ) ) { case GEOPACKAGE : bounds = featureTableIndex . getBoundingBox ( ) ; break ; case METADATA : bounds = featureIndexer . getBoundingBox ( ) ; break ; case RTREE : bounds = rTreeIndexTableDao . getBoundingBox ( ) ; break ; default : bounds = manualFeatureQuery . getBoundingBox ( ) ; } return bounds ; }
the feature index results .
the index type .
the internal file from the given path .
getInternalFilePath ( Context context ) { return getInternalFilePath ( context , null ) ; }
the geometry type .
the geometry type .
the bounding box for the given url .
the value of the tile generator variable .
whether a URL has a XYZ .
the bounding box .
the bounding box .
a GeoPackageGeometryData object .
the geometry metadata .
last indexed time .
the table metadata .
the geometry metadata .
the index of the geometry column .
the geometry metadata for the given feature .
the bounding box of the feature .
the count of the bounding box .
query ( GeometryEnvelope envelope ) { return query ( envelope ) ; }
the count of the geometry envelope .
the feature bounding box .
the feature bounding box .
the bounding box of the feature .
the geometry metadata from the cursor .
the feature row .
the feature row from the given geometryMetadata .
tile Daos for feature table .
< FeatureDao > getFeatureDaosForTileTable ( String tileTable ) { List < FeatureDao > featureDaos = new ArrayList < FeatureDao > ( ) ; List < String > featureTables = getFeatureTablesForTileTable ( tileTable ) ; for ( String featureTable : featureTables ) { if ( geoPackage . isFeatureTable ( featureTable ) ) { FeatureDao featureDao = geoPackage . getFeatureDao ( featureTable ) ; featureDaos . add ( featureDao ) ; } } return featureDaos ; }
getBoundingBox ( GeoPackage geoPackage , FeatureTiles featureTiles , BoundingBox boundingBox ) { if ( boundingBox == null ) { boundingBox = featureTiles . expandBoundingBox ( boundingBox , projection ) ; } return boundingBox ; }
query ( long baseId , long relatedId ) { return query ( buildWhereIds ( baseId , relatedId ) , buildWhereIdsArgs ( baseId , relatedId ) ) ; }
a list of unique base ids .
uniqueRelatedIds ( ) { return new ArrayList < Long > ( ) ; }
the given baseId .
the related id .
( long baseId ) { return delete ( buildWhereIds ( baseId , relatedId ) , buildWhereIdsArgs ( baseId , relatedId ) ) ; }
the where ids for the given baseId and relatedId .
GeoPackage metadata .
a GeoPackageMetadata .
a GeoPackageMetadata .
the package to the new name .
all GeoPackageMetadata .
the GeoPackageMetadata from the database .
the GeoPackageMetadata for the given id .
a GeoPackageMetadata .
boolean isExternal ( String database ) { GeoPackageMetadata metadata = get ( database ) ; return get ( database ) != null && metadata . getExternalPath ( ) != null ; }
a GeoPackageMetadata from the given path .
getMetadataWhereNameLike ( String like ) { return getMetadataWhereNameLike ( like , null ) ; }
getMetadataWhereNameLike ( String notLike , String sortColumn ) { return getMetadataWhereNameLike ( notLike , sortColumn , true ) ; }
all GeoPackageMetadata names from the given GeoPackageMetadata table .
a GeoPackageMetadata object .
onViewCreated ( View view ) { if ( view == null ) { return null ; } view = onViewCreatedInternal ( view , context , attrs ) ; for ( OnViewCreatedListener listener : otherListeners ) { if ( listener != null ) { view = listener . onViewCreated ( view , context , attrs ) ; } } return view ; }
a parallax view to the page .
a new view .
a custom view .
the event to a CyclicBuffer .
( boolean updateStatus ) { if ( updateStatus ) { statusOnResourceSearch ( logbackConfigFile , this . classLoader , logbackConfigFile ) ; } return logbackConfigFile ; }
the resource from the given filename .
configure the Joran configurator .
the status of the given resource .
the socket address .
ExecutorService newExecutorService ( ) { return new ThreadPoolExecutor ( CoreConstants . CORE_POOL_SIZE , CoreConstants . MAX_POOL_SIZE , 0L , TimeUnit . MILLISECONDS , new SynchronousQueue < Runnable > ( ) , THREAD_FACTORY ) ; }
a new converter .
event to the currently active file .
a substitution property .
the value of the property .
the converter .
EOpt ( ) throws ScanException { Node t = T ( ) ; if ( t == null ) { return null ; } Node eOpt = Eopt ( ) ; if ( eOpt != null ) { t . setNext ( eOpt ) ; } return t ; }
a FormattingNode .
characters .
the date to a regex .
an evaluator to the object stack .
the evaluator .
a context selector .
a new ContextSelector .
the properties of the LoggerContext .
the mounted external storage directory path .
( ) { return getDatabaseDirectoryPath ( ) ; }
the absolute path of the given filename .
the logging event .
the value .
( long mask ) { final long timeElapsedSinceLastMaskUpdateCheck = now - lastMaskCheck ; lastMaskCheck = mask ; if ( timeElapsedSinceLastMaskUpdateCheck < MASK_INCREASE_THRESHOLD && ( mask < MAX_MASK ) ) { mask = ( mask << 1 ) | 1 ; } else if ( timeElapsedSinceLastMaskUpdateCheck > MASK_DECREASE_THRESHOLD ) { mask = ( mask << 1 ) | 1 ; } else if ( timeElapsedSinceLastMaskUpdateCheck > MASK_INCREASE_THRESHOLD ) { mask = ( mask << 1 ) | 1 ; } else { mask = ( mask << 1 ) | 1 ; } return mask ; }
getFilterChainDecision ( ) { final Filter < E > [ ] filterArrray = filterList . asTypedArray ( ) ; final int len = filterArrray . length ; for ( int i = 0 ; i < len ; i ++ ) { final FilterReply r = filterArrray [ i ] . decide ( event ) ; if ( r == FilterReply . DENY || r == FilterReply . ACCEPT ) { return r ; } } return FilterReply . NEUTRAL ; }
a key manager .
a trust manager .
keyStoreFromSystemProperties ( String property ) { if ( System . getProperty ( property ) == null ) return null ; KeyStoreFactoryBean keyStore = new KeyStoreFactoryBean ( ) ; keyStore . setLocation ( locationFromSystemProperty ( property ) ) ; keyStore . setProvider ( System . getProperty ( property + " Provider " ) ) ; keyStore . setPassword ( System . getProperty ( property + " Password " ) ) ; keyStore . setType ( System . getProperty ( property + " Type " ) ) ; return keyStore ; }
the location of the file .
the URL for the given location .
( Converter < ILoggingEvent > head ) { if ( head instanceof ThrowableHandlingConverter ) { return chainHandlesThrowable ( ( ThrowableHandlingConverter ) head ) ; } if ( head instanceof ThrowableHandlingConverter ) { return chainHandlesThrowable ( ( ThrowableHandlingConverter ) head ) ; } return chainHandlesThrowable ( head ) ; }
the Logback context .
in case of errors or warnings .
.
the context .
the first line of the stacktrace .
the entry for the given key .
the last entry from the liveMap .
valueOf ( String str ) throws IllegalArgumentException { if ( str == null ) { throw new IllegalArgumentException ( " Formatting string cannot be null " ) ; } if ( str . length ( ) == 0 ) { throw new IllegalArgumentException ( " Formatting string cannot be empty " ) ; } if ( str . charAt ( str . length ( ) - 1 ) == ' . ' ) { throw new IllegalArgumentException ( " Formatting string cannot be empty " ) ; } if ( str . charAt ( str . length ( ) - 1 ) == ' . ' ) { throw new IllegalArgumentException ( " Formatting string cannot be empty " ) ; } if ( str . charAt ( str . length ( ) - 1 ) == ' . ' ) { throw new IllegalArgumentException ( " Formatting string cannot be empty " ) ; } if ( str . charAt ( str . length ( ) - 1 ) == ' . ' ) { throw new IllegalArgumentException ( " Formatting string cannot be empty " ) ; }
a file to a target .
whether the target file is on the same file store .
getenv ( String key ) { try { return System . getenv ( key ) ; } catch ( SecurityException e ) { return null ; } }
( String key ) { try { return SystemPropertiesProxy . getInstance ( ) . get ( key , null ) ; } catch ( IllegalArgumentException e ) { return null ; } }
the MDCPropertyMap .
the mdc properties for the given mdc property .
a StackTraceElement from a StackTraceElement array .
if the current class is a framework package .
a new status to the list .
a StatusListener to the list .
< Action > lookupImplicitAction ( List < ImplicitAction > implicitActions ) { if ( implicitActions != null && implicitActions . size ( ) > 0 ) { for ( int i = 0 ; i < implicitActions . size ( ) ; i ++ ) { ImplicitAction ia = ( ImplicitAction ) implicitActions . get ( i ) ; if ( ia . isApplicable ( elementPath , attributes , ec ) ) { List < Action > actionList = new ArrayList < Action > ( 1 ) ; actionList . add ( ia ) ; return actionList ; } } } return null ; }
< Action > getApplicableActionList ( ElementPath elementPath , Attributes attributes ) { List < Action > applicableActionList = ruleStore . matchActions ( elementPath ) ; if ( applicableActionList == null ) { applicableActionList = lookupImplicitAction ( elementPath , attributes , interpretationContext ) ; } return applicableActionList ; }
the ClassLoader to the system properties .
the value of the specified key .
getBoolean ( String key , boolean def ) throws IllegalArgumentException { if ( SystemProperties == null || getBoolean == null ) return def ; Boolean ret = def ; try { ret = ( Boolean ) getBoolean . invoke ( SystemProperties , new Object [ ] { key , def } ) ; } catch ( IllegalArgumentException e ) { throw e ; } catch ( Exception e ) { } return ret ; }
( String name ) { if ( name == null ) { return name ; } else { String nm = name . substring ( 0 , 1 ) . toLowerCase ( Locale . US ) ; if ( name . length ( ) > 1 ) { nm += name . substring ( 1 ) ; } return nm ; } }
the methods of the given class .
[ ] getPropertyDescriptors ( Class < ? > clazz ) { Map < String , PropertyDescriptor > map = new HashMap < String , PropertyDescriptor > ( ) ; map . put ( clazz . getName ( ) , new PropertyDescriptor ( clazz . getName ( ) ) ) ; return map . values ( ) ; }
the appender .
( Context context , OnConsoleStatusListener onConsoleStatusListener ) { onConsoleStatusListener . setContext ( context ) ; boolean effectivelyAdded = context . getStatusManager ( ) . add ( onConsoleStatusListener ) ; if ( effectivelyAdded ) { onConsoleStatusListener . start ( ) ; } }
property definer .
the value of the logger context .
whether the logging event is discardable .
a shutdown hook .
shutdown hook with JVM runtime .
enabled protocols .
cipher suites .
the included strings from the specified defaults .
the current scope .
setProperties ( InterpretationContext ic , Properties props ) { if ( props == null ) { props = new Properties ( ) ; } else { props . putAll ( props ) ; } return props ; }
a new appender .
( Appender < E > appender ) { if ( appender == null ) { return false ; } boolean result ; result = appenderList . remove ( appender ) ; return result ; }
( String name ) { if ( name == null ) { return false ; } for ( Appender < E > a : appenderList ) { if ( name . equals ( ( a ) . getName ( ) ) ) { removed = appenderList . remove ( a ) ; break ; } } return removed ; }
the parent level change .
appendLoop ( ILoggingEvent event ) { for ( Logger l = this ; l != null ; l = l . parent ) { writes += l . appendLoopOnAppenders ( event ) ; if ( ! l . additive ) { break ; } } if ( writes == 0 ) { loggerContext . noAppenderDefinedWarning ( this ) ; } }
( Appender < ILoggingEvent > appender ) { if ( appender == null ) { return false ; } return appender . detachAppender ( ) ; }
a child logger .
( Marker marker , Level level ) { return loggerContext . getTurboFilterChainDecision_0_3OrMore ( marker , this , level ) ; }
log ( slf4jEvent ) { return slf4jEvent ; }
a new socket .
a new directory if the file does not exist .
the level to an integer .
toLevel ( int val ) { switch ( val ) { case ALL_INT : return ALL ; case TRACE_INT : return TRACE ; case DEBUG_INT : return DEBUG ; case INFO_INT : return INFO ; case WARN_INT : return WARN ; case ERROR_INT : return ERROR ; case OFF_INT : return OFF ; default : return defaultLevel ; } }
the occurrence count of a resource .
the resource from the ClassLoader .
getClassLoaderOfObject ( Object o ) { if ( o == null ) { throw new NullPointerException ( " Argument cannot be null " ) ; } return getClassLoaderOfClass ( o . getClass ( ) ) ; }
the ClassLoader for the given class .
the ClassLoader of the given class .
the appender .
the tag of the event .
the value of a substitution property .
( String name ) { return getSeparatorIndexOf ( name , 0 ) ; }
the event marker .
the client thread name .
file store equality for a and b .
the session .
a message to the SMTPAppender .
a message to the SMTP server .
MDCValueLevelPair to valueLevelMap .
a dynamic converter .
a composite converter .
the compression mode .
the configuration .
the configuration file .
the stream .
an interpreter .
current configuration as safe fallback point .
the interpreter .
the name of the property .
the name of the Context .
if the context has a status listener .
the time of the last reset .
the converter .
( ) { return getEffectiveConverterMap ( ) ; }
the file header .
the file footer .
an Appender .
the appender .
the clients .
a client to the list of clients .
the client from the list of clients .
the copy of the context map .
the value of the given type .
getTurboFilterChainDecision ( final Marker marker , final Logger logger , final Level level , final String format , final Object [ ] params , final Throwable t ) { final int size = size ( ) ; if ( size == 1 ) { try { TurboFilter tf = get ( 0 ) ; return tf . decide ( marker , logger , level , format , params , t ) ; } catch ( IndexOutOfBoundsException iobe ) { return FilterReply . DENY ; } } return FilterReply . ACCEPT ; }
if the Android OS is present .
the default logger context .
all files in folder matching stemRegex .
( ) { if ( context == null ) return ; long now = System . currentTimeMillis ( ) ; StatusManager sm = context . getStatusManager ( ) ; List < Status > statusList = sm . getCopyOfStatusList ( ) ; for ( Status status : statusList ) { long timestampOfStatusMesage = status . getDate ( ) ; if ( isElapsedTimeLongerThanThreshold ( now , timestampOfStatusMesage ) ) { print ( status ) ; } } }
the facility string .
the database file .
( ) { if ( this . lastCleanupTime == 0 ) { this . lastCleanupTime = this . clock . currentTimeMillis ( ) ; this . getLogCleaner ( ) . performLogCleanup ( db ) ; } }
if the expiry has expired .
a logging event into a SQLiteStatement .
a new event into the database .
the logging event to a SQLiteStatement .
a String to a String .
the reference mask of the event .
logging event properties .
an exception into the database .
getPrefixMatchLength ( ElementPath p ) { return getPrefixMatchLength ( p ) ; }
the effective level of the Status .
property [ " + name + " ] .
( Class < ? > clazz ) { if ( clazz . isInterface ( ) ) { return isUnequivocallyInstantiable ( clazz ) ; } if ( isUnequivocallyInstantiable ( clazz ) ) { return isUnequivocallyInstantiable ( clazz ) ; } return isUnequivocallyInstantiable ( clazz ) ; }
the parent value .
a new SaxEventRecorder from the given URL .
a new URL .
the head and tail of the SaxEventRecorder .
the server .
the status of the exception .
the default hosts .
a local index .
the data selection queries .
the last sync date .
for a task to be published .
the offline data from the root data directory .
a string to a char array .
a byte array to a byte array .
the contents of the connection .
the list of hosts that are up .
setType ( Type type ) { if ( type == null ) { set ( KEY_TYPE , null ) ; } else { set ( KEY_TYPE , type ) ; } }
the index .
the value to the cache .
the value of the given key .
for the completion of the thread .
two versions .
the exception .
a directory to a target .
additional properties from a file .
the value of the given field .
MethodByName ( Class clazz , String methodName ) { for ( Method method : clazz . getDeclaredMethods ( ) ) { if ( method . getName ( ) . equals ( methodName ) ) { return method ; } } return null ; }
the percentage .
formatDouble ( double number ) { return padLeft ( format ( Locale . US , " % , . 2f " , number ) , length ) ; }
formatLong ( long number , int length ) { return padLeft ( format ( Locale . US , " % , d " , number ) , length ) ; }
a JSONSyntaxChar .
the hex value of the given character .
a JSON string to the transport .
an integer to the transport .
a double value to the transport .
a JSON string .
a JSON string .
the number of characters from the JSON .
a double from a JSON string .
( ) throws IOException { ByteString str = readJsonString ( false ) ; return ByteString . decodeBase64 ( str . utf8 ( ) ) ; }
to a closed service client .
the result of the method call .
to a closed service client .
the resource from the given location .
the decororation .
the repository view .
the resource history view .
a new editor .
the authentication failure .
the user for authentication .
a new server .
the animation thread .
the keepalive element from the root .
whether an element is omit .
setOwner ( Element root ) { Element owner = setChild ( root , " owner " ) ; Owner result = null ; try { result = new Owner ( owner ) ; } catch ( MalformedElementException e ) { Assert . isTrue ( false , Policy . bind ( " assert . internalError " ) ) ; } return result ; }
a new condition factor .
a new condition term .
a condition term .
the dsl content from the given rule source .
DSL config file .
the DSLTokenizedMapping file .
a menu to the parent .
a response to the root .
a href to the root .
a new Href .
the href from the root .
a propstat to the root .
the href from the root element .
the status of the given element .
the stack frame from the value .
if a class is a subtype of a given class .
a newProposal to the existing proposals .
a node .
the stream .
a new action for the ContentAssistProposal .
a new connection to the source .
the size of the location .
the connection .
the location of the new location .
the width and height of the rectangle .
size ( Dimension newSize ) { if ( newSize != null ) { size . setSize ( newSize ) ; firePropertyChange ( SIZE_PROP , null , size ) ; } }
the constraints .
a lock entry to the root .
a vertex to the list of vertices .
a vertex from the list .
the cache .
the plugin .
a string from the resource bundle .
the resource bundle .
the rule builder form colors .
the date to a DateTime .
the date to the specified date .
the status of the error .
the error message .
a field to the editor .
the number of columns in the grid .
font to all fields .
the number of columns .
the field editor .
a property change event .
the zoomComboContributionItem of the editor .
a ZoomComboContributionItem to the toolbar .
the dialect .
a new context .
the file to the specified location .
the table .
a new table .
a value to a URL .
the value to the table .
a new node to the tree .
a child node to the parent .
the offset and length of the file .
a condition to the list of conditions .
a state token condition .
a match for a given condition .
the prop from the root .
the status of the element .
a property .
the last line from the back text .
the last non - dash line .
static String bind ( String id , String binding ) { return bind ( id , new String [ ] { binding } ) ; }
a new binding to the given id .
a message to a bundle .
a new process .
a process sampleJUnit .
the runtime id .
the root vertex of the Rete .
whether a node is a real node .
the id of the object .
a new Prop to the root .
a property to a set .
a new locator .
getPresentationReconciler ( ISourceViewer sourceViewer ) { PresentationReconciler reconciler = new PresentationReconciler ( ) ; reconciler . setSourceViewer ( sourceViewer ) ; reconciler . setSourceReconciler ( sourceViewer ) ; reconciler . setSourceReconciler ( sourceViewer ) ; reconciler . setSourceReconciler ( sourceViewer ) ; reconciler . setSourceReconciler ( sourceViewer ) ; reconciler . setSourceReconciler ( sourceViewer ) ; reconciler . setSourceReconciler ( sourceViewer ) ; reconciler . setSourceReconciler ( sourceViewer ) ; reconciler . setSourceReconciler ( sourceViewer ) ; reconciler . setSourceReconciler ( sourceViewer ) ; reconciler . setSourceReconciler ( sourceViewer ) ; reconciler . setSourceReconciler ( sourceViewer ) ; reconciler . setSourceReconciler ( sourceViewer ) ; reconciler . setSourceReconciler ( sourceViewer ) ; reconciler .
the extended status of the given message .
a condition term .
a new state token .
a text editor to the ReteViewer .
the given request .
the response of the HTTP POST request .
the status of the job .
pull operation .
( final Map < Repository , Object > results ) { if ( tasksToWaitFor . decrementAndGet ( ) == 0 && results . isEmpty ( ) ) showResults ( ) ; }
a JsonArray with the given value .
active lock to the activelock .
proposals on prefix .
backwards of the document .
rete rows for the root vertex .
( Graphics g ) { g . setColor ( backgroundColor ) ; g . fillRect ( 0 , 0 , r . getWidth ( ) , r . getHeight ( ) ) ; g . fillRect ( r . getWidth ( ) , r . getHeight ( ) , r . getWidth ( ) , r . getHeight ( ) ) ; }
part for model element .
the image descriptor for the given path .
the registry image .
a new row .
the row of the given vertex .
the width of the given row .
a list of vertices .
the rows .
the ReteGraph .
zoomManager = new ZoomManager ( ) ; return zoomManager ; }
a new graph .
the DroolsLineBreakpoint for the given source .
the href of the root node .
the DAV client .
the document to the destination .
( IResponse response ) throws DAVException { if ( response . getStatusCode ( ) != IResponse . SC_MULTI_STATUS && response . getStatusCode ( ) != IResponse . SC_MULTI_STATUS && response . getStatusCode ( ) != IResponse . SC_MULTI_STATUS ) throw new SystemException ( response . getStatusCode ( ) ) ; }
the property stats from the response .
the content of the response .
( ) throws SystemException { try { Element element = getProperty ( DAV_LOCK_DISCOVERY ) . getProperty ( ) ; lockdiscovery = new LockDiscovery ( element ) ; return lockdiscovery . getActiveLocks ( ) ; } catch ( WebDAVException exception ) { if ( exception . getStatusCode ( ) == IResponse . SC_NOT_FOUND ) return new EmptyEnumeration ( ) ; throw exception ; } }
the properties of a given QualifiedName .
the current context .
lock ( boolean isShared , String depth , int timeout , String owner ) throws DAVException { IContext context = newContext ( ) ; context . setDepth ( depth ) ; context . setTimeout ( timeout ) ; Document document = newDocument ( ) ; lockinfo = LockInfo . create ( document ) ; lockinfo . setIsShared ( isShared ) ; if ( owner != null ) { Owner ownerEditor = lockinfo . setOwner ( ) ; ownerEditor . getElement ( ) . appendChild ( document . createTextNode ( owner ) ) ; } return lockinfo ; }
the document to the destination .
ILocator protectedCheckIn ( ILocator locator ) throws SystemException { IResponse response = null ; try { response = davClient . checkin ( locator , newContext ( ) , null ) ; examineResponse ( response ) ; String versionUrl = response . getContext ( ) . getLocation ( ) ; return davClient . getDAVFactory ( ) . newStableLocator ( versionUrl ) ; } catch ( IOException e ) { throw new SystemException ( e ) ; } }
the lock .
properties from the document .
( QualifiedName propertyName ) throws DAVException { Collection propertyNames = new Vector ( 1 ) ; propertyNames . add ( propertyName ) ; removeProperties ( propertyNames ) ; }
the content of the given document .
properties from the specified document .
the properties of the given element .
the given token .
the document .
the version control .
the document .
( int code , String message ) throws WebDAVException { if ( code >= 300 && code <= 399 ) throw new RedirectionException ( code , message ) ; if ( code >= 400 && code <= 499 ) throw new ClientException ( code , message ) ; if ( code >= 500 && code <= 599 ) throw new ServerException ( code , message ) ; }
if a property has a child .
( OutputStream os ) throws IOException { if ( requestBodyWriter == null ) { if ( inputRead ) { is . reset ( ) ; inputRead = false ; } super . write ( os ) ; } else { requestBodyWriter . writeRequestBody ( os ) ; } }
a byte array to a hex string .
an int array to a hex string .
whether a property is all .
the prop name from the root .
a property .
the last word from the prefix .
the package tree .
a byte array to the OutputStream .
over a MVELStackFrame .
the parser errors .
( String s ) { int pos = 0 ; while ( pos < s . length ( ) && Character . isWhitespace ( s . charAt ( pos ) ) ) ++ pos ; while ( pos < s . length ( ) && Character . isWhitespace ( s . charAt ( pos ) ) ) ++ pos ; }
a new resource to the guvnor .
file changes to the given file .
the age of the person .
the length of the content .
( ) { return MAX_FORWARDS ; }
the overwrite string .
the PASSTHROUGH value .
the timeout value .
a value to a ContextKey .
the timeout value .
( String filename ) { try { FileReader reader = new FileReader ( filename ) ; BufferedReader breader = new BufferedReader ( reader ) ; return breader ; } catch ( IOException e ) { e . printStackTrace ( ) ; return null ; } }
the file .
( String text ) { if ( text . startsWith ( " [ " ) ) { return text . substring ( 1 , text . lastIndexOf ( " ] " ) ) ; } else { return text ; } }
( String text ) { if ( text . startsWith ( " [ " ) ) { return text . substring ( text . lastIndexOf ( " ] " ) + 1 ) ; } else if ( text . startsWith ( " [ " ) ) { return text . substring ( text . lastIndexOf ( " ] " ) + 1 ) ; } else if ( text . startsWith ( " [ " ) ) { return text . substring ( text . lastIndexOf ( " ] " ) + 1 ) ; } else { return text ; } }
tokens to the thenode .
the children of the given condition .
the children of the given object .
< String > addChildToList ( Node n , String prefix , ArrayList < String > list ) { if ( n . getChildren ( ) . size ( ) > 0 ) { for ( Node child : n . getChildren ( ) ) { if ( prefix != null && " - " . equals ( child . getToken ( ) ) ) { if ( ! list . contains ( prefix ) ) { list . add ( prefix ) ; } return ; } String text = ( prefix == null ? " " : prefix + " " ) + child . getToken ( ) ; addChildToList ( child , text , list ) ; } } else { if ( prefix != null && " - " . equals ( prefix ) ) { if ( ! list . contains ( prefix ) ) { list . add ( prefix ) ; } } } return list ; }
( ) { for ( Node n : rootCond . getChildren ( ) ) { printNode ( n ) ; } }
a node .
a list of tabs .
the text .
the image descriptor for the given id .
a request using a proxy server .
the request header field .
a rule launcher .
a new rule .
a new ruleflow file .
a rule flow launcher .
the selected IUs .
the image to the clipboard .
getFieldName ( ) { if ( constraint instanceof MvelConstraint ) { MvelConstraint mvelConstraint = ( MvelConstraint ) constraint ; InternalReadAccessor accessor = mvelConstraint . getFieldExtractor ( ) ; if ( accessor instanceof ClassFieldReader ) { return ( ( ClassFieldReader ) accessor ) . getFieldName ( ) ; } } return null ; }
the value of the constraint .
the value of the constraint .
guvnor resource properties .
the baseline control for the given locator .
( String member , ILocator source ) { bind ( member , source , false ) ; }
the locator for the given member .
the vertices .
the resource group .
a resource group .
a new entity tag .
the opposite vertex .
a list of otps .
if YubiKey belongs to user .
the username of the yk user .
yubikey to user file .
OATH OTP .
the secrets .
static String getPublicId ( String otp ) { if ( ( otp == null ) || ( otp . length ( ) < OTP_MIN_LEN ) ) { throw new IllegalArgumentException ( " The OTP is too short to be valid " ) ; } Integer len = otp . length ( ) ; return otp . substring ( 0 , len - 32 ) . toLowerCase ( ) ; }
the OTP format .
Evaluation create ( SimpleNode node , Object source ) { return create ( node , source , false ) ; }
Evaluation create ( SimpleNode node , Object source , boolean setOperation ) { return new Evaluation ( node , source , setOperation ) ; }
the cache .
if JDK15 is installed .
static String getPackageName ( Object o ) { return ( o == null ) ? null : getClassPackageName ( o ) ; }
the name of the class .
a unique descriptor for the given object .
the type of the argument .
if a class is more specific than another class .
the applicable method for the given object .
the value of the given property .
the property descriptors of the given class .
the property descriptor from the array .
static Method getReadMethod ( Class target , String name ) { return getReadMethod ( target , name , null ) ; }
a character from a buffer .
projection ( ) throws ParseException { if ( jjtc000 ) { jjtree . openNodeScope ( jjtn000 ) ; jjtc000 = false ; } else { jjtree . closeNodeScope ( jjtn000 , true ) ; jjtree . closeNodeScope ( jjtn000 , true ) ; jjtree . closeNodeScope ( jjtn000 , true ) ; jjtree . closeNodeScope ( jjtn000 , true ) ; jjtree . closeNodeScope ( jjtn000 , true ) ; jjtree . closeNodeScope ( jjtn000 , true ) ; jjtree . closeNodeScope ( jjtn000 , true ) ; jjtn000 = null ; }
an expression .
longValue ( Object value ) throws NumberFormatException { if ( value == null ) return Long . parseLong ( stringValue ( value , false ) ) ; if ( value . getClass ( ) . getSuperclass ( ) == Number . class ) return Long . parseLong ( stringValue ( value , true ) ) ; if ( value . getClass ( ) . getSuperclass ( ) == Boolean . class ) return Long . parseLong ( stringValue ( value , false ) ) ; if ( value . getClass ( ) . getSuperclass ( ) == Character . class ) return Long . parseLong ( stringValue ( value , true ) ) ; return Long . parseLong ( stringValue ( value , false ) ) ; }
doubleValue ( Object value ) throws NumberFormatException { if ( value == null ) return 0.0 ; if ( value instanceof Number ) return Double . parseDouble ( ( Number ) value ) ; if ( value instanceof Boolean ) return Double . parseDouble ( ( Boolean ) value ) ; if ( value instanceof Number ) return Double . parseDouble ( ( Number ) value ) ; if ( value instanceof Boolean ) return Double . parseDouble ( ( Boolean ) value ) ; if ( value instanceof Character ) return Double . parseDouble ( ( Character ) value ) ; if ( value instanceof String ) return Double . parseDouble ( ( String ) value ) ; if ( value instanceof Number ) return Double . parseDouble ( ( ( Number ) value ) . doubleValue ( ) ) ; if ( value instanceof String ) return Double . parseDouble ( ( String ) value ) ; return Double . parseDouble ( value ) ; }
the value to a BigInteger .
bigDecValue ( Object value ) throws NumberFormatException { if ( value == null ) return BigDecimal . valueOf ( 0L ) ; if ( value instanceof BigDecimal ) return bigDecValue ( ( BigDecimal ) value ) ; if ( value instanceof BigInteger ) return bigDecValue ( ( BigInteger ) value ) ; if ( value instanceof BigDecimal ) return bigDecValue ( ( BigDecimal ) value ) ; if ( value instanceof BigInteger ) return bigDecValue ( ( BigInteger ) value ) ; if ( value instanceof Boolean ) return bigDecValue ( ( Boolean ) value ) ; if ( value instanceof Character ) return bigDecValue ( ( Character ) value ) ; if ( value instanceof Character ) return bigDecValue ( ( Character ) value ) ; if ( value instanceof Character ) return bigDecValue ( ( Character ) value ) ; if ( value instanceof Character ) return bigDecValue ( ( Character ) value ) ; return bigDecValue ( value ) ; }
the value to a string .
the numeric type of the value .
( Object value , Class toType ) { return convertValue ( value , toType , false ) ; }
the value to an integer .
the numeric type of the given type .
( Object v1 , Object v2 , boolean canBeNonNumeric ) { return getNumericType ( getNumericType ( v1 ) , getNumericType ( v2 ) , canBeNonNumeric ) ; }
static Number newInteger ( int type , long value ) { switch ( type ) { case INT : return new Integer ( ( int ) value ) ; case FLOAT : if ( ( long ) ( float ) value == value ) { return new Float ( ( float ) value ) ; } case DOUBLE : if ( ( long ) ( double ) value == value ) { return new Double ( ( double ) value ) ; } case BYTE : return new Byte ( ( byte ) value ) ; case SHORT : return new Short ( ( short ) value ) ; default : return BigInteger . valueOf ( value ) ; } }
( ) { if ( _currentEvaluation != null ) { return _currentEvaluation ; } _currentEvaluation = null ; }
an Ognl getter .
a setter for a field .
the tree .
a SimpleNode .
the escape character from the image .
static void setRoot ( Map context , Object root ) { context . put ( OgnlContext . ROOT_CONTEXT_KEY , root ) ; }
static Object getValue ( String expression ) throws OgnlException { return getValue ( expression , null , null ) ; }
the value of the expression .
the value of the tree .
static boolean isConstant ( String expression , Map context ) throws OgnlException { return isConstant ( parseExpression ( expression ) , context ) ; }
the default watch service id .
the Play ! server .
the contents of the file .
the current application classloader .
( String archiverName ) throws NoSuchArchiverException { Archiver result = archiverManager . getArchiver ( archiverName ) ; result . setDuplicateBehavior ( Archiver . DUPLICATES_FAIL ) ; return result ; }
( Archiver archiver ) { for ( ResourceIterator iter = archiver . getResources ( ) ; iter . hasNext ( ) ; ) { iter . next ( ) ; } }
the contents of the file .
createProject ( ) { final Project antProject = new Project ( ) ; final ProjectHelper helper = ProjectHelper . getProjectHelper ( ) ; antProject . addReference ( ProjectHelper . PROJECTHELPER_REFERENCE , helper ) ; helper . getImportStack ( ) . addElement ( " AntBuilder " ) ; final BuildLogger logger = new NoBannerLogger ( ) ; logger . setMessageOutputLevel ( Project . MSG_INFO ) ; logger . setErrorPrintStream ( System . err ) ; antProject . addBuildListener ( logger ) ; return antProject ; }
a system property to a Java object .
a system property to a Java object .
a new folder .
directory .
( ) { final Activity activity = getActivity ( ) ; if ( activity != null && mSelectedDir != null ) { mBtnConfirm . setEnabled ( isValidFile ( mSelectedDir ) ) ; mActivity . invalidateOptionsMenu ( ) ; } }
a new file observer .
the selected directory .
a new folder .
whether the file is readable or writable .
the background job .
a new paragraph style .
the list .
( int edge ) { if ( edge == GROW_NONE ) { return ; } if ( edge == GROW_LEFT_EDGE || edge == GROW_RIGHT_EDGE || edge == GROW_TOP_EDGE || edge == GROW_BOTTOM_EDGE || edge == GROW_TOP_EDGE || edge == GROW_BOTTOM_EDGE ) { return ; } if ( edge == MOVE ) { moveBy ( dx * ( mCropRect . width ( ) / r . width ( ) ) , dy * ( mCropRect . height ( ) / r . height ( ) ) ) ; } }
( ) { return mCropRect ; }
the layout of the image .
RTEditTextListener ( RTEditTextListener listener ) { mListener = listener ; }
a SpanWatcher to the text .
the spinner view .
a SpinnerItem to a View .
a string to a RTHtml .
a Spanned text to a SortedSet < CharacterStyle > .
a unique file .
the original file from the given uri .
the namespace of the schema .
the localName of the given name .
the attribute type to CDATA .
the attributes .
the font name from the given file .
the font name from the given file .
a new buffer to the current buffer .
a byte [ ] to the specified buffer .
a byte to the current buffer .
a new stream to the current buffer .
a byte array to the OutputStream .
a byte array to a byte array .
the font size of the spinner .
the path to a UNIX separator .
( MotionEvent event ) { for ( int i = 0 ; i < mHighlightViews . size ( ) ; i ++ ) { HighlightView hv = mHighlightViews . get ( i ) ; hv . setFocus ( false ) ; hv . invalidate ( ) ; } }
whether the highlight view is visible .
the highlighted view .
( String publicid ) { thePublicid = publicid ; theSystemid = systemid ; theLastLine = theLastColumn = theCurrentLine = theCurrentColumn = 0 ; }
a String value .
a new element type .
a new attribute to the specified element .
the parent of the child .
getElementType ( String name ) { return ( ElementType ) ( theElementTypes . get ( name . toLowerCase ( ) ) ) ; }
the name of the entity .
( RTEditText editor , Effect ... exclude ) { cleanupParagraphs ( editor , Effects . BULLET , exclude ) ; cleanupParagraphs ( editor , Effects . NUMBER , exclude ) ; }
to the selected text .
if a domain is valid .
the undo and redo stack .
the editor .
all occurrences of a given string .
the current thread status .
( Thread t , BitmapFactory . Options options ) { getOrCreateThreadStatus ( t ) . mOptions = options ; }
the current thread .
a Bitmap from a FileDescriptor .
font names from assets .
the font names from the context .
the system font names .
a new HTML Schema .
getReader ( InputSource s ) throws IOException { if ( s == null ) return null ; if ( s . getEncoding ( ) == null ) return getReader ( s . getPublicId ( ) , s . getSystemId ( ) ) ; if ( s . getEncoding ( ) == null ) return getReader ( s . getPublicId ( ) , s . getSystemId ( ) ) ; if ( s . getEncoding ( ) == null ) return getReader ( s . getPublicId ( ) , s . getSystemId ( ) ) ; if ( s . getEncoding ( ) == null ) return getReader ( s . getPublicId ( ) , s . getSystemId ( ) ) ; return getReader ( s . getPublicId ( ) , s . getSystemId ( ) ) ; }
the contents of the file .
adup ( ) throws SAXException { if ( theNewElement != null && theAttributeName != null ) { theNewElement . setAttribute ( theAttributeName , null , theAttributeName ) ; theAttributeName = null ; } }
a string to a char array .
the entity from the schema .
the saved element .
the stack .
the element from the stack .
the prefix of a given name .
if the schema has a foreign namespace .
quotes from the given string .
a String into an array of strings .
the current element .
the name of the given name .
( Bundle outState ) { outState . putString ( " mToolbarVisibility " , mToolbarVisibility . name ( ) ) ; outState . putBoolean ( " mToolbarIsVisible " , mToolbarIsVisible ) ; outState . putInt ( " mActiveEditor " , mActiveEditor ) ; if ( mLinkSelection != null ) { outState . putSerializable ( " mLinkSelection " , mLinkSelection ) ; } }
the RTEditText editor .
an image into the editor .
a fragment from the RTEditText .
the base matrix of the rotated bitmap .
the max zoom of the image .
if a span exists in the editor .
spans from paragraph .
the url .
query string .
a directory .
the image .
a new OutputStreamWriter ( ) { if ( output == null ) { output = new OutputStreamWriter ( System . out ) ; } return output ; }
a character to the output stream .
a string to the output stream .
whether a boolean attribute is true or false .
( String s , int start , int length , boolean isAttVal ) throws SAXException { if ( isAttVal ) { write ( StringEscapeUtils . escapeHtml4 ( s ) ) ; } else { write ( StringEscapeUtils . escapeHtml4 ( s ) ) ; } }
a prefix to the document .
the name of the element .
a stream if it does not exist .
for stream activation .
( Path targetStoresPath ) { }
the nextProvisioningRequest .
the records from the kinesis stream .
an Amazon action with a retry limit .
< T > tryAmazonAction ( String actionLabel , Supplier < T > action , AtomicLong durationBetweenRequests ) { try { return of ( action . get ( ) ) ; } catch ( LimitExceededException | ProvisionedThroughputExceededException | KMSThrottlingException e ) { throw e ; } }
whether the bucket is accessible .
the store from the latest snapshot .
wildcard expander .
a string with a given pattern .
any chars from the given string .
a resourceLintReport to a LintReport .
the properties of the FilterConfig .
( ) { Properties configProperties = new Properties ( ) ; if ( additionalConfigProperties != null ) { configProperties . putAll ( additionalConfigProperties ) ; } return configProperties ; }
the auto detected wro file .
pre processors to post processors .
the given content .
the cache with the new value .
the model with the new value .
the ServletRequest from the given location .
< String > baseNameSuffixTransformer ( final String suffix ) { return new Transformer < String > ( ) { public String transform ( final String input ) { final String baseName = FilenameUtils . getBaseName ( input ) ; final String extension = FilenameUtils . getExtension ( input ) ; return baseName + suffix + " . " + extension ; } } ; }
the error message from the server .
a redirect to the specified location .
wildcard for the given resource uri .
a expander handler for the given resource .
the given URI .
a new WroConfiguration object .
the Cache & Model change listeners .
the request .
a new WroConfiguration object .
( final Collection < Group > groups ) { LOG . debug ( " identifyDuplicateGroupNames " ) ; final List < String > groupNames = new ArrayList < String > ( ) ; for ( final Group group : groups ) { if ( groupNames . contains ( group . getName ( ) ) ) { throw new WroRuntimeException ( " Duplicate group name detected : " + group . getName ( ) ) ; } groupNames . add ( group . getName ( ) ) ; } for ( final Group group : groups ) { if ( groupNames . contains ( group . getName ( ) ) ) { throw new WroRuntimeException ( " Duplicate group name detected : " + group . getName ( ) ) ; } } }
the imported model .
InputStream locate ( String uri ) throws IOException { final UriLocator locator = getInstance ( uri ) ; if ( locator == null ) { return getDecoratedObject ( ) . locate ( uri ) ; } return locator . locate ( uri ) ; }
post processors to the given content .
the processor .
the resource .
the option string .
the properties from the file .
the properties file .
a custom WroManagerFactory .
the resource fingerprints .
the target group .
( ) throws MojoExecutionException { final List < String > classpathElements = new ArrayList < String > ( ) ; try { classpathElements . addAll ( mavenProject . getRuntimeClasspathElements ( ) ) ; } catch ( final DependencyResolutionRequiredException e ) { throw new MojoExecutionException ( " Could not get compile classpath elements " , e ) ; } final ClassLoader classLoader = createClassLoader ( classpathElements ) ; if ( classLoader == null ) { throw new MojoExecutionException ( " Could not extend plugin classpath " ) ; } if ( classLoader . getClassLoader ( ) == null ) { throw new MojoExecutionException ( " Could not extend plugin classpath " ) ; } return classLoader ; }
the model resource from the ServletContext .
the WroManagerFactory .
the model transformers .
a precompiled function .
( final List < Resource > resources ) throws IOException { return processAndMerge ( resources , ProcessingCriteria . create ( ProcessingType . ALL , minimize ) ) ; }
and merge resources .
pre processing in parallel .
preProcessors to the given resource .
the pre processor .
fallback storage .
all fields of the given object .
the image url with the given cssUri .
new image location .
a model transformer .
the processed bundle .
the aggregated folder path .
variables from the body .
the variables from the css file .
variables in css .
a post processor to a pre processor .
isEligible ( final ResourceType searchedType ) { Validate . notNull ( searchedType ) ; final SupportedResourceType supportedType = getSupportedResourceType ( ) ; final boolean isTypeSatisfied = supportedType == null || ( supportedType != null && searchedType == supportedType . value ( ) ) ; return isTypeSatisfied ; }
gzip to the response .
static PathPatternProcessorDecorator include ( final Object processor , final String ... patterns ) { return new PathPatternProcessorDecorator ( processor , true , patterns ) ; }
static PathPatternProcessorDecorator exclude ( final Object processor , final String ... patterns ) { return new PathPatternProcessorDecorator ( processor , false , patterns ) ; }
a new ResourceChangeHandler .
the fingerprint of the resource .
the css import to the given resource .
a list of all items in the collection .
whether the application is minimized or not .
imported resources .
the absolute url of the imported resource .
a string representation of the items .
< String > getAliasList ( final String aliasCsv ) { LOG . debug ( " configured aliases : { } " , aliasCsv ) ; final List < String > list = new ArrayList < String > ( ) ; if ( ! StringUtils . isEmpty ( aliasCsv ) ) { final String [ ] tokens = aliasCsv . split ( TOKEN_DELIMITER ) ; for ( final String token : tokens ) { list . add ( token . trim ( ) ) ; } } return list ; }
a new context .
the source file .
a JavaScript string .
the processed bundle .
whether the request is a handler .
a handler request path .
the group .
the destination folder for the resourceType .
the group .
the hash for the given group .
a standalone context .
a new GenericObjectPool .
( final String uri ) throws IOException { notNull ( uri ) ; notNull ( folder ) ; final File jarPath = getJarFile ( folder ) ; if ( isSupported ( jarPath ) ) { return locateStreamFromJar ( uri , jarPath ) ; } return super . locateStream ( uri ) ; }
open ( final File jarFile ) throws IOException { isTrue ( jarFile . exists ( ) , " The JAR file must exists . " ) ; return new JarFile ( jarFile ) ; }
the path from the uri .
whether a group is minimized .
addLocator ( final UriLocator ... locators ) { for ( final UriLocator locator : locators ) { uriLocators . add ( locator ) ; } return this ; }
decorate ( final WroModelFactory decorated ) { return decorated instanceof DefaultWroModelFactoryDecorator ? decorated : new DefaultWroModelFactoryDecorator ( decorated , modelTransformers ) ; }
Requirements to the list of Requirements .
the update script .
a summary of all lint errors .
the resource .
getLockForKey ( final K key ) { final ReadWriteLock lock = locks . putIfAbsent ( key , new ReentrantReadWriteLock ( ) ) ; return lock == null ? locks . get ( key ) : lock ; }
a new process .
a list of properties from the contents .
the task info from the list .
the compilation command .
( final String header ) { LOG . debug ( " parseHeader : { } " , header ) ; final String headerName = header . substring ( 0 , header . indexOf ( " : " ) ) ; if ( ! headersMap . containsKey ( headerName ) ) { final String value = header . substring ( header . indexOf ( " : " ) + 1 ) ; headersMap . put ( headerName , StringUtils . trim ( value ) ) ; } }
no cache headers to the response .
the location of the request .
getServletPathFromLocation ( final HttpServletRequest request , final String location ) { return location . replace ( getPathInfoFromLocation ( request , location ) , StringUtils . EMPTY ) ; }
true if the requested URL matches the given pattern .
pattern with key .
the contents of the reader to the writer .
a new file .
the image url .
the attribute to the given object .
a URI for the given file .
a data URI .
the context with the given correlationId .
the correlation id .
whether or not a group is changed .
for resource changes .
if the resource has changed .
the hash of the current group .
whether a resource is a ResourceType .
a new process .
( final java . io . Serializable serializableObject ) throws IOException { return encodeObject ( serializableObject , NO_OPTIONS ) ; }
all groups .
a new group to the model .
a new Group .
a new resource to the specified group .
all resources for the given group .
the name of the timer .
the timer .
the name of the timer .
the name of the timer .
Saturation Jobs statistics .
( ) { if ( workersWaiting_ ) { return ; } stopWorkersLock_ . lock ( ) ; try { workersWaiting_ = false ; thereAreContextsToProcess_ . signalAll ( ) ; } finally { stopWorkersLock_ . unlock ( ) ; } }
the processed counters .
finished counters .
the value of the counter .
defaultVisit ( Rule < P > rule , P premise , ContextPremises premises , ClassInferenceProducer producer ) { if ( LOGGER_ . isTraceEnabled ( ) ) { LOGGER_ . trace ( " ignore { } by { } in { } " , premise , rule , premises ) ; } return null ; }
whether an ElkObjectProperty is equivalent to an ElkObjectProperty .
axiom loading .
( ) throws ElkException { restoreSaturation ( ) ; }
( ) throws ElkException { if ( consistencyCheckingState . isInconsistent ( ) ) { incompleteness_ . log ( incompleteness_ . getIncompletenessMonitorForClassification ( ) ) ; } }
the taxonomy .
the instance taxonomy .
< EntailmentInference > getEvidence ( final boolean atMostOne ) { return new Proof < EntailmentInference > ( ) { @ SuppressWarnings ( " unchecked " ) @ Override public Collection < OntologyInconsistencyEntailmentInference > getInferences ( final Object conclusion ) { if ( ! OntologyInconsistencyImpl . INSTANCE . equals ( conclusion ) ) { return Collections . < OntologyInconsistencyEntailmentInference > singleton ( new OntologyInconsistencyEntailmentInferenceImpl ( conclusionFactory_ . getContradiction ( conclusion ) ) ) ; } return Operations . getCollection ( result , size ) ; } } ; }
if the reasoner has been initialized .
whether to invalidate a given reasoner stage .
the add to the taxonomy .
the toRemove from the taxonomy .
an unsupported OWL API reasoner method .
the moved element .
an element from the array .
( E [ ] d , int del ) { if ( del < d . length ) return d [ del ] ; if ( del < d . length ) return d [ del ] ; if ( del < d . length ) return d [ del ] ; if ( del < d . length ) return d [ del ] ; if ( del < d . length ) return d [ del ] ; for ( ; ) { if ( del < d . length ) return d [ del ] ; if ( del < d . length ) return d [ del ] ; if ( del < d . length ) return d [ del ] ; if ( del < d . length ) return d [ del ] ; if ( del < d . length ) return d [ del ] ; if ( del < d . length ) return d [ del ] ; if ( del < d . length ) return d [ del ] ; } }
true if the given object is not null .
a new element to the array .
( ) { if ( LOGGER_ . isTraceEnabled ( ) ) LOGGER_ . trace ( toString ( ) + " occurences : " + printOccurrenceNumbers ( ) ) ; if ( positiveOccurrenceNo < 0 || negativeOccurrenceNo < 0 ) throw new ElkUnexpectedIndexingException ( toString ( ) + " has a negative occurrence : " + printOccurrenceNumbers ( ) ) ; }
the timeComposedSubsumers and timeDecomposedSubsumers .
a new RuleApplicationTimer to the timer .
a key and value .
the entry from the map .
the map .
the list of keys and values .
the configuration .
( Taxonomy < ElkClass > classTaxonomy , ElkObject . Factory objectFactory , Appendable writer ) throws IOException { List < ElkClass > classes = new ArrayList < ElkClass > ( classTaxonomy . getNodes ( ) . size ( ) * 2 ) ; for ( TaxonomyNode < ElkClass > classNode : classTaxonomy . getNodes ( ) ) { for ( ElkClass clazz : classNode ) { if ( ! clazz . getIri ( ) . equals ( PredefinedElkIris . OWL_THING ) && ! clazz . getIri ( ) . equals ( PredefinedElkIris . OWL_NOTHING ) ) { classes . add ( clazz ) ; } } } Collections . sort ( classes , CLASS_COMPARATOR ) ; for ( ElkClass clazz : classes ) { ElkDeclarationAxiom decl = objectFactory . getDeclarationAxiom ( clazz ) ; if ( decl .
all instances of a generic type node .
( ) { E [ ] tab = buckets ; for ( int i = 0 ; i < tab . length ; i ++ ) tab [ i ] = null ; size = 0 ; }
( boolean finalize , int ... hashes ) { int hash = 0 ; for ( int h : hashes ) { hash = hash + h ; } if ( finalize ) { hash = combineListHash ( hash ) ; } return hash ; }
a list of hashes into a single hash .
the input stream to the output stream .
logNewIncompletenessReasons ( final Logger logger ) { final List < IncompletenessMonitor > monitors = new ArrayList < IncompletenessMonitor > ( additionalMonitors . length + 1 ) ; monitors . add ( getIncompletenessDueToStatedAxiomsMonitor ( ) ) ; monitors . addAll ( Arrays . asList ( additionalMonitors ) ) ; return new DelegatingIncompletenessMonitor ( monitors ) ; }
all memberAxioms in the taxonomy .
the input to the buffer .
append ( Appendable appender , ElkObject elkObject ) throws IOException { append ( appender , elkObject , false ) ; return appender ; }
( final IndexedClassExpression queryClass ) { }
a direct type node .
if a sub object property is found in the chain .
static < T > Set < T > filter ( final Set < ? extends T > input , final Condition < ? super T > condition ) { return new Set < T > ( ) { @ Override public int size ( ) { return input . size ( ) ; } } ; }
< I , O > map ( final Set < ? extends I > input , final FunctorEx < I , O > functor ) { return new Map < I , O > ( ) { @ Override public Iterator < O > iterator ( ) { return new MapIterator < I , O > ( input . iterator ( ) , functor ) ; } @ Override public boolean contains ( Object o ) { I element = functor . deapply ( o ) ; return element == null ? false : input . contains ( element ) ; } @ Override public int size ( ) { return input . size ( ) ; } } ; }
a new element to the array .
the object from the array .
a ClassConclusionCounter to a ClassConclusionCounter .
the memory usage .
the configuration options .
the ELK reasoner .
( ) { addPadding ( ' ' , headerParams_ ) ; logger_ . debug ( String . format ( headerFormat_ , headerParams_ ) ) ; }
a list of values .
a string from a char array .
a new RuleCounter .
a resource to the output stream .
getActionInputParameter ( String name ) { ActionInputParameter ret = requestParams . get ( name ) ; if ( ret == null ) { ret = pathVariables . get ( name ) ; } return ret ; }
the property descriptor for the given property path .
< String , ActionInputParameter > getRequiredParameters ( ) { Map < String , ActionInputParameter > ret = new HashMap < String , ActionInputParameter > ( ) ; for ( Map . Entry < String , ActionInputParameter > entry : requestParams . entrySet ( ) ) { ActionInputParameter annotatedParameter = entry . getValue ( ) ; ret . put ( entry . getKey ( ) , annotatedParameter ) ; } return ret ; }
static boolean isSingleValueType ( Class < ? > clazz ) { boolean ret ; if ( isNumber ( clazz ) || isString ( clazz ) || isEnum ( clazz ) || isDate ( clazz ) || isCalendar ( clazz ) || isCurrency ( clazz ) ) { ret = true ; } else { ret = false ; } return ret ; }
a rel to a link .
the type of the link .
HREFLANG to the linkParams .
a rev to a link .
a link param .
( Map < String , ? extends Object > arguments ) { UriTemplate template = new UriTemplate ( partialUriTemplate . asComponents ( ) . toString ( ) ) ; return new Affordance ( expanded , linkParams , actionDescriptors ) ; }
the rels of a given link .
the revs of a given link .
the required parameters for the given action .
the value to a string .
whether the input is hidden or not .
the value of the property .
whether the inputAnnotation hasExplicitOrImplicitPropertyIncludeValue .
true if the request is required .
the default value of the request .
the name of the method parameter .
the property name of the input parameter .
the Vocab from the mixin .
the query string .
a form to the given action .
the value of the input button .
( String paramName , ActionInputParameter childInputParameter ) throws IOException { if ( childInputParameter . isArrayOrCollection ( ) ) { appendSelectMulti ( paramName , possibleValues , childInputParameter ) ; } else { appendSelectOne ( paramName , possibleValues , childInputParameter ) ; } }
a new ActionDescriptor to the AffordanceBuilder .
PartialUriTemplateComponents asComponents ( ) { return new PartialUriTemplateComponents ( ) ; }
( List < ActionDescriptor > actionDescriptors ) { return getUriTemplateComponents ( Collections . < String , Object > emptyMap ( ) , getRequiredArgNames ( actionDescriptors ) ) ; }
the first node of the given name .
the first node that matches the given rel .
< UberNode > iterator ( ) { return new Iterator < UberNode > ( ) { int index = 0 ; @ Override public boolean hasNext ( ) { return index < data . size ( ) ; } @ Override public void remove ( ) { throw new UnsupportedOperationException ( " removing from uber node is not supported " ) ; } @ Override public UberNode next ( ) { index = findNextChildWithData ( ) ; return data . get ( index ++ ) ; } @ Override public boolean hasNext ( ) { return findNextChildWithData ( ) != - 1 ; } private int findNextChildWithData ( ) { for ( int i = index ; i < data . size ( ) ; i ++ ) { if ( ! data . get ( i ) . getData ( ) . isEmpty ( ) ) { return i ; } } return - 1 ; } } ; }
< K , V > ofEq ( Equator < K > eq , Iterable < Map . Entry < K , V > > es ) { if ( es == null ) { return empty ( eq ) ; } MutableHashMap < K , V > map = emptyMutable ( eq ) ; for ( Map . Entry < K , V > entry : es ) { map . assoc ( entry . getKey ( ) , entry . getValue ( ) ) ; } return map . immutable ( ) ; }
< K , V > of ( Iterable < Map . Entry < K , V > > es ) { if ( es == null ) { return empty ( ) ; } PersistentTreeMap < K , V > map = new PersistentTreeMap < > ( Equator . defaultComparator ( ) , null , 0 ) ; for ( Map . Entry < K , V > entry : es ) { if ( entry != null ) { map = map . assoc ( entry . getKey ( ) , entry . getValue ( ) ) ; } } return map ; }
< K , V > empty ( Comparator < ? super K > c ) { return new PersistentTreeMap < > ( c , null , 0 ) ; }
ImSortedSet < Entry < K , V > > entrySet ( ) { return this . fold ( PersistentTreeSet . ofComp ( new KeyComparator < > ( comp ) ) , PersistentTreeSet :: put ) ; }
the last key from the map .
< T > of ( Iterable < ? extends T > list ) { if ( list == null ) { return empty ( ) ; } return new SourceProviderIterableDesc < > ( list ) ; }
_fold ( Iterable < ? > source , Operation [ ] ops , int opIdx , Fn2 reducer ) { if ( reducer == null ) { reducer = new Fn2 ( ) ; } if ( opIdx == 0 ) { reducer = new Fn2 ( ) ; } if ( reducer == null ) { reducer = new Fn2 ( ) ; } return reducer ; }
< A > dropWhile ( Fn1 < ? super A , Boolean > predicate ) { if ( predicate == null ) { throw new IllegalArgumentException ( " Can ' t dropWhile without a function . " ) ; } return new DropWhileDesc < > ( this , predicate ) ; }
fold ( B ident , Fn2 < ? super B , ? super A , B > reducer ) { if ( reducer == null ) { throw new IllegalArgumentException ( " Can ' t fold with a null reduction function . " ) ; } RunList runList = toRunList ( ) ; return _fold ( runList , runList . opArray ( ) , 0 , ident , reducer ) ; }
a Tuple2 < K , V > .
< A , R > match ( Fn1 < A , R > fa , Fn1 < B , R > fb , Fn1 < C , R > fc , int sel ) { if ( sel == 0 ) { return fa . apply ( ( A ) item ) ; } else if ( sel == 1 ) { return fb . apply ( ( B ) item ) ; } else if ( sel == 2 ) { return fc . apply ( ( C ) item ) ; } else if ( sel == 3 ) { return fc . apply ( ( D ) item ) ; } else if ( sel == 4 ) { return fc . apply ( ( E ) item ) ; } else if ( sel == 5 ) { return fb . apply ( ( Fn1 < B , R > ) item ) ; } else { return fc . apply ( ( Fn1 < C , R > ) item ) ; } }
a type array .
leaf node ( int i ) { E [ ] node = leafNodeArray ( i ) ; return node [ i & LOW_BITS ] ; }
the tail to the root .
PersistentVector < E > concat ( Iterable < ? extends E > items ) { return ( PersistentVector < E > ) ImList . super . concat ( items ) ; }
< T > mutableSet ( T ... items ) { MutableSet < T > ret = PersistentHashSet . emptyMutable ( ) ; if ( items == null ) { return ret ; } for ( T t : items ) { ret . put ( t ) ; } return ret ; }
< T > mutableVec ( T ... items ) { MutableList < T > ret = PersistentVector . emptyMutable ( ) ; if ( items == null ) { return ret ; } for ( T t : items ) { ret . append ( t ) ; } return ret ; }
< T > set ( T ... items ) { if ( items == null ) || ( items . length < 1 ) ) { return PersistentHashSet . empty ( ) ; } return PersistentHashSet . of ( items ) ; }
< T > vec ( T ... items ) { if ( items == null ) || ( items . length < 1 ) ) { return PersistentVector . empty ( ) ; } return mutableVec ( items ) . immutable ( ) ; }
< T > xformArray ( T ... items ) { return Xform . of ( Arrays . asList ( items ) ) ; }
the indented string .
an array of strings .
< T > of ( Fn0 < T > producer ) { if ( producer == null ) { throw new IllegalArgumentException ( " The producer function cannot be null ( the value it returns can ) " ) ; } return new LazyRef < > ( producer ) ; }
the value to the producer .
a new item into the array .
the items to a new array .
( ) throws SystemException { final SleeTransaction currentThreadTransaction = transactionManager . getSleeTransaction ( ) ; if ( currentThreadTransaction != null && currentThreadTransaction . equals ( this ) ) { transactionManager . getRealTransactionManager ( ) . suspend ( ) ; } }
the status of the async operation .
the service components from the given jar file .
a directory .
a new inheritance link for the given class .
( CtClass source , CtClass destination , CtClass [ ] exceptions ) { copyMethods ( source , destination , exceptions ) ; }
the methods to the destination .
a new TreeItem for the given root .
( final SbbEntity sbbEntity ) { this . sbbEntity = sbbEntity ; }
( String paramName ) { Boolean areNotificationsEnabled = paramNames . get ( paramName ) ; if ( areNotificationsEnabled != null && areNotificationsEnabled . booleanValue ( ) ) { return true ; } else { return false ; } }
( ServiceComponent serviceComponent ) { Set < String > result = new HashSet < String > ( ) ; Set < String > raLinkNames = sleeContainer . getResourceManagement ( ) . getLinkNamesSet ( ) ; for ( String raLink : serviceComponent . getResourceAdaptorEntityLinks ( componentRepositoryImpl ) ) { if ( ! raLinkNames . contains ( raLink ) ) { result . add ( raLink ) ; } } return result ; }
Service " + serviceComponent
the service .
if a ra link name is referenced by a component .
usage parameter sets .
( ) { try { for ( UsageMBeanImpl usageMBeanImpl : usageMBeans . values ( ) ) { usageMBeanImpl . resetAllUsageParameters ( ) ; } } catch ( Throwable e ) { throw new ManagementException ( e . getMessage ( ) , e ) ; } }
all profiles from the given table .
getProfileTableActivity ( String profileTableName ) throws FacilityException { if ( logger . isTraceEnabled ( ) ) { logger . trace ( " getProfileTableActivity ( profileTableName = " + profileTableName + " ) " ) ; } return null ; }
getProfileByIndexedAttribute ( java . lang . String profileTableName , java . lang . String attributeName , java . lang . Object attributeValue ) throws NullPointerException , UnrecognizedProfileTableNameException , UnrecognizedAttributeException , AttributeNotIndexedException , AttributeTypeMismatchException , TransactionRolledbackLocalException { if ( logger . isTraceEnabled ( ) ) { logger . trace ( " getProfileByIndexedAttribute ( profileTableName = " + profileTableName + " , attributeName = " + attributeName + " , attributeValue = " + attributeValue + " ) " ) ; } return getProfileByIndexedAttribute ( profileTableName , attributeName , attributeValue ) ; }
the result text .
the array .
a fire event .
a name to a node .
( String name ) throws NameNotBoundException { final Node node = getNode ( ) ; final Node childNode = node . getChild ( name ) ; if ( childNode == null ) { throw new NameNotBoundException ( " name not bound " ) ; } else { final Object ach = childNode . get ( CACHE_NODE_MAP_KEY ) ; node . removeChild ( name ) ; return ach ; } }
( String name ) { return lookupName ( name ) ; }
the name of the node .
the sbb entity associated with the slee event .
isHigherLevel ( TraceLevel other ) { if ( other == null ) throw new NullPointerException ( " other is null " ) ; return this . level < other . level ; }
a jar file from a directory .
the InputStream to the OutputStream .
Object putObject ( Object key , Object value ) { return getNode ( ) . put ( key , value ) ; }
a SbbEntity to a Node .
( SbbEntityID sbbEntityId ) { final Node node = getAttachedSbbsNode ( false ) ; return node != null ? node . removeChild ( sbbEntityId ) : false ; }
the attached Sbbs node .
< SbbEntityID > getSbbEntitiesAttached ( ) { final Node node = getAttachedSbbsNode ( ) ; return node != null ? node . getChildrenNames ( ) : Collections . emptySet ( ) ; }
a timer to a node .
( TimerID timerID ) { final Node node = getAttachedTimersNode ( false ) ; return node != null ? node . removeChild ( timerID ) : false ; }
( ) { final Node node = getAttachedTimersNode ( false ) ; return node != null ? node . getChildrenNames ( ) : null ; }
( ) { final Node node = getAttachedTimersNode ( ) ; return node != null ? node . getChildrenNames ( ) : Collections . emptySet ( ) ; }
a name bound node .
the name of the bound node .
the names bound node .
getNamesBoundCopy ( ) { return getNamesBoundCopy ( ) ; }
the CMP attribute value .
the CMP attribute from the node .
the CMP_ATTRIBUTES_NODE_MAP_KEY .
a MBeanNotificationInfo for the specified notification type .
a notification to the given usage parameter .
a remoteDU .
deployed components .
DeployableUnit ( DeployableUnit du ) throws Exception { if ( du . isReadyToInstall ( false ) ) { sciAction ( du . getInstallActions ( ) , du ) ; du . setInstalled ( true ) ; deployedDUs . add ( du ) ; } }
DeployableUnit .
( DeployableUnit du ) throws Exception { sleeContainerDeployer . getSleeSubDeployer ( ) . stop ( du . getURL ( ) , du . getDeploymentInfoShortName ( ) ) ; sleeContainerDeployer . getSleeSubDeployer ( ) . stop ( du . getDeploymentInfoShortName ( ) ) ; }
the status of the deployed components .
isLoggable ( LogRecord record ) { if ( record . getThrown ( ) != null ) { logWithThrowable ( logger , record ) ; } else { logWithoutThrowable ( logger , record ) ; } return record ; }
getLogger ( ) { return logger ; }
( SleeComponent component ) { Set < SleeComponent > result = new HashSet < SleeComponent > ( ) ; for ( EventTypeComponent otherComponent : eventTypeComponents . values ( ) ) { if ( ! otherComponent . getComponentID ( ) . equals ( component . getComponentID ( ) ) ) { if ( otherComponent . getDependenciesSet ( ) . contains ( component . getComponentID ( ) ) ) { result . add ( otherComponent ) ; } } } }
a list of all SbbEntityIDs from a node .
getPermissions ( Permissions permissions , final CodeSource cs , Principal [ ] principals ) { return permissions ; }
the code sources from the current policy .
true if the profile exists .
the profile table .
the configuration properties .
a FaultTolerantResourceAdaptorContext .
a RA object .
the entity .
the object .
all activities end .
the entity from the state .
( ResourceAdaptorTypeID raType ) { return object . getResourceAdaptorInterface ( ) ; }
the active receivable service .
a new ActivityHandle from the given handle .
the activity .
the config properties .
the config properties .
( ) throws Exception { if ( doTraceLogs ) { logger . trace ( " raStopping ( ) " ) ; } if ( state == ResourceAdaptorObjectState . ACTIVE ) { state = ResourceAdaptorObjectState . STOPPING ; object . raStopping ( ) ; } else { throw new InvalidStateException ( " ra object is in state " + state ) ; } }
( ) { if ( doTraceLogs ) { logger . trace ( " raInactive ( ) " ) ; } if ( state == ResourceAdaptorObjectState . STOPPING ) { state = ResourceAdaptorObjectState . INACTIVE ; object . raInactive ( ) ; } else { throw new InvalidStateException ( " ra object is in state " + state ) ; } }
( ) throws InvalidStateException { if ( doTrace ) { logger . trace ( " raUnconfigure ( ) " ) ; } if ( state == ResourceAdaptorObjectState . INACTIVE ) { state = ResourceAdaptorObjectState . UNCONFIGURED ; object . raUnconfigure ( ) ; } else { throw new InvalidStateException ( " ra object is in state " + state ) ; } }
( ) throws InvalidStateException { if ( doTraceLogs ) { logger . trace ( " unsetResourceAdaptorContext ( ) " ) ; } if ( state == ResourceAdaptorObjectState . UNCONFIGURED ) { object . unsetResourceAdaptorContext ( ) ; state = null ; } else { throw new InvalidStateException ( " ResourceAdaptor object is in state " + state ) ; } }
( ) throws IllegalArgumentException { if ( doTraceLogs ) { logger . trace ( " unsetFaultTolerantResourceAdaptorContext ( ) " ) ; } if ( isFaultTolerant ( ) ) { ( ( FaultTolerantResourceAdaptor < Serializable , Serializable > ) this . object ) . unsetFaultTolerantResourceAdaptorContext ( ) ; } else { throw new IllegalArgumentException ( " RA Object is not fault tolerant ! " ) ; } }
the profile attribute map from the profile cmp interface .
the current event .
< ActivityContextHandle > getActivityContextHandles ( ) { return getActivityContextHandles ( ) ; }
all named usage parameters .
the Sbb usage param set .
Abstract Class .
event to sbb entity .
an event on the Slee container .
the profile CMP Method .
( SbbEntity sbbEntity , String name ) throws UnrecognizedUsageParameterSetNameException { if ( logger . isTraceEnabled ( ) ) { logger . trace ( " getSbbUsageParameterSet ( ) : serviceId = " + sbbEntity . getSbbEntityId ( ) . getServiceID ( ) + " , sbbID = " + sbbEntity . getSbbId ( ) + " , name = " + name ) ; } return getServiceUsageMBeanImpl ( sbbEntity . getSbbEntityId ( ) . getServiceID ( ) ) . getInstalledUsageParameterSet ( name ) ; }
the abstract methods from the abstract class .
the interface methods from the given interface .
a new object pool .
object pool from profile table .
boolean isSourceOwnerOfAlarm ( NotificationSourceWrapper notificationSource ) { return true ; }
raiseAlarm ( NotificationSourceWrapper notificationSource , String alarmType , String instanceID , AlarmLevel level , String message , Throwable cause ) { synchronized ( notificationSource ) { if ( isAlarmAlive ( notificationSource , alarmType , instanceID ) ) { return this . raiseAlarm ( notificationSource , alarmType , instanceID , level , message , cause ) ; } } }
( ProfileObjectImpl profileObject , String name ) throws UnrecognizedUsageParameterSetNameException { if ( logger . isDebugEnabled ( ) ) { logger . info ( " [ getUsageParameterSet ( " + name + " ) ] @ " + profileObject ) ; } if ( name == null ) { throw new NullPointerException ( " UsageParameterSet name must not be null . " ) ; } ProfileTableImpl profileTable = profileObject . getProfileTable ( ) ; Object result = profileTable . getProfileTableUsageMBean ( ) . getInstalledUsageParameterSet ( name ) ; if ( result == null ) { throw new UnrecognizedUsageParameterSetNameException ( ) ; } return result ; }
the specs descriptor .
a deployable unit .
a new deployable unit .
the deployable unit .
the deployable unit .
the status of the deployable units .
after commit actions .
after commit priority actions .
afterRollbackActions ( ) { if ( afterRollbackActions != null ) { if ( trace ) { logger . trace ( " Executing rollback actions " ) ; } executeActions ( afterRollbackActions ) ; afterRollbackActions = null ; } }
before commit actions .
before commit priority actions .
a list of defined tracers .
a new Tracer .
replicated data .
a PropertyEditorManager .
a usage parameter class .
( ServiceID serviceID , SbbID sbbID ) { return pools . get ( new ObjectPoolMapKey ( serviceID , sbbID ) ) ; }
a new object pool .
the activity .
a new ActivityContextHandle .
the activity .
if the event is fired .
an event on an activity handle .
SbbLocalObjectConcreteClass .
a getter for the bean .
optArg to a String .
the profileID to the specified profileTableName .
a message from a string .
a SbbEntityCacheData for the given object .
boolean containsAll ( Collection c ) { if ( c == null ) throw new NullPointerException ( " null collection ! " ) ; for ( Iterator it = c . iterator ( ) ; it . hasNext ( ) ; ) { if ( ! contains ( it . next ( ) ) ) { return false ; } } if ( logger . isDebugEnabled ( ) ) { logger . debug ( " containsAll : collection = " + c + " > all in child relation " ) ; } return true ; }
all the elements from the collection .
isHigherLevel ( Level other ) { if ( other == null ) throw new NullPointerException ( " other is null " ) ; return this . level < other . level ; }
the level of the stream .
class from class pool .
call to profile .
getProfile ( String profileName ) throws SLEEException { Map txData = getTxData ( ) ; ProfileTransactionID key = new ProfileTransactionID ( profileName , profileTable . getProfileTableName ( ) ) ; ProfileObjectImpl value = ( ProfileObjectImpl ) txData . get ( key ) ; return value ; }
( SleeTransactionManager txManager , final ProfileObjectImpl profileObject , final ProfileObjectPool pool ) { TransactionalAction afterRollbackAction = new TransactionalAction ( ) { public void execute ( ) { profileObject . invalidateObject ( ) ; pool . returnObject ( profileObject ) ; } } ; TransactionalAction beforeCommitAction = new TransactionalAction ( ) { public void execute ( ) { if ( profileObject . getState ( ) == ProfileObjectState . READY ) { if ( ! profileObject . getProfileEntity ( ) . isRemove ( ) ) { profileObject . fireAddOrUpdatedEventIfNeeded ( ) ; profileObject . profilePassivate ( ) ; } else { profileObject . profileRemove ( true , false ) ; } pool . returnObject ( profileObject ) ; } } } ; txManager . commit ( ) ; }
the value of the ComponentID property .
a concrete class .
concrete methods .
the value of the cmp attribute .
a name binding to the cache .
naming bindings from the ActivityContextNamingFacility .
the name binding from the cache .
a timer to the cache .
the attached timers .
a Sbb entity to an ActivityContextHandle .
( SbbEntityID sbbEntityId ) throws javax . slee . TransactionRequiredLocalException { this . sbbEntityId = sbbEntityId ; }
sortByPriority ( Set < SbbEntityID > excludeSet ) { final Set < SbbEntityID > sbbAttachementSet = cacheData . getSbbEntitiesAttached ( ) ; Set < SbbEntityID > result = new HashSet < SbbEntityID > ( ) ; for ( SbbEntityID sbbEntityId : sbbAttachementSet ) { if ( ! excludeSet . contains ( sbbEntityId ) ) { result . add ( sbbEntityId ) ; } } return result ; }
the activity context .
a component to a DeployableComponent .
the external dependencies .
all dependenciesSatisfied for the given diShortName .
if a component is already deployed .
( ) { return this . installActions ; }
( ) { Collection < ManagementAction > uActions = new ArrayList < ManagementAction > ( ) ; uActions . add ( new UninstallDeployableUnitAction ( diURL . toString ( ) , sleeContainerDeployer . getDeploymentMBean ( ) ) ) ; if ( ! preUninstallActions . keySet ( ) . isEmpty ( ) ) { for ( String componentId : preUninstallActions . keySet ( ) ) { uActions . addAll ( preUninstallActions . get ( componentId ) ) ; } } return uActions ; }
the referring components from the SleeContainer .
the profile table .
the name of the profile table .
the write state of the profile mbean .
( ) throws InvalidStateException { if ( logger . isDebugEnabled ( ) ) { logger . debug ( " beforeSetCmpField ( ) on profile with name " + profileName + " of table " + profileTable . getProfileTableName ( ) ) ; } }
( ) throws ManagementException { if ( logger . isDebugEnabled ( ) ) { logger . debug ( " afterSetCmpField ( ) on profile with name " + profileName + " of table " + profileTable . getProfileTableName ( ) ) ; } try { sleeContainer . getTransactionManager ( ) . suspend ( ) ; } catch ( Throwable e ) { throw new ManagementException ( e . getMessage ( ) , e ) ; } }
( ) throws ManagementException { if ( logger . isDebugEnabled ( ) ) { logger . debug ( " beforeGetCmpField ( ) on profile with name " + profileName + " of table " + profileTable . getProfileTableName ( ) ) ; } return beforeNonSetCmpField ( ) ; }
( ) throws ManagementException { if ( logger . isDebugEnabled ( ) ) { logger . debug ( " afterGetCmpField ( activatedTransaction = " + activatedTransaction + " ) on profile with name " + profileName + " of table " + profileTable . getProfileTableName ( ) ) ; } afterNonSetCmpField ( activatedTransaction ) ; }
the beforeManagementMethodInvocation method .
afterManagementMethodInvocation ( ) throws Exception { if ( logger . isDebugEnabled ( ) ) { logger . debug ( " afterManagementMethodInvocation ( activatedTransaction = " + activatedTransaction + " ) on profile with name " + profileName + " of table " + profileTable . getProfileTableName ( ) ) ; } afterNonSetCmpField ( activatedTransaction ) ; }
the path .
a default constructor .
the default SbbUsageParameterSet from the sbbConcreteClass .
a new SbbEntityGetterAndSetter .
fire event methods .
( CtClass activityContextInterface , Class < ? > concreteActivityContextInterfaceClass ) throws DeploymentException { String methodToAdd = " public " + activityContextInterface . getName ( ) + " asSbbActivityContextInterface ( javax . slee . ActivityContextInterface aci ) { " + " if ( aci = = null ) " + " throw new " + IllegalStateException . class . getName ( ) + " ( " + " Cannot call asSbbActivityContextInterface ( javax . slee . ActivityContextInterface aci ) . " + " ) ; " + " if ( sbbEntity = = null | | sbbEntity . getSbbObject ( ) . getState ( ) ! = " + SbbObjectState . class . getName ( ) + " . READY ) { throw new " + IllegalStateException . class . getName ( ) + " ( " + " Cannot call asSbbActivityContextInterface ( javax . slee .
a query expression .
a new object to the NonSerializableFactory .
( Name name , Object target ) throws NamingException { rebind ( name , target , false ) ; }
Abstract Sbb Class .
( SbbConcrete proxy , String methodName , Object [ ] args , Class < ? > [ ] argTypes ) throws Exception { invokeAndReturnObject ( proxy , methodName , args , argTypes ) ; }
the real field name .
setFieldValue ( String fieldName , Object value ) { String realFieldName = getRealFieldName ( fieldName ) ; aciImpl . getActivityContext ( ) . setDataAttribute ( realFieldName , value ) ; }
the value of the given field .
the profile context .
a new profile entity .
the profile context .
the profile local object .
a new event for the given profile .
the profileCmpSlee10Wrapper .
a new class .
inheritance link for concrete class .
an annotation to an annotated class .
member values to annotation .
the activity context interface for the given activity .
getClassPool ( ClassLoader classLoaderDomain ) { if ( classPool == null ) { if ( classLoaderDomain == null ) { throw new IllegalStateException ( " can ' t init javassit classpool , there is no class loader set for the component " ) ; } classPool = new ClassPool ( ) ; classPool . appendClassPath ( new LoaderClassPath ( classLoaderDomain ) ) ; for ( ClassLoader domainDependencies : classLoaderDomain . getAllDependencies ( ) ) { classPool . appendClassPath ( new LoaderClassPath ( domainDependencies ) ) ; } classPool . appendClassPath ( new LoaderClassPath ( classLoaderDomain . getParent ( ) ) ) ; } return classPool ; }
setDeployableUnit ( DeployableUnit deployableUnit ) throws AlreadyDeployedException { if ( this . deployableUnit != null ) { throw new IllegalStateException ( " deployable unit already set . du = " + this . deployableUnit ) ; } this . deployableUnit = deployableUnit ; if ( ! addToDeployableUnit ( ) ) { throw new AlreadyDeployedException ( " unable to install du having multiple components with id " + getComponentID ( ) ) ; } }
whether the class pool is undeployed .
a new activity .
the interfaces of the given class .
( Class xInterfaceClass , Set < String > ignore ) { Map < String , Method > abstractMethods = new HashMap < String , Method > ( ) ; abstractMethods . putAll ( getAllInterfacesMethods ( xInterfaceClass , ignore ) ) ; return abstractMethods ; }
the publicId of the resource .
the tracer name .
the profiles of the given query .
dependencies in the deployable unit .
a deployment dir for DU " + deployableUnitID .
the EntityManager for the given profileSpecificationID .
the container .
( final ClassLoader cl , final ProfileObject po ) { ClassLoader _cl = null ; if ( System . getSecurityManager ( ) != null ) { _cl = ( ClassLoader ) AccessController . doPrivileged ( new PrivilegedAction ( ) { public Object run ( ) { return _switchSafelyClassLoader ( cl , po ) ; } } ) ; } else { _cl = _switchSafelyClassLoader ( cl , po ) ; } return _cl ; }
( final Object proxy , final String methodToCallname , final Class [ ] signature , final Object [ ] values ) throws PrivilegedActionException { try { return AccessController . doPrivileged ( new PrivilegedExceptionAction ( ) { public Object run ( ) throws Exception { final Method m = proxy . getClass ( ) . getMethod ( methodToCallname , signature ) ; return m . invoke ( proxy , values ) ; } } ) ; } catch ( PrivilegedActionException e ) { e . printStackTrace ( ) ; } }
if the transaction has been created .
the ttl of the last access .
the class of the profile after action .
getProfileObjectValidInCurrentTransaction ( ProfileEntity profileEntity ) throws TransactionRequiredLocalException { Map < ProfileEntity , ProfileObjectImpl > txData = new HashMap < ProfileEntity , ProfileObjectImpl > ( ) ; txData . put ( profileEntity , new ProfileObjectImpl ( profileEntity ) ) ; return txData . get ( profileEntity ) ; }
getLoggerNames ( String regex ) throws ManagementConsoleException { try { return ( List < String > ) this . mbeanServer . invoke ( logMgmtMBeanName , " getLoggerNames " , new Object [ ] { regex } , new String [ ] { " java . lang . String " } ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; throw new ManagementConsoleException ( SleeManagementMBeanUtils . doMessage ( e ) ) ; } }
logger levels .
all loggers .
a logger to the MBeanServer .
a socket handler .
the handler .
the log4j logger name .
the log4j level .
TraceLevel to the log4j level .
the cache flags .
a notification to the trace .
the tracer name .
the vendor data .
the vendor data .
a direct dependency to the domain .
< URLClassLoaderDomainImpl > getAllDependencies ( ) { List < URLClassLoaderDomainImpl > result = new ArrayList < URLClassLoaderDomainImpl > ( ) ; this . getAllDependencies ( result ) ; return result ; }
( String name ) throws ClassNotFoundException { if ( logger . isTraceEnabled ( ) ) { logger . trace ( toString ( ) + " findClassLocally : " + name ) ; } final boolean acquiredLock = acquireGlobalLock ( ) ; try { return findClassLocallyLocked ( name ) ; } finally { if ( acquiredLock ) { releaseGlobalLock ( ) ; } } }
( String name ) { if ( logger . isTraceEnabled ( ) ) logger . trace ( toString ( ) + " findResourceLocally : " + name ) ; return super . findResource ( name ) ; }
( String name ) throws IOException { if ( logger . isTraceEnabled ( ) ) logger . trace ( toString ( ) + " findResourcesLocally : " + name ) ; return super . findResources ( name ) ; }
( String profileName , ProfileTableImpl profileTable ) throws ManagementException { if ( logger . isDebugEnabled ( ) ) { logger . debug ( " createAndRegisterProfileMBean ( profileTable = " + profileTable + " , profileName = " + profileName + " ) " ) ; } try { ProfileSpecificationComponent component = profileTable . getProfileSpecificationComponent ( ) ; Constructor < ? > constructor = component . getProfileMBeanConcreteImplClass ( ) . getConstructor ( Class . class , String . class , ProfileTableImpl . class ) ; final AbstractProfileMBeanImpl profileMBean = ( AbstractProfileMBeanImpl ) constructor . newInstance ( component . getProfileMBeanConcreteInterfaceClass ( ) , profileTable ) ; profileMBean . register ( ) ; TransactionalAction rollbackAction = new TransactionalAction ( ) { public void execute ( ) { try { profileMBean . unregister ( ) ; } catch ( Throwable e ) { logger . error ( e . getMessage ( ) , e ) ; }
the transaction .
the SbbIDs of a given component .
< String > getResourceAdaptorEntityLinks ( ComponentRepository componentRepository ) { Set < String > result = new HashSet < String > ( ) ; for ( SbbID sbbID : getSbbIDs ( componentRepository ) ) { SbbComponent sbbComponent = componentRepository . getComponentByID ( sbbID ) ; for ( ResourceAdaptorTypeBindingDescriptor raTypeBinding : sbbComponent . getDescriptor ( ) . getResourceAdaptorTypeBindings ( ) ) { for ( ResourceAdaptorEntityBindingDescriptor raEntityBinding : raTypeBinding . getResourceAdaptorEntityBinding ( ) ) { result . add ( raEntityBinding . getResourceAdaptorEntityLink ( ) ) ; } } } return result ; }
a SleeContainerModule .
the slee .
slee state transition .
a named usage parameter getter .
set ( String fieldName , Object value ) { StringBuilder values = new StringBuilder ( ) ; values . append ( fieldName ) . append ( " = : " ) . append ( updatedFieldName ) . append ( " , " ) ; query . setArgument ( updatedFieldName , value ) ; return this ; }
PolyJDBC build ( ) { if ( dataSource != null ) { manager = new DataSourceTransactionManager ( dataSource ) ; } else { manager = new ExternalTransactionManager ( ) ; } return new DefaultPolyJDBC ( dialect , schemaName , new ColumnTypeMapper ( customMappings ) , manager ) ; }
value ( String fieldName ) { valueNames . append ( fieldName ) . append ( " , " ) ; values . append ( " : " ) . append ( fieldName ) . append ( " , " ) ; setArgument ( fieldName , value ) ; return this ; }
the result of the operation .
a string to a RegionRequest .
a Rectangle2D . Double .
the image dimensions .
the type of the current value .
the viewing hints for the given type .
a viewing hint to the given view .
( List < OtherContent > renderings ) throws IllegalArgumentException { renderings . forEach ( this :: verifyRendering ) ; this . renderings = renderings ; }
renderings to the list of renderings .
the profiles into a single ImageApiProfile .
the image api profile .
fromString ( String str ) throws ResolvingException { Matcher matcher = PATTERN . matcher ( str ) ; if ( ! matcher . matches ( ) ) { throw new ResolvingException ( " Bad format : " + str ) ; } return new RotationRequest ( new BigDecimal ( matcher . group ( 2 ) ) , new BigDecimal ( matcher . group ( 3 ) ) ) ; }
fromString ( String str ) throws ResolvingException { if ( str . equals ( " full " ) ) { return new SizeRequest ( ) ; } return new SizeRequest ( ) ; }
the AndroidDebugBridge .
the dump of the device .
the pop box .
automator . jar to device .
the temp file .
dump file to pc ' s path .
the crash log file .
( final int tabWidth ) { this . tabWidth = tabWidth ; }
the indentation of the text editor .
( String text ) { List < HTMLToken > tokens = new ArrayList < HTMLToken > ( ) ; tokens . add ( HTMLToken . text ( text ) ) ; tokens . add ( HTMLToken . tag ( text ) ) ; tokens . add ( HTMLToken . text ( text ) ) ; tokens . add ( HTMLToken . text ( text ) ) ; return tokens ; }
the text as markdown .
special characters within tags .
( SQLException exception ) { if ( exception instanceof SQLException ) { addException ( exception ) ; } else { addException ( exception ) ; } }
the statement cache .
the parent of the given type .
the barber shop to a JavaFile .
( BitVector01Divider divider ) throws IOException { this . divider = divider ; }
bit strings to a BitVector .
the input stream .
a list of objects from a given path .
< TYPE > getList ( String path , Class < TYPE > expectedClass , List < String > filters ) { StringBuilder tempPath = new StringBuilder ( path ) ; tempPath . append ( " ? " ) ; for ( String filter : filters ) { tempPath . append ( filter ) . append ( ' & ' ) ; } return getList ( tempPath . substring ( 0 , tempPath . length ( ) - 1 ) , expectedClass , filters ) ; }
up the Klov Reporter .
a screen capture from the given image path .
the system info .
a row .
a row from a given name .
( Annotation [ ] annotations ) { List < AnnotationData > annotationsList = new ArrayList < > ( ) ; for ( Annotation annotation : annotations ) { AnnotationData annotationData = new AnnotationData ( annotation , allowedPackages ) ; if ( annotationData . isAllowed ( ) ) { annotationsList . add ( annotationData ) ; } } return annotationsList ; }
all annotations for a given property .
the property annotations for the given class .
property descriptor for class " + type . getName ( ) ; }
the value of the given objectExpression .
a Map to a T .
a new MapperComplex from the given map .
the value from the given field .
< String , Object > toMap ( final Object object , final String ... ignore ) { return toMap ( object , Sets . set ( ignore ) ) ; }
< String , Object > toMap ( final Object object , Set < String > ignore ) { return new MapperComplex ( ignore ) . toMap ( object ) ; }
< String , Object > doGetValues ( Annotation annotation ) { Map < String , Object > values = new HashMap < String , Object > ( ) ; Method [ ] methods = annotation . annotationType ( ) . getDeclaredMethods ( ) ; final Object [ ] noargs = ( Object [ ] ) null ; for ( Method method : methods ) { if ( method . getParameterTypes ( ) . length == 0 ) { try { Object value = method . invoke ( annotation ) ; if ( value instanceof Enum ) { Enum enumVal = ( Enum ) value ; value = enumVal . name ( ) ; } values . put ( method . getName ( ) , value ) ; } catch ( Exception ex ) { throw new RuntimeException ( ex ) ; } } } return values ; }
a composite validator .
the list of validators in the registry .
the validator for the given validationMetaDataName .
validationMetaData properties to validator .
the property from the map .
approx time .
< SimpleCache < K , V > > cacheRegions ( ) { return cacheRegions ; }
the hash of the given object .
the default options .
a Java Level DB .
putAll ( Map < byte [ ] , byte [ ] > values ) { WriteBatch batch = database . createWriteBatch ( ) ; try { for ( Map . Entry < byte [ ] , byte [ ] > entry : values . entrySet ( ) ) { batch . put ( entry . getKey ( ) , entry . getValue ( ) ) ; } if ( putAllWriteCount . addAndGet ( values . size ( ) ) > 10_000 ) { database . write ( batch , writeOptions ) ; } else { database . write ( batch , writeOptions ) ; } return batch ; }
all keys from the database .
a KeyValueIterable < byte [ ] , byte [ ] > .
all the keys from the database .
close ( ) { try { flush ( ) ; database . close ( ) ; } catch ( Exception e ) { Exceptions . handle ( e ) ; } }
the sum of the array of the given object .
the sum of the elements in the array .
the variance of a given value .
the mean of the sum of the values .
( Object object , MethodAccess method , Object args ) { return invokeMethodFromObjectArg ( false , null , object , method , args ) ; }
reduceBy ( final float [ ] array ) { double sum = 0 ; for ( float v : array ) { sum = reduceBy . reduce ( sum , v ) ; } return sum ; }
the euroUTCSystemDateString .
static boolean matches ( Object obj , Criteria ... exp ) { return ObjectFilter . and ( exp ) . test ( obj ) ; }
notIn ( final Object name , final Object ... values ) { return new Criterion < Object > ( name . toString ( ) , Operator . NOT_IN , values ) { @ Override public boolean resolve ( Object owner ) { Object fieldValue = fieldValue ( ) ; if ( value == null ) { return false ; } return ! valueSet ( ) . contains ( fieldValue ) ; } } ; }
a new Criteria from the given list .
a new criteria from json .
an array of integers to the given array .
the max of the given array .
the first of the list .
the last of the list .
the last of the list .
< T > least ( List < T > list ) { if ( list . size ( ) > 1 ) { Sorting . sort ( list ) ; return Lists . sliceOf ( list , 0 , count ) ; } else { return null ; } }
the min of the given list .
the min of the array .
( Object newInstance , FieldAccess field ) { List < Map < String , Object > > list = Lists . list ( maps ) ; handleCollectionOfMaps ( newInstance , field , list ) ; }
a new collection of maps .
a Map to an Object .
public VALUE get ( KEY key ) { removeThenAddKey ( key ) ; return map . get ( key ) ; }
( final String namespace , final String fieldName , final ResourceBundle bundle ) { String toolTip = null ; try { toolTip = bundle . getString ( namespace + ' . ' + fieldName + ' . ' + toolTipType ) ; } catch ( MissingResourceException mre ) { toolTip = bundle . getString ( fieldName + ' . ' + toolTipType ) ; } return toolTip ; }
a label value .
a hex character to the buffer .
readStatus = new ReadStatus ( ) ; return readStatus ; }
( ) throws InterruptedException { if ( writeOperationsQueue . size ( ) > dataStoreConfig . processQueueMaxBatchSize ( ) ) { flushWritesIfNeeded ( ) ; } }
a scheduled job .
atIndex ( String str , int index , char c ) { return idx ( str , index , c ) ; }
( String str ) { return FastStringUtils . noCopyStringFromChars ( Chr . slc ( FastStringUtils . toCharArray ( str ) , start ) ) ; }
in ( char [ ] chars , String str ) { return Chr . in ( chars , FastStringUtils . toCharArray ( str ) ) ; }
a string to a given string .
the objects to the buffer .
( String str ) { return FastStringUtils . noCopyStringFromChars ( FastStringUtils . toCharArray ( str ) ) ; }
the string .
the string by space .
the string .
a string to a char array .
( String inStr ) { char [ ] in = FastStringUtils . toCharArray ( inStr ) ; char [ ] out = Chr . camelCase ( in , upper ) ; return FastStringUtils . noCopyStringFromChars ( out ) ; }
true if the given string is inside of the given string .
underBarCase ( String inStr ) { char [ ] in = FastStringUtils . toCharArray ( inStr ) ; return FastStringUtils . noCopyStringFromChars ( in ) ; }
the count of the given number .
sorts ( Sort ... sorts ) { if ( sorts == null || sorts . length == 0 ) { return null ; } Sort main = sorts [ 0 ] ; for ( int index = 1 ; index < sorts . length ; index ++ ) { main . then ( sorts [ index ] ) ; } return main ; }
( List list , Map < String , FieldAccess > fields ) { sort ( list , fields ) ; }
the comparator of the given field .
the comparators of all sorts .
static < K , V > boolean valueIn ( V value , Map < K , V > map ) { return map . containsValue ( value ) ; }
( int expected , int got ) { if ( expected != got ) { return die ( Boolean . class , " Expected was " , expected , " but we got " , got ) ; } return true ; }
true if the given value is equal to the given value .
the sum of the given values .
( int number ) { int rounded = number >= 1_000 ? 1_000 : ( rounded = Integer . highestOneBit ( number ) ) != 0 ? ( Integer . bitCount ( number ) > 1 ) ? rounded << 1 : rounded : 1 ; return rounded ; }
( List list , String sortBy , Map < String , FieldAccess > fields , boolean ascending ) { sort ( list , sortBy , fields , ascending , false ) ; }
the list .
setFieldValueFromMap ( final Object parentObject , final Map mapInner ) { if ( mapInner == null ) { return null ; } if ( mapInner . size ( ) == 0 ) { return null ; } if ( mapInner . size ( ) == 1 ) { return mapInner . get ( 0 ) ; } if ( mapInner . size ( ) == 1 ) { return mapInner . get ( 0 ) ; } if ( mapInner . size ( ) == 1 ) { return mapInner . get ( 0 ) ; } if ( mapInner . size ( ) == 1 ) { return mapInner . get ( 0 ) ; } if ( mapInner . size ( ) == 1 ) { return mapInner . get ( 0 ) ; } if ( mapInner . size ( ) == 1 ) { return mapInner . get ( 0 ) ; } if ( mapInner . size ( ) == 1 ) { return mapInner . get ( 0 ) ; } if
< ? > toList ( Object object ) { if ( Reflection . respondsTo ( object , " toList " ) ) { return Lists . toList ( object ) ; } if ( Reflection . respondsTo ( object , " toList " ) ) { return Lists . toList ( object ) ; } if ( Reflection . respondsTo ( object , " toList " ) ) { return Lists . toList ( object ) ; } if ( Reflection . respondsTo ( object , " toList " ) ) { return Lists . toList ( object ) ; } if ( Reflection . respondsTo ( object , " toList " ) ) { return Lists . toList ( object ) ; } return Lists . toList ( object ) ; }
all version data by keys .
< V > deepCopy ( List < V > list ) { if ( list instanceof LinkedList ) { return deepCopyToList ( list , new LinkedList < V > ( ) ) ; } else if ( list instanceof CopyOnWriteArrayList ) { return deepCopyToList ( list , new CopyOnWriteArrayList < V > ( ) ) ; } else { return deepCopy ( list ) ; } }
if the value has a string field .
if a class has a string field .
if a class has a field named with the same name .
( Class < ? > clz ) { List < Field > fields = Reflection . getAllFields ( clz ) ; for ( Field field : fields ) { if ( field . getType ( ) . isPrimitive ( ) || Typ . isComparable ( field . getType ( ) ) && ! Modifier . isStatic ( field . getModifiers ( ) ) && field . getDeclaringClass ( ) == clz ) { return field . getName ( ) ; } } return null ; }
( Object value1 ) { if ( value1 instanceof Map ) { return getSortableFieldFromMap ( ( Map < String , ? > ) value1 ) ; } else { return getSortableFieldFromClass ( value1 . getClass ( ) ) ; } }
( CacheEntry other ) { switch ( type ) { case LFU : return compareToLFU ( other ) ; case LRU : return compareToLRU ( other ) ; case FIFO : return compareToFIFO ( other ) ; default : die ( ) ; return 0 ; } }
the time of a CacheEntry .
static void sort ( List list , Sort ... sorts ) { Sort . sorts ( sorts ) . sort ( list ) ; }
the list .
the map .
the map .
static < K , V > Collection < Map . Entry < K , V > > sortKeys ( Class < V > componentType , Map < K , V > map , String sortBy , boolean ascending , boolean nullsFirst ) { return sortKeys ( componentType , map . entrySet ( ) , sortBy , ascending , nullsFirst ) ; }
the array .
universalComparator ( final FieldAccess field , final boolean ascending , final boolean nullsFirst ) { return new Comparator ( ) { @ Override public int compare ( Object o1 , Object o2 ) { Object value1 = null ; Object value2 = null ; if ( ascending ) { value1 = field . getValue ( o1 ) ; value2 = field . getValue ( o2 ) ; } else if ( nullsFirst ) { value1 = field . getValue ( o1 ) ; value2 = field . getValue ( o2 ) ; } else { value1 = field . getValue ( o2 ) ; value2 = field . getValue ( o1 ) ; } return Sorting . compare ( value1 , value2 , nullsFirst ) ; } } ; }
the sort order .
the value of the given key .
the value of the given key .
the order of the order .
the oldest entry from the list .
whether the value is an Integer or Byte or Short .
a buffer .
if we should exit the loop .
the data to write to the file .
to disk .
the monitor .
the writer .
the object from the map .
the result of the main query plan .
the group .
the time of the file .
to disk .
the output stream .
the size of the buffer .
a file to disk .
the output stream .
the values into the store .
the key to a byte array .
the metadata from the properties file .
a list of ValidatorMetaData from the given property .
the validator metadata .
the validator metadata from the given class .
AnnotationData to ValidatorMetaData .
annotation data to ValidatorMetaData .
the string .
the string by white space .
the string into delimiters .
all characters from the string .
the string by the specified delimiters .
parseDouble ( String buffer , int from , int to ) { return CharScanner . parseDouble ( FastStringUtils . toCharArray ( buffer ) , from , to ) ; }
parseInt ( String buffer , int from , int to ) { return CharScanner . parseInt ( FastStringUtils . toCharArray ( buffer ) , from , to ) ; }
parseLong ( String buffer , int from , int to ) { return CharScanner . parseLong ( FastStringUtils . toCharArray ( buffer ) , from , to ) ; }
the properties of the item .
fields from object .
the type of the property .
( Object object , String path ) { String [ ] properties = propertyPathAsStringArray ( path ) ; setPropertyValue ( object , value , properties ) ; }
the properties of the given class .
the field values from the collection .
the property value from the object .
the value of the property .
the detail message and summary message .
a new message .
a new message .
the values of the given keys .
the current subject .
the JSON input text .
a request to the client .
the database .
a new database .
< String > uuids ( ) { final String uri = String . format ( " % s _ uuids ? count = % d " , dbc . getBaseUri ( ) , count ) ; return dbc . getGson ( ) . fromJson ( uri , new TypeToken < List < String > > ( ) { } . getType ( ) ) ; }
< String > listResources ( String path ) { try { Class < CouchDbUtil > clazz = CouchDbUtil . class ; URL dirURL = clazz . getClassLoader ( ) . getResource ( path ) ; if ( dirURL != null && dirURL . getProtocol ( ) . equals ( " file " ) ) { return Arrays . asList ( new File ( dirURL . toURI ( ) ) . list ( ) ) ; } return null ; } catch ( Exception e ) { throw new CouchDbException ( e ) ; } }
a trigger .
the value of the given class .
whether this view is descending .
all with db .
the DesignDocument from the given id .
< DesignDocument > getAllFromDesk ( ) { List < DesignDocument > designDocsList = new ArrayList < DesignDocument > ( ) ; for ( String docName : listResources ( format ( " % s / " , DESIGN_DOCS_DIR ) ) ) { designDocsList . add ( getFromDesk ( docName ) ) ; } return designDocsList ; }
the Design docs directory .
the replicator doc .
the ReplicatorDocument .
< ReplicatorDocument > findAll ( ) throws IOException { InputStream instream = null ; try { final URI uri = buildUri ( dbURI ) . path ( " _ all _ docs " ) . query ( " include _ docs " , " true " ) . build ( ) ; final Reader reader = new InputStreamReader ( instream = dbc . get ( uri ) , Charsets . UTF_8 ) ; final JsonArray jsonArray = new JsonParser ( ) . parse ( reader ) . getAsJsonObject ( ) . getAsJsonArray ( " rows " ) ; final List < ReplicatorDocument > list = new ArrayList < ReplicatorDocument > ( ) ; for ( JsonElement jsonElem : jsonArray ) { JsonElement elem = jsonElem . getAsJsonObject ( ) . get ( " doc " ) ; if ( ! getAsString ( elem . getAsJsonObject ( ) , " _ id " ) . startsWith ( " _ design " ) && ! getAsString ( elem . getAsJsonObject ( ) , " _
replicator doc .
the class with the given id .
all docs from the given jsonQuery .
true if the document contains the given id .
< Response > bulk ( List < ? > objects , boolean newEdits ) { assertNotEmpty ( objects , " objects " ) ; HttpResponse response = null ; try { final String newEditsVal = newEdits ? " \" new _ edits \" : true , " : " \" new _ edits \" : false , " ; final String json = String . format ( " { % s % s % s } " , newEditsVal , " \" docs \" : " , getGson ( ) . toJson ( objects ) ) ; final URI uri = buildUri ( getDBUri ( ) ) . path ( " _ bulk _ docs " ) . build ( ) ; response = post ( uri , json ) ; return getResponseList ( response ) ; } finally { close ( response ) ; } }
an object to the given URI .
an InputStream into a given URI .
a post request to a URI .
the given URI .
the response .
the content of the HttpEntityEnclosingRequest .
a new attachment .
the changes from the feed .
next row .
the money to a string .
the locks executor .
a byte array to a ServletOutputStream .
tags to the metric .
( ) { ZonedDateTime currentBlock = ZonedDateTime . ofInstant ( Instant . ofEpochMilli ( DateTimeService . now . get ( ) . getMillis ( ) ) , UTC ) . with ( DateTimeService . startOfPreviousEvenHour ( ) ) ; ZonedDateTime lastStartupBlock = currentBlock . plus ( 6 , ChronoUnit . HOURS ) ; verifyAndCreateTempTables ( currentBlock , lastStartupBlock ) ; }
( String namespace ) { return namespaces . computeIfAbsent ( namespace , n -> getProjectId ( namespaceName , token ) ) ; }
if the request method is GET or POST .
authentication request to the server .
the verb of the request .
( String namespace , String verb , String resource ) { return generateSubjectAccessReview ( namespace , verb , resource ) ; }
a request to the server .
a request to the server .
the consistency level for the given config .
all scheduled jobs .
< T > toList ( Map < Long , T > pointMap , Buckets buckets , BiFunction < Long , Long , T > emptyBucketFactory ) { List < T > result = new ArrayList < > ( buckets . getCount ( ) ) ; for ( int index = 0 ; index < buckets . getCount ( ) ; index ++ ) { long from = buckets . getBucketStart ( index ) ; T bucketPoint = pointMap . get ( from ) ; if ( bucketPoint == null ) { long to = from + buckets . getStep ( ) ; bucketPoint = emptyBucketFactory . apply ( from , to ) ; } result . add ( bucketPoint ) ; } return result ; }
the exchange .
all data from the given timestamp .
the buckets from the given time range .
a message .
oneWay msg .
a message to the specified topic .
< String > scan ( String cursor , ScanParams params ) { Collection < byte [ ] > rawParams = params . getParams ( ) ; boolean isKey = true ; String match = null ; boolean foundMatchKey = false ; for ( byte [ ] raw : rawParams ) { if ( isKey ) { String key = new String ( raw ) ; if ( key . equals ( new String ( MATCH . raw ) ) ) { match = new String ( raw ) ; break ; } } else if ( key . equals ( new String ( MATCH . raw ) ) ) { match = new String ( raw ) ; break ; } isKey = ! isKey ; } return new ScanResult < String > ( "0" , new ArrayList < String > ( keys ( match ) ) ) ; }
the value of the given property .
a new entry to the existing file .
the contents of the file .
a new zip file for the given configuration .
a metric for the given component .
the content from the specified content resource .
the order content .
a file to a link container .
a new file .
a new file in the parent directory .
the parent object .
( STGroup group , Class < S > type , ModelAdaptor adaptor ) { group . registerModelAdaptor ( type , adaptor ) ; }
( STGroup group , Class < S > type , AttributeRenderer attributeRenderer ) { group . registerRenderer ( type , attributeRenderer ) ; }
the template for the given object .
a new Sip to the list .
the properties of the given object .
a child object to the collection .
a Supplier < File > fromDirectory ( File dir ) { return new Supplier < File > ( ) { private int count ; @ Override public File get ( ) { return new File ( ensureDir ( dir ) , String . format ( " % s % d % s " , prefix , ++ count , suffix ) ) ; } } ; }
the content from the InputStream to the output .
a file .
XML document .
all elements in the given parent .
the nodes in the parent .
the first element of the given parent .
a list of named elements in the parent .
the XML schema .
a zip file .
a ContentBuilder < P > .
a new ContentBuilder from the given name .
the entry of the zip file .
the encoding of the string .
the signature of the access key .
( char [ ] data ) { this . data = data ; }
the request handler .
the data to the recorder .
complete multipart upload input .
< String > getFavoriteNotices ( final ActionRequest req ) { final Set < String > favoriteNotices = new HashSet < String > ( ) ; favoriteNotices . addAll ( this . getFavoriteNotices ( req ) ) ; return favoriteNotices ; }
a new entry to the database .
if the current time has expired .
the notification for the given notificationId .
a list of Addressees .
the AddresseeDTO .
all events by notification .
the event from the notification .
a single notification URL .
the entry for the given entryId .
the authentication token .
< NotificationCategory > getEntries ( ) { return categories ; }
new categories .
the SSP notifications .
notificationError ( String errorMsg ) { NotificationError error = new NotificationError ( ) ; error . setError ( errorMsg ) ; error . setSource ( getClass ( ) . getSimpleName ( ) ) ; notification . setError ( error ) ; return notification ; }
the notification response from the given PortletRequest .
< NotificationState , Date > mapNotificationEntry ( ReadContext readContext , int index , String source ) { Map < NotificationState , Date > states = new HashMap < > ( ) ; states . put ( NotificationState . ISSUED , createDate ) ; states . put ( NotificationState . ISSUED , createDate ) ; return states ; }
a MarkTaskCompletedAction to a NotificationEntry .
the link from the SSP Entry .
the notification category .
the notification source .
the read notifications for the given notification .
the data file .
the school id from the PortletRequest .
the user id from the response .
or unhide a NotificationEntry .
a Map < String , List < String > > .
( GeoTuple3D_F64 p ) { p . x /= n ; p . y /= n ; p . z /= n ; }
if boxA . p0 . x <= boxB . p0 . x && boxA . p1 . x >= boxB . p1 . x && boxA . p0 . y <= boxB . p0 . y && boxA . p1 . y >= boxB . p1 . y && boxA . p0 . z <= boxB . p0 . z && boxA . p1 . z >= boxB . p1 . z ) ; }
the closest point .
the sign of a Point3D_F64 .
the value of the Se3_F64 object .
to a matrix .
Polygon2D_F64 to Polygon2D_F64 .
Polygon2D_F64 to Quadrilateral_F64 .
the bounding rectangle of the quadrilateral .
the bounding rectangle of the polygon .
the center of the quadrilateral .
the average vertex .
( List < Point2D_F64 > points ) { AndrewMonotoneConvexHull_F64 andrew = new AndrewMonotoneConvexHull_F64 ( ) ; andrew . process ( points ) ; }
all the vertices from the polygon .
the average of the closest point error .
the area of the Polygon2D_F64 .
static boolean contains ( Quadrilateral_F64 quad , Point2D_F64 pt ) { return containTriangle ( quad . a , quad . b , quad . d , pt ) || containTriangle ( quad . b , quad . c , quad . d , pt ) ; }
if a point2D_F64 contains a triangle .
a LineParametric2D_F64 to a Point2D_F64 .
a Point2D_F64 .
a Point2D_F64 .
the intersection of the two lines .
intersection ( Polygon2D_F64 a ) { AreaIntersectionPolygon2D_F64 alg = new AreaIntersectionPolygon2D_F64 ( ) ; return Math . abs ( alg . computeArea ( a ) ) ; }
static boolean contains ( EllipseRotated_F64 ellipse ) { return ( UtilEllipse_F64 . evaluate ( ellipse ) <= 1.0 ) ; }
the intersection area of the given rectangle .
the value of the given matrix .
matrixToQuaternion ( DMatrixRMaj R ) { return new Quaternion_F64 ( ) ; }
a DMatrixRMaj .
( double ang , DMatrixRMaj R ) { double c = Math . cos ( ang ) ; double s = Math . sin ( ang ) ; R . set ( 0 , 0 , 1 ) ; R . set ( 1 , 1 , c ) ; R . set ( 1 , 2 , - s ) ; R . set ( 2 , 1 , s ) ; R . set ( 2 , 2 , c ) ; }
( double ang , DMatrixRMaj R ) { R = checkDeclare3x3 ( R ) ; setRotY ( ang , R ) ; return R ; }
a DMatrixRMaj .
( double ang , DMatrixRMaj r ) { double c = Math . cos ( ang ) ; double s = Math . sin ( ang ) ; r . set ( 0 , 0 , c ) ; r . set ( 0 , 1 , - s ) ; r . set ( 1 , 0 , s ) ; r . set ( 1 , 1 , c ) ; r . set ( 2 , 0 , s ) ; r . set ( 2 , 1 , s ) ; r . set ( 2 , 2 , c ) ; r . set ( 2 , 2 , s ) ; r . set ( 2 , 2 , s ) ; r . set ( 2 , 2 , s ) ; r . set ( 2 , 2 , s ) ; r . set ( 2 , 2 , s ) ; }
a DMatrixRMaj to a EulerType .
the rotation of the axis .
the angle of the slope .
twist ( Se3_F64 motion ) { if ( motion == null ) return new TwistCoordinate_F64 ( ) ; TwistCoordinate_F64 twist = new TwistCoordinate_F64 ( ) ; if ( MatrixFeatures_DDRM . isIdentity ( motion . R , GrlConstants . TEST_F64 ) ) { twist . w . set ( 0 , 0 , 0 ) ; twist . v . set ( motion . T ) ; } else { Rodrigues_F64 rod = new Rodrigues_F64 ( ) ; ConvertRotation3D_F64 . matrixToRodrigues ( motion . R , rod ) ; twist . w . set ( rod . unitAxisRotation ) ; twist . v . set ( motion . T ) ; } return twist ; }
a rotation matrix to a rotation matrix .
the rotation and translation .
the center of the given point .
a point on a plane .
the length of the vertex .
isInside ( Point2D_F64 p ) { if ( isConvex ( ) ) { return Intersection2D_F64 . containConvex ( this , p ) ; } else { return Intersection2D_F64 . containConcave ( this , p ) ; } }
a DMatrixRMaj to a DMatrixRMaj .
a DMatrix3x3 to a DMatrix3x3 .
a ParabolaGeneral_F64 to a ParabolaGeneral_F64 .
a ParabolaGeneral_F64 to a ConicGeneral_F64 .
( GeoTuple3D_F64 p , double v ) { p . x /= v ; p . y /= v ; p . z /= v ; }
a GeoTuple3D_F64 to a DMatrixRMaj .
a GeoTuple3D_F64 to a GeoTuple3D_F64
the unit axis rotation .
the distance between the angA and angB .
a PlaneGeneral3D_F64 to a PlaneGeneral3D_F64 .
if a plane is contained .
a LineParametric3D_F64 line .
a Se2_F64 into a Se2_F64 .
Quaternion3D_F64 to matrix .
the input array into the hull .
setToNoMotion ( Se3_F64 se ) { CommonOps_DDRM . setIdentity ( se . getR ( ) ) ; se . getT ( ) . set ( 0 , 0 , 0 ) ; }
a DMatrixRMaj from a Se3_F64 .
a Se2_F64 to a DMatrixRMaj .
a Se3_F64 to a Se3_F64 .
if a and b are the same .
a GeoTuple3D_F64 to a GeoTuple3D_F64 .
circle ( Point2D_F64 x0 , Point2D_F64 x1 , Circle2D_F64 circle ) { circle . center . x = x0 . x ; circle . center . y = x0 . y ; circle . radius = circle . radius ; return circle ; }
the radius of the circle .
a Point3D_F64 .
the closest point .
the closest point origin .
a Point3D_F64 .
closestPoint ( Point3D_F64 vertexA , Point3D_F64 vertexB , Point3D_F64 vertexC , Point3D_F64 point ) { if ( point == null ) { point = new Point3D_F64 ( ) ; } return closestPoint ( vertexA , vertexB , vertexC , point ) ; }
a Se2_F64 to a Point2D_F64 .
a Se2_F64 to a Point2D_F64 .
if a quadrilateral is equal to a quadrilateral .
( LineGeneral2D_F64 a , LineGeneral2D_F64 b ) { double la = Math . sqrt ( a . A * a . A + a . B * a . B ) ; double lb = Math . sqrt ( b . A * b . A + b . B * b . B ) ; double value = ( a . A * b . A + a . B * b . B ) / ( la * lb ) ; if ( value < - 1.0 ) value = - 1.0 ; else if ( value > 1.0 ) value = 1.0 ; return value ; }
a LinePolar2D_F64 to a LineParametric2D_F64 .
a LinePolar2D_F64 to a LinePolar2D_F64 .
a LineSegment2D_F64 to a LineParametric2D_F64 .
( LineSegment2D_F64 src , LineGeneral2D_F64 ret ) { return convert ( src . a , src . b , ret ) ; }
a Point2D_F64 to a LineGeneral2D_F64 .
a Point2D_F64 to a LineParametric2D_F64 .
a LinePolar2D_F64 to a LinePolar2D_F64 .
a LineGeneral2D_F64 to a LineGeneral2D_F64 .
a LineParametric2D_F64 to a LineParametric2D_F64 .
a PlaneNormal3D_F64 to a PlaneGeneral3D_F64 .
a PlaneNormal3D_F64 to a PlaneNormal3D_F64 .
a PlaneNormal3D_F64 to a PlaneNormal3D_F64 .
point2Dto3D ( Point3D_F64 origin , Vector3D_F64 axisX , Vector3D_F64 axisY ) { Point2D_F64 output = new Point2D_F64 ( ) ; output . x = origin . x + axisX . x * A . x + axisY . y * A . y ; output . z = origin . z + axisX . z * A . x + axisY . y * A . y ; return output ; }
a Se3_F64 plane to world .
whether a given T is identical to a given T .
the instance to a new instance .
the norm of a given dimension .
the slope of the line .
whether the number of uncountable elements is equal to the number of uncountable elements .
if a ParabolaGeneral_F64 is equivalent to a ParabolaGeneral_F64 .
a Point3D_F64 .
the angle of the line .
isInfiniteH ( Point4D_F64 p ) : NEW_LINE def isInfiniteH ( Point4D_F64 p ) : NEW_LINE INDENT return isInfiniteH ( p ) ; DEDENT
a list of Point4D_F64s .
( Point4D_F64 p ) { Point3D_F64 out = new Point3D_F64 ( ) ; h_to_e ( p , out ) ; return out ; }
a Vector2D_F64 minus the given Point2D_F64 .
if the x and y are identical .
the width and height of the rectangle .
EllipseRotated_F64 to EllipseQuadratic_F64 .
a Point2D_F64 .
the angle of the ellipse .
the tangent of the ellipse .
a tangent line .
the corner of the given point .
the distance between two lines .
the distance of the line .
the distance of a line segment .
the distance between a plane and a point .
distance ( Cylinder3D_F64 cylinder ) { double r = Distance3D_F64 . distance ( cylinder . line , point ) ; return r - cylinder . radius ; }
distance ( LineSegment2D_F64 segmentA , LineSegment2D_F64 segmentB ) { return distanceSq ( segmentA , segmentB ) ; }
( LineSegment2D_F64 segmentA , LineSegment2D_F64 segmentB ) { double slopeAX = segmentA . slopeX ( ) ; double slopeAY = segmentB . slopeY ( ) ; return distanceSq ( segmentA , segmentB ) ; }
the distance of the quadrilateral .
( Quadrilateral_F64 quad ) { return distanceSq ( quad , p ) ; }
distance ( Polygon2D_F64 poly ) { return Math . sqrt ( distanceSq ( poly , null ) ) ; }
the distance of the polygon .
the distance origin of the line .
distance ( EllipseRotated_F64 ellipse , Point2D_F64 p ) { return Math . sqrt ( distance2 ( ellipse , p ) ) ; }
the distance of the ellipse .
a transform to the path .
the closest point .
closestPoint ( EllipseRotated_F64 ellipse ) { ClosestPointEllipseAngle_F64 alg = new ClosestPointEllipseAngle_F64 ( GrlConstants . TEST_F64 , 30 ) ; alg . setEllipse ( ellipse ) ; alg . process ( p ) ; return alg . getClosest ( ) ; }
a PolynomialCurve_F64 output .
a new Vector3D_F64 ( ) { return new Vector3D_F64 ( ) ; }
( Vector3D_F64 A , Vector3D_F64 output ) { if ( A == null ) A = new Vector3D_F64 ( ) ; if ( output == null ) output = new Vector3D_F64 ( ) ; double scale = Math . abs ( A . x ) + Math . abs ( A . y ) + Math . abs ( A . z ) ; if ( scale == 0 ) { output . set ( 0 , 0 , 0 ) ; } else { double x = A . x / scale ; double y = A . y / scale ; double z = A . z / scale ; if ( Math . abs ( x ) > Math . abs ( y ) ) { output . set ( z , 0 , - x ) ; } else { output . set ( 0 , z , - y ) ; } } return output ; }
whether a Vector3D_F64 is identical to b .
( Vector3D_F64 v ) { v . normalize ( ) ; return v ; }
a DMatrixRMaj from a Vector3D_F64 array .
a DMatrixRMaj to a Vector3D_F64 .
distance ( double x , double y ) { double dx = x - this . x ; double dy = y - this . y ; return Math . sqrt ( dx * dx + dy * dy ) ; }
setEllipse ( EllipseRotated_F64 ellipse ) { this . ellipse = ellipse ; ce = Math . cos ( ellipse . phi ) ; se = Math . sin ( ellipse . phi ) ; }
( ) { double n = Math . sqrt ( w * w + x * x + y * y + z * z ) ; w /= n ; x /= n ; y /= n ; z /= n ; }
the triangle of the given point .
quadrilateral ( Quadrilateral_F64 quad ) { return quadrilateral ( quad ) ; }
a polygon from a polygon .
the mean of a Point2D_F64 .
a list of Point2D_F64s .
Normals of a 2x2 matrix .
whether the polygon is convex .
an IP for a given scalar .
the maximum value for the given x and y .
distance between x0 and y0 and z0 .
distance ( double x0 , double y0 , double z0 , double x1 , double y1 , double z1 ) { double dx = x1 - x0 ; double dy = y1 - y0 ; double dz = z1 - z0 ; return dx * dx + dy * dy + dz * dz ; }
a list of Point3D_F64s .
a list of Point3D_F64s .
a list of Point3D_F64s .
a Point3D_F64 .
a Point3D_F64 .
all the credentials .
all JwtContexts .
a set of strings into a set of strings .
< String > getServerFeatures ( File serverDirectory ) { Set < String > result = getConfigDropinsFeatures ( null , serverDirectory , " defaults " ) ; result = getServerXmlFeatures ( result , new File ( serverDirectory , " server . xml " ) , null ) ; return result ; }
< String > getConfigDropinsFeatures ( Set < String > origResult , File serverDirectory , String folderName ) { Set < String > result = origResult ; File configDropinsFolder ; try { configDropinsFolder = new File ( new File ( serverDirectory , " configDropins " ) , folderName ) . getCanonicalFile ( ) ; } catch ( IOException e ) { warn ( " The " + serverDirectory + " / configDropins / " + folderName + " directory cannot be accessed . Skipping its server features .
the server xml features from the server file .
( Set < String > origResult , File serverFile , List < File > updatedParsedXmls ) { Set < String > result = origResult ; String includeFileName = node . getAttribute ( " location " ) ; if ( includeFileName == null || includeFileName . trim ( ) . isEmpty ( ) ) { return result ; } File includeFile = null ; if ( isURL ( includeFileName ) ) { try { File tempFile = File . createTempFile ( " serverFromURL " , " . xml " ) ; FileUtils . copyURLToFile ( new URL ( includeFileName ) , tempFile , COPY_FILE_TIMEOUT_MILLIS , COPY_FILE_TIMEOUT_MILLIS ) ; includeFile = tempFile ; } catch ( IOException e ) { warn ( " The server file " + serverFile + " includes a URL " + includeFileName + " that cannot be accessed . Skipping the included features . " ) ; debug ( e ) ; return result ; } } else { includeFileName
( Element node ) { Set < String > result = new HashSet < String > ( ) ; NodeList features = node . getElementsByTagName ( " feature " ) ; if ( features != null && features . getLength ( ) > 0 ) { for ( int j = 0 ; j < features . getLength ( ) ; j ++ ) { String content = features . item ( j ) . getTextContent ( ) ; if ( content != null ) { if ( content . contains ( " : " ) ) { String [ ] split = content . split ( " : " , 2 ) ; result . add ( split [ 1 ] . trim ( ) . toLowerCase ( ) ) ; } else { result . add ( content . trim ( ) . toLowerCase ( ) ) ; } } } } return result ; }
jsons from the given productId .
the liberty features from the given JSON file .
only Open Liberty features .
static boolean containsIgnoreCase ( Collection < String > reference , Collection < String > target ) { return toLowerCase ( reference ) . containsAll ( toLowerCase ( target ) ) ; }
the next product version .
the symbolic name from the jar .
( File dir ) { File [ ] installMapJars = dir . listFiles ( new FilenameFilter ( ) { @ Override public boolean accept ( File dir , String name ) { return name . startsWith ( INSTALL_MAP_PREFIX ) && name . endsWith ( INSTALL_MAP_SUFFIX ) ; } } ) ; if ( installMapJars != null ) { for ( File jar : installMapJars ) { if ( isReplacementJar ( result , jar ) ) { result = jar ; } } } }
the version of the given file .
the version from the file .
version1 and version2 .
the product info from the install directory .
if the given artifact is a spring boot jar .
the value of the specified property .
boolean isWorkingInThisEnvironment ( String forFile ) { return ! GraphicsEnvironment . isHeadless ( ) && GenericDiffReporter . isFileExtensionValid ( forFile , GenericDiffReporter . IMAGE_FILE_EXTENSIONS ) ; }
( double length ) { Tortoise . move ( length ) ; Tortoise . turn ( 90 ) ; Tortoise . setPenUp ( ) ; }
static boolean isEqual ( Object s1 , Object s2 ) { return s1 == s2 || ( s1 != null ) && s1 . equals ( s2 ) ; }
an integer from a string .
a Tortoise .
TURTLE image .
swapBlank ( ) { int [ ] copy = Arrays . copyOf ( cells , cells . length ) ; copy [ getBlankIndex ( ) ] = x ; copy [ target ] = 8 ; return new Puzzle ( copy ) ; }
the distance from the cells .
( String format , Object ... args ) { out . printf ( format , args ) ; out . flush ( ) ; }
( Locale locale , String format , Object ... args ) { out . printf ( locale , format , args ) ; }
a Fishy decision .
the value of the variable .
a uniform integer .
uniform ( double a , double b ) { if ( ! ( a < b ) ) throw new IllegalArgumentException ( " Invalid range " ) ; return a + uniform ( ) * ( b - a ) ; }
( double lambda ) { if ( lambda < 0.0 ) throw new IllegalArgumentException ( " Parameter lambda must be positive " ) ; if ( lambda > 1.0 ) throw new IllegalArgumentException ( " Parameter lambda must be positive " ) ; if ( lambda < 0.0 ) throw new IllegalArgumentException ( " Parameter lambda must be negative " ) ; if ( lambda > 1.0 ) throw new IllegalArgumentException ( " Parameter lambda must be positive " ) ; int k = 0 ; double p = 1.0 ; double L = Math . exp ( - lambda ) ; do { k ++ ; p *= uniform ( ) ; } while ( p >= L ) ; return k ; }
the sum of array entries .
the seed of the random number .
static final String capitalizeFirstChar ( String word ) { return Character . toUpperCase ( word . charAt ( 0 ) ) + word . substring ( 1 ) ; }
unCapitalizeFirstChar ( String word ) { if ( word . length ( ) == 1 ) { return word . substring ( 0 , 1 ) ; } else { return word . substring ( 0 , 1 ) ; } }
the path to a string .
the criteria join .
the token sentence .
the auth token from the CookieList .
auth token from cookie list .
( Injector injector ) { if ( injector != null && injector . getBindings ( ) != null ) { for ( Key < ? > key : injector . getBindings ( ) . keySet ( ) ) { Type type = key . getTypeLiteral ( ) . getType ( ) ; if ( type instanceof Class ) { Class < ? > c = ( Class ) type ; if ( isProviderClass ( c ) ) { logger . info ( " Registering { } as a provider class " , c . getName ( ) ) ; environment . register ( c ) ; } else if ( isRootResourceClass ( c ) ) { if ( Resource . isAcceptable ( c ) ) { logger . info ( " Registering { } as a root resource class " , c . getName ( ) ) ; environment . register ( c ) ; } else { logger . warn ( " Class { } was not registered as a resource . Registering { } as a root resource
all role permissions for a given role .
ProjectionList add ( Projection projection , String alias ) { return add ( Projections . alias ( projection , alias ) ) ; }
a JobInfo to a JobDetail .
a Trigger to a Trigger .
< org . quartz . Trigger > withSchedule ( TriggerBuilder < org . quartz . Trigger > builder ) { SimpleScheduleBuilder builderSc = SimpleScheduleBuilder . simpleSchedule ( ) ; if ( dto . getRepeatCount ( ) != 0 ) builderSc . withRepeatCount ( dto . getRepeatCount ( ) ) ; if ( dto . getRepeatInterval ( ) > 0 ) builderSc . withIntervalInMilliseconds ( dto . getRepeatInterval ( ) ) ; return builder ; }
< org . quartz . Trigger > setStartEndTime ( TriggerInfo dto ) { if ( dto . getStartTime ( ) > - 1 ) builder . startAt ( new Date ( dto . getStartTime ( ) ) ) ; else builder . startNow ( ) ; if ( dto . getEndTime ( ) > - 1 ) builder . endAt ( new Date ( dto . getEndTime ( ) ) ) ; return builder ; }
a mail to the queue .
the output to the bufferedInputStream .
the scheduler .
all fields of the given class .
the fields of the given class .
Override public Response toResponse ( Exception e ) { String id = System . nanoTime ( ) + " " ; LOGGER . error ( id , e ) ; if ( e instanceof RobeRuntimeException ) { return ( ( RobeRuntimeException ) e ) . getResponse ( id ) ; } else if ( e instanceof ConstraintViolationException ) { ConstraintViolationException exception = ( ConstraintViolationException ) e ; RobeMessage [ ] errors = new RobeMessage [ exception . getConstraintViolations ( ) . size ( ) ] ; int i = 0 ; for ( ConstraintViolation error : exception . getConstraintViolations ( ) ) { errors [ i ++ ] = new RobeMessage . Builder ( ) . message ( error . getMessage ( ) ) . status ( 422 ) . id ( id ) . build ( ) ; } return Response . status ( 422 ) . entity ( errors ) . type ( MediaType . APPLICATION_JSON ) . build ( ) ; } else if ( e instanceof
the encryptor .
attributes hash .
a new token string .
a message to the given MailItem .
a new password .
the password of the user .
the user from the given accountName .
the password .
account name strength .
the password strength .
the search model .
the status of the transaction .
the transaction .
the transaction wrapper .
field by name .
whether a token is authorized .
parse ( Object o ) { if ( ! isValid ( o ) ) { return null ; } JsonFormat formatAnn = field . getAnnotation ( JsonFormat . class ) ; if ( formatAnn == null ) { throw new RuntimeException ( " JsonFormat with pattern is wrong for : " + field . getName ( ) ) ; } try { return new SimpleDateFormat ( formatAnn . pattern ( ) , Locale . getDefault ( ) ) . parse ( o . toString ( ) ) ; } catch ( ParseException e ) { throw new RuntimeException ( " JsonFormat with pattern is wrong for : " + field . getName ( ) + " pattern : " + formatAnn . pattern ( ) ) ; } }
the response .
static Restriction eq ( String name , Object value ) { return new Restriction ( Operator . EQUALS , name , value ) ; }
ne ( String name , Object value ) { return new Restriction ( Operator . NOT_EQUALS , name , value ) ; }
lt ( String name ) { return new Restriction ( Operator . LESS_THAN , name , Object ) ; }
le ( String name ) { return new Restriction ( Operator . LESS_OR_EQUALS_THAN , name ) ; }
gt ( String name , Object value ) { return new Restriction ( Operator . GREATER_THAN , name , value ) ; }
ge ( String name , Object value ) { return new Restriction ( Operator . GREATER_OR_EQUALS_THAN , name , value ) ; }
ilike ( String name , Object value ) { return new Restriction ( Operator . CONTAINS , name , value ) ; }
static Restriction in ( String name , Object value ) { return new Restriction ( Operator . IN , name , value ) ; }
a new NamespaceManager from the given namespace .
a ResourceRepresentation of the given content .
a new ResourceRepresentation .
< R > withValue ( R newValue ) { return new ResourceRepresentation < > ( Option . none ( ) , links , rels , namespaceManager , newValue , resources ) ; }
a ResourceRepresentation of the given namespace .
a byte array .
a string to a byte array .
true if the input stream is equal .
( File src , File dst ) throws IOException { checkNotNull ( src ) ; checkNotNull ( dst ) ; if ( ! src . equals ( dst ) ) { cp ( src , dst ) ; try { rm ( src ) ; } catch ( IOException e ) { rm ( dst ) ; throw new IOException ( " Can ' t move " + src , e ) ; } } }
a new file .
the base name of the file .
padding to the buffer .
the name of the class .
the superclass of the given class .
the hash of the password .
a string from the input stream .
append ( byte b ) { int newCount = count + 1 ; ensureCapacity ( newCount ) ; buf [ count ] = b ; count = newCount ; return this ; }
append ( byte [ ] bytes , int off , int len ) { int newCount = count + len ; ensureCapacity ( newCount ) ; System . arraycopy ( bytes , off , buf , count , len ) ; return this ; }
static < T > T [ ] copyOf ( T [ ] original ) { return copyOf ( original , original . length ) ; }
( Fraction n , Fraction d ) { return new Fraction ( n . multiply ( f . d ) . add ( f . n ) , d . multiply ( f . d ) ) ; }
a new Fraction ( Fraction n , Fraction d )
a Fraction by another Fraction .
by zero .
the max of the given values .
the minimum value of a long array .
if the condition is true .
the content from the given location .
the Sunrise data .
the Sunrise content from the given latitude and longitude .
( int hoursAhead ) { List < MeteoExtrasForecast > pointExtrasForecasts = new ArrayList < > ( ) ; ZonedDateTime now = getNow ( ) ; for ( int i = 0 ; i < hoursAhead ; i ++ ) { ZonedDateTime ahead = now . plusHours ( i ) ; Optional < PointForecast > pointForecast = getIndexer ( ) . getPointForecast ( ahead ) ; pointForecast . ifPresent ( pof -> { Optional < PeriodForecast > periodForecast = getIndexer ( ) . getTightestFitPeriodForecast ( pof . getFrom ( ) ) ; periodForecast . ifPresent ( pef -> pointExtrasForecasts . add ( new MeteoExtrasForecast ( pof , pef ) ) ) ; } ) ; } return pointExtrasForecasts ; }
( ZonedDateTime dateTime ) { return Optional . empty ( ) ; }
the weather from the given forecast query .
createSimpleLongTermForecast ( ) throws MeteoException { List < MeteoExtrasForecastDay > forecastDays = new ArrayList < > ( ) ; ZonedDateTime dt = getNow ( ) ; for ( int i = 0 ; i <= 6 ; i ++ ) { ZonedDateTime dti = dt . plusDays ( i ) ; if ( getIndexer ( ) . hasForecastsForDay ( dti ) ) { MeteoExtrasForecastDay mefd = createSimpleForcastForDay ( dti ) ; if ( mefd != null && mefd . getForecasts ( ) . size ( ) > 0 ) { forecastDays . add ( mefd ) ; } } } return this ; }
a long term forecast day .
a new Location from the given coordinates .
the content from the given URL .
a WindSymbol name for the pointForecast .
the BeaufortLevel for the given pointForecast .
a new URI .
if the current date is within a given period .
the point forecast from the given ZonedDateTime .
the forecast for the given period .
content from the given latitude and longitude .
the content from the given location language .
the database .
StringMethod ( final ScriptEngine jsEngine , final Object thiz , final String name , final Object ... args ) throws ScriptException { return ( String ) ( ( Invocable ) jsEngine ) . invokeMethod ( thiz , name , args ) ; }
the object from the source .
the referenced object .
< T > getWrappedObject ( final Class < T > clazz ) { return new ReferencedObject < > ( clazz , null , obj ) ; }
the configuration for the given config class .
if a bootstrap configuration is enabled .
a class iterator .
the decoder from the bootstrap configuration .
< T > getServices ( Class < T > intf ) { Objects . requireNonNull ( intf ) ; List < T > ret = new LinkedList < > ( ) ; for ( final T t : ServiceLoader . load ( intf ) ) { ret . add ( t ) ; } return ret ; }
the module instance for the given interface .
the data from the source .
the size of the DataSource .
a new ReferencedData ( String ref , byte [ ] data )
the index of the component .
the prefix of the given component .
public boolean colored ( ) { return type == Compiler . PLAIN || type == Compiler . AHEAD || type == Compiler . BEHIND ; }
a regex pattern .
true if a match is found .
a subset of a RuntimeSubexpression .
whether a given subexpression is a subexpression .
a subexpression .
the outchain .
( Subre t ) { if ( t == null ) { return ; } if ( t . left != null ) { optst ( t . left ) ; } if ( t . right != null ) { optst ( t . right ) ; } }
a subre .
a new NFA for the given subre .
parsebranch ( int stopper , int type , State initState , State finalState ) throws RegexException { State left ; State right ; Subre branches ; Subre t ; int firstbranch ; assert stopper == ' ) ' || stopper == EOS ; branches = new Subre ( ' | ' , Subre . LONGER , initState , finalState ) ; for ( t = branches ; t != branch ; t = t . right ) { t . flags |= branch . flags ; } return branches ; }
deltraverse ( Nfa nfa , State leftend ) { if ( leftend == State . FREESTATE ) { nfa . freestate ( leftend ) ; return ; } if ( leftend == State . FREESTATE ) { nfa . freestate ( leftend ) ; return ; } if ( leftend == State . FREESTATE ) { nfa . freestate ( leftend ) ; return ; } if ( leftend == State . FREESTATE ) { nfa . freestate ( leftend ) ; return ; } if ( leftend == State . FREESTATE ) { nfa . freestate ( leftend ) ; return ; } if ( leftend == State . FREESTATE ) { nfa . freestate ( leftend ) ; return ; } if ( leftend == State . FREESTATE ) { nfa . freestate ( leftend ) ; return ; } if (
a color complement of the given anchor .
the word of the current directory .
the number of digits .
the bracket .
a plain string .
a newlacon to the lacon list .
the color of the given string .
a UnicodeSet to a UnicodeSet .
the color of the given character .
the pseudocolor of the color .
a range .
a new colorchain for the given color .
a colorchain .
the colorchain .
color descs .
the lexer .
the flags of the given string .
the pattern .
the color of the codepoint .
a new state set .
the last cold of a StateSet .
eclass ( char c , boolean cases ) { if ( cases ) { return allcases ( c ) ; } else { UnicodeSet set = new UnicodeSet ( ) ; set . add ( c ) ; return set ; } }
a UnicodeSet .
carcsort ( long [ ] arcs ) { if ( arcs == null ) { return null ; } if ( arcs . length < 2 ) { return null ; } if ( arcs . length < 2 ) { return null ; } if ( arcs . length < 2 ) { return null ; } if ( arcs . length < 2 ) { return null ; } if ( arcs . length < 2 ) { return null ; } if ( arcs . length < 2 ) { return null ; } if ( arcs . length < 2 ) { return null ; } if ( arcs . length < 2 ) { return null ; } if ( arcs . length < 2 ) { return null ; } if ( arcs . length < 2 ) { return null ; } if ( arcs . length < 2 ) { return null ; } if ( arcs . length < 2 ) { return null ; } if ( arcs . length < 2 ) { return null ; } if ( arcs . length <
a string to a file .
newstate ( ) { State newState = new State ( ) ; newState . no = nstates ++ ; return newState ; }
( State old , State newState ) { if ( old == newState ) { return ; } if ( newState == old ) { return ; } if ( newState == newState ) { return ; } if ( newState == old ) { return ; } if ( newState == newState ) { return ; } if ( newState == old ) { return ; } if ( newState == newState ) { return ; } if ( newState == newState ) { return ; } if ( newState == old ) { return ; } if ( newState == newState ) { return ; } if ( newState == newState ) { return ; } if ( newState == old ) { return ; } if ( newState == newState ) { return ; } if ( newState == newState ) { return ; } if ( newState == old ) { return ; } if ( newState == newState ) { return ; } if ( newState == newState ) { return ; } if ( newState == old ) { return ; } if ( newState == newState ) { return ;
ins .
( State old , State newState ) { for ( Arc a = old . ins ; a != null ; a = a . inchain ) { cparc ( a , a . from , newState ) ; } for ( Arc a = newState ; a != null ; a = a . inchain ) { cparc ( a , a . from , newState ) ; } }
outs to a new outchain .
a State from a Arc .
( State s ) { assert s != null ; assert s . nins == 0 ; assert s . nouts == 0 ; if ( s . next != null ) { s . next . prev = s . prev ; } else { assert s == slast ; slast = s . prev ; } if ( s . prev != null ) { s . prev . next = s . next ; } else { assert s == slast ; slast = s . next ; } if ( s . next != null ) { s . next . prev = s . prev ; } else { assert s == slast ; slast = s . prev ; } if ( s . prev != null ) { s . prev . next = s . next ; } else { assert s == slast ; slast = s . next ; } if ( s . next != null ) { s . next . prev = s . prev ; } else { assert s == slast
( Arc oa , State from , State to ) { newarc ( oa . type , oa . co , from , to ) ; }
( State s , State stmp ) { if ( s == null ) { s = newstate ( ) ; } if ( stmp == null ) { stmp = newstate ( ) ; } if ( stmp == null ) { stmp = newstate ( ) ; } if ( stmp == null ) { stmp = newstate ( ) ; } if ( stmp == null ) { stmp = newstate ( ) ; } if ( stmp == null ) { stmp = newstate ( ) ; } if ( stmp == null ) { stmp = newstate ( ) ; } if ( stmp == null ) { stmp = newstate ( ) ; } if ( stmp == null ) { stmp = newstate ( ) ; } return stmp ; }
the pseudocolor of the parent .
nfa states .
the state chain .
( State s , StringBuilder sb ) { if ( s . nouts == 0 ) { return sb . toString ( ) ; } else if ( s . nouts == 1 ) { return sb . toString ( ) ; } else if ( s . nouts == 2 ) { return sb . toString ( ) ; } else if ( s . nouts == 3 ) { return sb . toString ( ) ; } else { return sb . toString ( ) ; } }
( Arc a , State s , StringBuilder sb ) { if ( a . outchain != null ) { pos = dumprarcs ( a . outchain , s , pos , sb ) ; } dumparc ( a , s , sb ) ; if ( pos == 5 ) { sb . append ( " \n " ) ; pos = 1 ; } return pos ; }
( Arc a , State s , StringBuilder sb ) { sb . append ( String . format ( " % d " , a . from . no ) ) ; sb . append ( " - > " ) ; sb . append ( String . format ( " % d " , a . to . no ) ) ; sb . append ( " - > " ) ; sb . append ( String . format ( " % d " , a . from . no ) ) ; sb . append ( " - > " ) ; sb . append ( String . format ( " % d " , a . to . no ) ) ; sb . append ( " - > " ) ; sb . append ( String . format ( " % d " , a . to . no ) ) ; sb . append ( " - > " ) ; sb . append ( String . format ( " % d " , a . to . no ) ) ; sb . append ( " - > " )
the final cleanup .
the outchain .
an arc .
the pre and post states .
unreachable arcs .
canreach ( State s , State okay , State mark ) { if ( s . tmp != okay ) { return ; } s . tmp = mark ; for ( a = s . ins ; a != null ; a = a . inchain ) { markcanreach ( a . from , okay , mark ) ; } }
( ) { for ( State s = states ; s != null ; s = s . next ) { if ( s . type == Compiler . EMPTY && unempty ( s ) ) { progress = true ; } } }
an Arc .
the rule parameters from a file .
report plugins .
report plugins .
the rule selection .
a command line .
the error message .
the properties file from the classpath .
tasks options from task factory .
the task names from the given task factory .
a task .
the command line .
the task .
properties from command line .
usage for the given task .
the JQASSISTANT _ HOME directory .
a classloader for the given plugin directory .
the ids of all cells in the given location .
the Intersecting ids .
the uri of the given method .
a route to the router .
int size ( ) { return last . routes ( ) . size ( ) ; }
a route to the router .
a route to the router .
a route to the last route .
boolean anyMatched ( String [ ] requestPathTokens ) { return first . anyMatched ( requestPathTokens ) || other . anyMatched ( requestPathTokens ) ; }
the value of the given property .
the name of the store file .
( final Entry e1 , final Entry e2 ) { final boolean f1 = e1 instanceof Folder ; final boolean f2 = e2 instanceof Folder ; if ( f1 && ! f2 ) { return - 1 ; } else if ( f1 && f2 ) { return 1 ; } else { return 0 ; } }
( final Entry e1 ) { return new CompareToBuilder ( ) . append ( e1 . getName ( ) , e2 . getName ( ) ) . append ( e1 . getNote ( ) , e2 . getNote ( ) ) . append ( e1 . getCreated ( ) , e2 . getCreated ( ) ) . toComparison ( ) ; }
bookmarks ( final Entry e1 , final Entry e2 ) { if ( e1 instanceof Bookmark && e2 instanceof Bookmark ) { final Bookmark b1 = ( Bookmark ) e1 ; final Bookmark b2 = ( Bookmark ) e2 ; return new CompareToBuilder ( ) . append ( b1 . getUrl ( ) , b2 . getUrl ( ) ) . append ( b1 . isNewWindow ( ) , b2 . isNewWindow ( ) ) . toComparison ( ) ; } else { return new CompareToBuilder ( ) . append ( e1 . getUrl ( ) , e2 . getUrl ( ) ) . append ( e1 . isNewWindow ( ) , e2 . isNewWindow ( ) ) . toComparison ( ) ; } }
servletClassLastModifiedTime ( long lastModified ) { if ( lastModified > this . servletClassLastModifiedTime ) { this . servletClassLastModifiedTime = lastModified ; reload = true ; } }
the dependencies of the specified tag handler .
the class .
( final HttpServletRequest request ) { return null ; }
getInstance ( ) { if ( SecurityUtil . isPackageProtectionEnabled ( ) ) { funcMapper = AccessController . doPrivileged ( new PrivilegedAction < ProtectedFunctionMapper > ( ) { public ProtectedFunctionMapper run ( ) { return new ProtectedFunctionMapper ( ) ; } } ) ; } else { funcMapper = new ProtectedFunctionMapper ( ) ; } funcMapper . fnmap = new java . util . HashMap < String , Method > ( ) ; return funcMapper ; }
a function to a given name .
getMapForFunction ( final String fnQName , final Class < ? > c , final String methodName , final Class < ? > [ ] args ) { java . lang . reflect . Method method ; ProtectedFunctionMapper funcMapper ; if ( SecurityUtil . isPackageProtectionEnabled ( ) ) { funcMapper = AccessController . doPrivileged ( new PrivilegedAction < ProtectedFunctionMapper > ( ) { public ProtectedFunctionMapper run ( ) { return new ProtectedFunctionMapper ( ) ; } } ) ; } else if ( SecurityUtil . isPackageProtectionEnabled ( ) ) { funcMapper = AccessController . doPrivileged ( new PrivilegedExceptionAction < ProtectedFunctionMapper > ( ) { public ProtectedFunctionMapper run ( ) { return new ProtectedFunctionMapper ( ) ; } } ) ; } else if ( SecurityUtil . isPackageProtectionEnabled ( ) ) { funcMapper = AccessController . doPrivileged ( new PrivilegedExceptionAction < ProtectedFunctionMapper > ( ) {
the function name .
the length of the given character .
the value of the specified variable .
the given file .
( String inFileName ) throws FileNotFoundException , JasperException { return doParse ( inFileName ) ; }
( String inFileName , boolean directiveOnly ) throws IOException { if ( inFileName == null || inFileName . length ( ) == 0 ) throw new FileNotFoundException ( ) ; if ( inFileName . length ( ) == 0 ) throw new FileNotFoundException ( ) ; boolean isTagFileSave = directiveOnly ; isTagFile = true ; directiveOnly = true ; Node . Nodes page = doParse ( inFileName , null , ( URL ) ctxt . getTagFileJarUrls ( ) . get ( inFileName ) ) ; directiveOnly = directiveOnlySave ; return page ; }
the given file .
a new compiler .
resourceAsStream ( String res ) throws IOException { return context . getResourceAsStream ( canonicalURI ( res ) ) ; }
the last mod of the channel .
all class loaders for the given class .
if classloader is a parent classloader .
the loading of the class .
the stream header .
< T > paginate ( final Integer startPage , final int pageSize , final List < T > fullDataSet ) { return paginate ( startPage , pageSize , ( start , length ) -> { final int len = fullDataSet . size ( ) ; if ( start > len ) { return Collections . emptyList ( ) ; } return fullDataSet . subList ( start , Math . min ( start + length , len ) ) ; } ) ; }
a string to a MetaKey .
the requirements for the rpmlib .
getTagFile ( String shortName ) { if ( tagFileMap . containsKey ( shortName ) ) { return tagFileMap . get ( shortName ) ; } return null ; }
( JspCompilationContext ctxt , String path ) throws JasperException { this . jspversion = null ; this . tlibversion = null ; this . tlibversion = null ; this . jspversion = null ; }
the checksum of the given file .
the size of the given file .
the name of the channel .
to the specified block number .
( long pos ) { if ( pos < 0 || pos >= uncompressedSize ) throw new IndexOutOfBoundsException ( " Invalid uncompressed position : " + pos ) ; IndexDecoder index ; for ( int i = 0 ; i < streams . size ( ) ; ++ i ) { index = streams . get ( i ) ; if ( index . hasUncompressedOffset ( pos ) ) break ; } index . locateBlock ( info , pos ) ; }
< MavenVersionedArtifact > getMavenArtifacts ( final String channelId , final Supplier < Collection < ArtifactInformation > > artifactsSupplier ) { if ( artifactsSupplier . get ( ) . size ( ) == 0 ) { return Collections . emptyList ( ) ; } if ( artifactsSupplier . get ( ) . size ( ) == 0 ) { return Collections . emptyList ( ) ; } if ( artifactsSupplier . get ( ) . size ( ) == 0 ) { return Collections . emptyList ( ) ; } if ( artifactsSupplier . get ( ) . size ( ) == 0 ) { return Collections . emptyList ( ) ; } if ( artifactsSupplier . get ( ) . size ( ) == 0 ) { return Collections . emptyList ( ) ; } if ( artifactsSupplier . get ( ) . size ( ) == 0 ) { return Collections . emptyList ( ) ; } return artifactsSupplier . get ( ) ; }
opt state and reps .
( int optCur , int optEnd ) { if ( optCur + 1 + optEnd >= opts [ optCur + 1 + optEnd ] . price ) { return null ; } if ( optCur + 1 + optEnd >= opts [ optCur + 1 + optEnd ] . price ) { return null ; } if ( optCur + 1 + optEnd >= opts [ optCur + 1 + optEnd ] . price ) { return null ; } if ( optCur + 1 + optEnd >= opts [ optCur + 1 + optEnd ] . price ) { return null ; } if ( optCur + 1 + optEnd >= opts [ optCur + 1 + optEnd ] . price ) { return null ; } if ( optCur + 1 + optEnd >= opts [ optCur + 1 + optEnd ] . price ) { return null ; } if ( optCur + 1 + optEnd < opts [ optCur + 1
( int optCur , int optEnd ) { if ( optCur == optEnd ) return this ; if ( optCur == optEnd ) { return this ; } if ( optCur == optEnd ) { return this ; } if ( optCur == optEnd ) { return this ; } if ( optCur == optEnd ) { return this ; } if ( optCur == optEnd ) { return this ; } if ( optCur == optEnd ) { return this ; } if ( optCur == optEnd ) { return this ; } if ( optCur == optEnd ) { return this ; } if ( optCur == optEnd ) { return this ; } if ( optCur == optEnd ) { return this ; } if ( optCur == optEnd ) { return this ; } if ( optCur == optEnd ) { return this ; } if ( optCur == optEnd ) { return this ; } int nextState = nextState
normal match prices .
the expected byte .
a byte to a UTFDataFormatException .
Tlds .
scanTld ( String resourcePath , String entryName , boolean isValidationEnabled ) throws JasperException { InputStream stream = null ; try { stream = new FileInputStream ( resourcePath ) ; stream . read ( ) ; stream . close ( ) ; return new TldInfo ( resourcePath , entryName , isValidationEnabled ) ; } catch ( IOException e ) { throw new JasperException ( e ) ; } }
a wrapper to the jsp .
the parent classloader .
the bytecode for the given name .
the bytecode birth time .
the bytecode for the given class .
the JspServletWrapper .
the classpath .
the thread .
the thread .
a JSP page .
the name of the channel .
a channel by the given name .
( final ChannelServiceAccess model ) { this . deployKeysMap = new HashMap < String , Set < DeployGroup > > ( ) ; this . deployKeysMap . putAll ( model . getDeployGroupMap ( ) ) ; }
< DeployGroup > listGroups ( final int position , final int count ) { return this . manager . accessCall ( KEY_STORAGE , ChannelServiceAccess . class , model -> { return split ( model . getDeployGroups ( ) , position , count ) ; } ) ; }
the contents of the InputStream to the OutputStream .
a page .
( ParserController pc , JspReader reader ) throws JasperException { Parser tmpParser = new Parser ( pc , reader , false , false , null , false ) ; return tmpParser . parseAttributes ( ) ; }
( String tx ) { StringBuilder buf = new StringBuilder ( ) ; buf . append ( tx ) ; buf . append ( tx ) ; buf . append ( tx ) ; buf . append ( tx ) ; buf . append ( tx ) ; buf . append ( tx ) ; buf . append ( tx ) ; buf . append ( tx ) ; buf . append ( tx ) ; buf . append ( tx ) ; buf . append ( tx ) ; buf . append ( tx ) ; }
a include directive to the parent .
( Node parent , String tag , String bodyType ) throws JasperException { if ( reader . matchesOptionalSpacesFollowedBy ( " < jsp : attribute " ) ) { parseJspAttribute ( parent , tag , bodyType ) ; reader . skipSpaces ( ) ; } else if ( reader . matchesOptionalSpacesFollowedBy ( " < jsp : attribute " ) ) { parseJspAttribute ( parent , tag , bodyType ) ; reader . skipSpaces ( ) ; } else if ( reader . matchesOptionalSpacesFollowedBy ( " < jsp : attribute " ) ) { parseJspAttribute ( parent , tag , bodyType ) ; reader . skipSpaces ( ) ; } else if ( reader . matchesOptionalSpacesFollowedBy ( " < jsp : attribute " ) ) { parseJspAttribute ( parent , tag , bodyType ) ; reader . skipSpaces ( ) ; } else if ( reader . matchesOptionalSpacesFollowedBy ( " < jsp : attribute " ) ) {
a new attribute .
a node to the list of children .
the attributes of the given object .
the children of a TreeNode .
all children of a given name .
a MavenCoordinates to a MavenCoordinates .
( String varName ) { if ( aliases == null ) return varName ; String alias = aliases . get ( varName ) ; if ( alias == null ) { return varName ; } return alias ; }
the thread name .
( ) { ByteArrayOutputStream baos = ( ByteArrayOutputStream ) data . get ( ) ; if ( baos == null ) { return null ; } streams . set ( null ) ; data . set ( null ) ; return baos . toString ( ) ; }
( ) { return findStream ( ) ; }
( final StringWriter writer , final String fieldName , final String value ) { if ( value != null ) { write ( writer , fieldName , value ) ; } }
the value to the writer .
a new element to the parent .
a new element to the parent .
( Writer out ) throws IOException { if ( out != null ) { out . write ( cb , 0 , nextChar ) ; } }
the writer to null .
( char [ ] cb ) { if ( cb == null ) { cb = new char [ bufferSize ] ; } if ( cb . length == 0 ) { cb = new char [ bufferSize ] ; } if ( cb . length == 0 ) { cb = new char [ bufferSize ] ; } if ( cb . length == bufferSize ) { cb = new char [ bufferSize ] ; } if ( cb . length == 0 ) { cb = new char [ bufferSize ] ; } if ( cb . length == bufferSize ) { cb = new char [ bufferSize ] ; } if ( cb . length == bufferSize ) { cb = new char [ bufferSize ] ; } if ( cb . length == bufferSize ) { cb = new char [ bufferSize ] ; } if ( cb . length == bufferSize ) { cb = new char [ bufferSize ] ; } if ( cb . length == bufferSize ) { cb = new char [ bufferSize ] ; } if ( cb . length == bufferSize ) { cb =
a function to an ELFunctionMapper .
the parent for the given key .
a new storage model .
a stream from the data path .
the job .
boolean isAuthenticated ( final By by , final HttpServletRequest request ) { final String [ ] authToks = parseAuthorization ( request ) ; if ( authToks == null ) { return false ; } final String deployKey = authToks [ 1 ] ; logger . debug ( " Deploy key : ' { } ' " , deployKey ) ; final ChannelService service = getService ( request ) ; if ( service == null ) { logger . info ( " Called ' isAuthenticated ' without service " ) ; return false ; } return service . isAuthenticated ( by ) ; }
the stream .
makeGson ( ) { final GsonBuilder gb = new GsonBuilder ( ) ; if ( pretty ) { gb . setPrettyPrinting ( ) ; } gb . registerTypeAdapter ( Node . class , new NodeAdapter ( ) ) ; gb . registerTypeAdapter ( byte [ ] . class , new ByteArrayAdapter ( ) ) ; return gb . create ( ) ; }
whether to encode a LZMA2 file .
the provided metadata into the extracted metadata .
the error of the request .
the checksum for the given Coordinates .
the compressed stream .
the exception .
the expression .
the hostname of the service .
the XML file from the given path .
( ParserController pc , String name , String path , TagLibraryInfo tagLibInfo ) throws JasperException { ErrorDispatcher err = pc . getCompiler ( ) . getErrorDispatcher ( ) ; Node . Nodes page = null ; try { page = pc . parseTagFileDirectives ( path ) ; } catch ( FileNotFoundException e ) { err . jspError ( " jsp . error . file . not . found " , path ) ; } catch ( IOException e ) { err . jspError ( " jsp . error . file . not . found " , path ) ; } return page ; }
the tag file from the JspCompilationContext .
all generated class files .
jspc .
the uri root .
all files in the given directory .
the uri root .
the system classloader .
the current position .
true if the given string matches the given string .
( String s ) throws JasperException { Mark mark = mark ( ) ; skipSpaces ( ) ; boolean result = matches ( s ) ; if ( ! result ) { reset ( mark ) ; } return result ; }
skipUntil ( String limit ) throws JasperException { if ( limit == null ) { return null ; } if ( limit . length ( ) == 0 ) { return mark ( ) ; } if ( limit . length ( ) == 1 ) { return mark ( ) ; } if ( limit . length ( ) == 2 ) { return mark ( ) ; } if ( limit . length ( ) == 1 ) { return mark ( ) ; } if ( limit . length ( ) == 2 ) { return mark ( ) ; } if ( limit . length ( ) == 1 ) { return mark ( ) ; } if ( limit . length ( ) == 2 ) { return mark ( ) ; } if ( limit . length ( ) == 1 ) { return mark ( ) ; } if ( limit . length ( ) == 2 ) { return mark ( ) ; } if ( limit . length ( ) == 1 ) { return mark ( ) ; } if ( limit . length ( )
skipUntilIgnoreEsc ( String limit ) throws JasperException { if ( limit == null ) return null ; if ( limit . length ( ) == 0 ) return null ; if ( limit . charAt ( 0 ) == ' \\ ' ) return mark ( ) ; if ( limit . charAt ( 0 ) == ' \\ ' ) return mark ( ) ; if ( limit . charAt ( 0 ) == ' \\ ' ) return mark ( ) ; if ( limit . charAt ( 0 ) == ' \\ ' ) return mark ( ) ; if ( limit . charAt ( 0 ) == ' \\ ' ) return mark ( ) ; if ( limit . charAt ( 0 ) == ' \\ ' ) return mark ( ) ; if ( limit . charAt ( 0 ) == ' \\ ' ) { if ( limit . charAt ( 0 ) == ' \\ ' ) return mark ( ) ; if ( limit . charAt ( 0 ) == ' \\ ' ) { if ( limit . charAt ( 0 ) == '
skipUntilETag ( String tag ) throws JasperException { Mark ret = skipUntil ( " < / " + tag ) ; if ( ret != null ) { skipSpaces ( ) ; if ( nextChar ( ) != ' > ' ) ret = null ; } return ret ; }
parseToken ( ) throws JasperException { if ( peekChar ( ) == ' " ' || peekChar ( ) == ' \ ' ' || peekChar ( ) == ' " ' || peekChar ( ) == ' \ ' ' || peekChar ( ) == ' > ' || peekChar ( ) == ' % ' || peekChar ( ) == ' > ' || peekChar ( ) == ' % ' || peekChar ( ) == ' > ' || peekChar ( ) == ' % ' || peekChar ( ) == ' > ' || peekChar ( ) == ' % ' || peekChar ( ) == ' > ' || peekChar ( ) == ' % ' || peekChar ( ) == ' > ' || peekChar ( ) == ' % ' || peekChar ( ) == ' > ' || peekChar ( ) == ' % ' || peekChar ( ) == ' > ' || peekChar ( ) == ' % ' || peekChar ( ) == '
( ) throws JasperException { if ( current == null || currFileId < 0 ) { return false ; } String fName = getFile ( currFileId ) ; currFileId = unregisterSourceFile ( fName ) ; if ( currFileId < - 1 ) { err . jspError ( " jsp . error . file . not . registered " , fName ) ; } }
makeUnclassified ( ) { if ( this . classifier == null ) { return this ; } return new Coordinates ( this . groupId , this . artifactId ) ; }
a list of AspectInformation objects .
a list of all required aspects .
the schema resource prefix .
the specified dtd resource prefix .
the prefix of the file .
a node to a TreeNode .
Errors from BindingResult to BindingResult .
the binder .
the ChannelAspectInformations of a given ChannelAspectFactory .
the path .
the tag plugin .
a byte array of the given size .
the array of the given size .
asResult ( final Collection < ArtifactResult > results , final ImportConfiguration cfg ) { final Map < String , Boolean > optionalDeps = new HashMap < > ( ) ; fillOptionalDependenciesMap ( dependencyResult , optionalDeps ) ; return result ; }
resourceAsStream ( String uri ) { try { String real = ctxt . getRealPath ( uri ) ; if ( real == null ) { return ctxt . getResourceAsStream ( uri ) ; } else { return new FileInputStream ( real ) ; } } catch ( FileNotFoundException ex ) { return ctxt . getResourceAsStream ( uri ) ; } }
a tag library .
the stream .
the encoding of the specified file .
XMLDeclOrTextDecl ( ) throws IOException { if ( skipString ( " < ? xml " ) ) { fMarkupDepth ++ ; if ( XMLChar . isName ( peekChar ( ) ) ) { fStringBuffer . clear ( ) ; fStringBuffer . append ( " xml " ) ; while ( XMLChar . isName ( peekChar ( ) ) ) { fStringBuffer . append ( ( char ) scanChar ( ) ) ; } String target = fSymbolTable . addSymbol ( fStringBuffer . ch , fStringBuffer . offset , fStringBuffer . length ) ; scanPIData ( target , fString ) ; } else { scanXMLDecl ( false ) ; } } }
( String msgId , String arg ) throws JasperException { if ( msgId != null && msgId . length ( ) > 0 ) { throw new JasperException ( msgId ) ; } }
the real path of the resource .
the resource from the given path .
the resource from the given path .
< String > getResourcePaths ( String path ) { Set < String > thePaths = new HashSet < String > ( ) ; if ( ! path . endsWith ( " / " ) ) path += " / " ; String basePath = getRealPath ( path ) ; if ( basePath == null ) return ( thePaths ) ; File theBaseDir = new File ( basePath ) ; if ( ! theBaseDir . exists ( ) || ! theBaseDir . isDirectory ( ) ) return ( thePaths ) ; String theFiles [ ] = theBaseDir . list ( ) ; for ( int i = 0 ; i < theFiles . length ; i ++ ) { File testFile = new File ( basePath + File . separator + theFiles [ i ] ) ; if ( testFile . isFile ( ) ) thePaths . add ( path + theFiles [ i ] ) ; else if ( testFile . isDirectory ( ) ) thePaths . add ( path + theFiles [ i ] + " /
the exception to the log file .
addFilter ( String filterName , String description , String className , Map < String , String > initParameters ) { if ( initParameters == null ) { initParameters = new HashMap < String , String > ( ) ; } return addFilter ( filterName , description , className , initParameters ) ; }
the size of the dict .
the memory usage of the dict .
preset dictionaries .
( ) { int moveOffset = ( readPos + 1 - keepSizeBefore ) & ~ 15 ; int moveSize = writePos - moveOffset ; System . arraycopy ( buf , moveOffset , buf , 0 , moveSize ) ; readPos -= moveOffset ; writePos -= moveOffset ; }
( byte [ ] in , int off , int len ) { if ( len > bufSize - keepSizeAfter ) len = bufSize - keepSizeAfter ; if ( len > bufSize - writePos ) len = bufSize - writePos ; System . arraycopy ( in , off , buf , writePos , len ) ; writePos += len ; }
( ) { if ( pendingSize > 0 && readPos < readLimit ) { int oldPendingSize = pendingSize ; pendingSize = 0 ; skip ( oldPendingSize ) ; assert pendingSize < oldPendingSize ; } }
( int readPos ) { int backPos = readPos - dist - 1 ; int len = 0 ; while ( len < lenLimit && buf [ readPos + len ] == buf [ backPos + len ] ) ++ len ; return len ; }
( int forward , int dist , int lenLimit ) { int curPos = readPos + forward ; int backPos = curPos - dist - 1 ; int len = 0 ; while ( len < lenLimit && buf [ curPos + len ] == buf [ backPos + len ] ) ++ len ; return len ; }
( Matches matches ) { int lenLimit = Math . min ( getAvail ( ) , matchLenMax ) ; for ( int i = 0 ; i < matches . count ; ++ i ) if ( getMatchLen ( matches . dist [ i ] , lenLimit ) != matches . len [ i ] ) return false ; return true ; }
to the end of the file .
( ) { if ( out != null ) out . recycle ( ) ; if ( response != null ) response . recycle ( ) ; }
the buffer .
the flushed buffer .
the output stream .
the output stream .
a string to a byte buffer .
( int bufferSize ) { if ( bufferSize == 0 ) return ; if ( bufferSize > MAX_BUFFER_SIZE ) { buf = new CharBuffer ( new char [ bufferSize ] , 0 , bufferSize ) ; } else { buf = getCharBufferThreadLocalPool ( ) . allocate ( bufferSize ) ; } }
error report .
a key for all fields .
a class .
a Java file .
the generated files from the classpath .
a Java compiler .
the system jar in the specified path .
a quote from a string .
the declarations of the page .
( Node . Nodes page ) throws JasperException { List < TagHandlerPool > tagHandlerPoolNames = new ArrayList < TagHandlerPool > ( ) ; page . visit ( new TagHandlerPoolVisitor ( tagHandlerPoolNames ) ) ; }
XML Prolog for the given page .
common postamble .
a postamble .
a tag handler .
a tag handler attribute .
properties from the input stream .
a channel to a zip file .
the xml view .
the JspTagHandler .
the expression .
the properties of a JspPropertyGroup .
whether a jsp page is a jsp page .
a comment .
the given string .
( String s , int indent ) { if ( indent > 0 ) { writer . print ( SPACES . substring ( 0 , indent ) ) ; writer . println ( s ) ; } else { writer . print ( SPACES . substring ( indent ) ) ; writer . println ( s ) ; } }
( String s ) { int index = 0 ; while ( ( index = s . indexOf ( ' \n ' , index ) ) > - 1 ) { javaLine ++ ; index ++ ; } writer . print ( s ) ; }
the expression in XML .
the scope of a JSP page .
the XML string .
( Mark where , String expressions , FunctionMapper functionMapper , ErrorDispatcher err ) throws JasperException { try { ELContextImpl elContext = new ELContextImpl ( null ) ; elContext . setFunctionMapper ( functionMapper ) ; getExpressionFactory ( ) . createValueExpression ( elContext , expressions , Object . class ) ; } catch ( ELException e ) { err . jspError ( where , " jsp . error . invalid . expression " , expressions , e . toString ( ) ) ; } }
the class name from the given path .
a Java package from the given path .
the path .
a new Java identifier .
mangleChar ( char ch ) { char [ ] result = new char [ 5 ] ; result [ 0 ] = ' _ ' ; result [ 1 ] = Character . forDigit ( ( ch >> 12 ) & 0xf , 16 ) ; result [ 2 ] = Character . forDigit ( ( ch >> 8 ) & 0xf , 16 ) ; result [ 3 ] = Character . forDigit ( ( ch >> 4 ) & 0xf , 16 ) ; result [ 4 ] = Character . forDigit ( ch & 0xf , 16 ) ; return new String ( result ) ; }
if the key is a Java keyword .
a property to the properties file .
static String modifier ( final String prefix ) { if ( prefix == null ) { return " " ; } if ( prefix . length ( ) == 0 ) { return " " ; } if ( prefix . length ( ) == 0 ) { return " " ; } if ( prefix . length ( ) == 0 ) { return " " ; } if ( prefix . length ( ) == 0 ) { return " " ; } if ( prefix . length ( ) == 0 ) { return " " ; } if ( prefix . length ( ) == 0 ) { return " " ; } if ( prefix . length ( ) == 0 ) { return " " ; } if ( prefix . length ( ) == 0 ) { return " " ; } if ( prefix . length ( ) == 0 ) { return " " ; } if ( prefix . length ( ) == 0 ) { return " " ; } return prefix ; }
the metadata for the given namespace .
a user to the list of users .
the name of the file .
the value to the database .
the metadata from the database .
the aggregated payload to a collection of IMetric metrics .
a number to a number .
a string to the output stream .
( Locator locator , RollupType rollupType ) { return getTtl ( locator , rollupType , null ) ; }
a prepared statement .
delayed metrics .
delayed metrics .
a double or long from a CodedInputStream .
( Number number ) throws IOException { if ( number instanceof Double ) { out . writeRawByte ( Constants . B_DOUBLE ) ; out . writeDoubleNoTag ( number . doubleValue ( ) ) ; } else if ( number instanceof Long ) { out . writeRawByte ( Constants . B_LONG ) ; out . writeLongNoTag ( number . longValue ( ) ) ; } else if ( number instanceof Float ) { out . writeRawByte ( Constants . B_FLOAT ) ; out . writeFloatNoTag ( number . floatValue ( ) ) ; } else if ( number instanceof Double ) { out . writeRawByte ( Constants . B_DOUBLE ) ; out . writeDoubleNoTag ( number . doubleValue ( ) ) ; } else { out . writeRawByte ( Constants . B_DOUBLE ) ; out . writeDoubleNoTag ( number . doubleValue ( ) ) ; } }
< Object , Object > getAllProperties ( ) { Map < Object , Object > map = new HashMap < Object , Object > ( ) ; for ( Object key : defaultProps . keySet ( ) ) { map . put ( key , defaultProps . getProperty ( key . toString ( ) ) ) ; } for ( Object key : props . keySet ( ) ) { map . put ( key , props . getProperty ( key . toString ( ) ) ) ; } return map ; }
a new container .
( long scheduleTime ) { synchronized ( scheduledSlots ) { if ( scheduledSlots . size ( ) == 0 ) { scheduledSlots . clear ( ) ; orderedScheduledSlots . clear ( ) ; recentlyScheduledShards . put ( scheduleTime , scheduleTime ) ; } } }
all coarser slots from running slots .
on ( String event ) { ConcurrentLinkedQueue < Listener > callbacks = this . callbacks . get ( event ) ; if ( callbacks == null ) { callbacks = new ConcurrentLinkedQueue < Listener > ( ) ; ConcurrentLinkedQueue < Listener > _callbacks = this . callbacks . putIfAbsent ( event , callbacks ) ; if ( _callbacks != null ) { callbacks = _callbacks ; } } callbacks . add ( fn ) ; return this ; }
once ( final String event ) { if ( this . onceCallbacks . containsKey ( event ) ) { return this . onceCallbacks . get ( event ) ; } return this ; }
off ( String event ) { ConcurrentLinkedQueue < Listener > callbacks = this . callbacks . remove ( event ) ; if ( callbacks != null ) { for ( Listener fn : callbacks ) { this . onceCallbacks . remove ( fn ) ; } } return this ; }
a new event .
< Listener > listeners ( ) { return listeners ; }
the remote name .
rollup to outputStream .
( String fileName ) throws NumberFormatException { parseTimestamp ( fileName ) ; }
the HTTP server on port { }
rollups for a given RollupType .
an IOContainer from the configuration .
a TTL config for a given granularity .
maximums of the given headers .
the headers .
the output .
the ZKShardLockManager metrics .
a new thread pool with the given name .
a metric to the given metricNameBaseLevelMap .
complete metric names .
the tokens from the locator .
a batch statement to a given locator .
granularityFromPointsInInterval ( String tenantid , long from , long to , int points , String algorithm , Clock ttlComparisonClock ) { if ( from >= to ) { throw new RuntimeException ( " Invalid interval specified for fromPointsInInterval " ) ; } double requestedDuration = to - from ; if ( algorithm . startsWith ( " GEOMETRIC " ) ) return granularityFromPointsGeometric ( tenantid , from , to , requestedDuration , points , assumedIntervalMillis , ttlComparisonClock ) ; else if ( algorithm . startsWith ( " LINEAR " ) ) return granularityFromPointsLinear ( requestedDuration , points , assumedIntervalMillis ) ; else if ( algorithm . startsWith ( " LESSTHANEQUAL " ) ) return granularityFromPointsLessThanEqual ( requestedDuration , points , assumedIntervalMillis ) ; return granularityFromPointsGeometric ( tenantid , from , to , requestedDuration , points , assumedIntervalMillis , ttlComparisonClock ) ; }
the granularity of the given duration .
setting the server time .
the unique hosts from the CASSANDRA config .
( ) { return maxConns ; }
< MetricColumnFamily > getMetricColumnFamilies ( ) { return new Iterator < MetricColumnFamily > ( ) { @ Override public Iterator < MetricColumnFamily > iterator ( ) { return new Iterator < MetricColumnFamily > ( ) { private int pos = 0 ; @ Override public boolean hasNext ( ) { return pos < METRIC_COLUMN_FAMILES . length ; } @ Override public MetricColumnFamily next ( ) { throw new NoSuchMethodError ( " Not implemented " ) ; } @ Override public void remove ( ) { throw new NoSuchMethodError ( " Not implemented " ) ; } } ; } } ; }
( Collection < IMetric > metrics ) throws IOException { insertMetrics ( metrics , Granularity . FULL ) ; }
metrics to the database .
for delayed metrics .
the metric names from Elasticsearch .
the regex to grab the current and next level .
uploader thread .
the uploader .
the current locator .
the current locator .
the current locator .
synchronized boolean isDelayedLocatorForSlot ( int slot , Locator locator ) { return insertedDelayedLocators . getIfPresent ( getLocatorSlotKey ( slot , locator ) ) != null ; }
( int slot , Locator locator ) { insertedDelayedLocators . put ( getLocatorSlotKey ( slot , locator ) , Boolean . TRUE ) ; }
< Range , Iterable < Range > > mapFinerRanges ( Granularity g , Range range ) throws GranularityException { if ( range . getStart ( ) >= range . getStop ( ) ) throw new IllegalArgumentException ( " start cannot be greater than end . Start : " + range . getStart ( ) + " Stop : " + range . getStop ( ) ) ; final long snappedStartMillis = g . snapMillis ( range . getStart ( ) ) ; final long snappedStopMillis = g . snapMillis ( range . getStop ( ) + g . milliseconds ( ) ) ; HashMap < Range , Iterable < Range > > rangeMap = new HashMap < Range , Iterable < Range > > ( ) ; rangeMap . put ( range , rangeMap ) ; return rangeMap ; }
the ranges of the given granularity .
a full mutation batch .
metrics to the keyspace .
if a metric is delayed .
getBoundStatementForMetric ( IMetric metric ) { Locator locator = metric . getLocator ( ) ; if ( isDelayed ( metric ) ) { int slot = getDelayedSlot ( metric ) ; if ( ! LocatorCache . getInstance ( ) . isDelayedLocatorForASlotCurrent ( slot , locator ) ) { LocatorCache . getInstance ( ) . setDelayedLocatorForASlotCurrent ( slot , locator ) ; return delayedLocatorIO . getBoundStatementForLocator ( DELAYED_METRICS_STORAGE_GRANULARITY , slot , locator ) ; } } return null ; }
metadata values from the given locator .
the serializer for the given type .
the content type of the request .
whether the Accept header is valid or not .
the data into Elasticsearch .
the aggregated metrics .
the downloaded files from the download directory .
a new extractor .
( final String osNamePrefix , final String osVersionPrefix ) { return isOSMatch ( OS_NAME , osNamePrefix , osVersionPrefix ) ; }
the rabbitMq process .
the rabbitMq process .
defaultInstance ( ) { return defaultInstance ( ) ; }
IceServers to the list of IceServers .
an ice server to the list of ice servers .
a message .
a message .
the weitere adresse .
a list of UserDefinedSimplefield .
a list of UserDefinedAnyfield objects .
( ApiSuchfelderTyp value ) { this . apiSuchfelder = value ; }
the multimedia anhang .
( ) { return statusVBM ; }
the status of aKTIV .
the status of aKTIV .
the importmodus .
true if adressdruck is null .
getWaehrungTyp ( ) { if ( waehrung == null ) { waehrung = WaehrungTyp . EUR ; } return waehrung ; }
the bodenbelagTyp from the BodenbelagTyp object .
the region to the specified value .
the area .
the address to a string .
the description of the element .
setRentCollectionPeriod ( RentCollectionPeriod value ) { this . rentCollectionPeriod = value ; return this ; }
setFurnished ( Furnished value ) { this . furnished = value ; return this ; }
the phone1 value .
the phone2 value .
the contact name .
the phone info .
the main email .
the cc email .
the external id .
the agent id .
the Energiepass . Epart value .
( Energiepass . Jahrgang value ) { this . jahrgang = value ; }
( Energiepass . Gebaeudeart value ) { this . gebaeudeart = value ; return this ; }
setBueroTyp ( BueroTyp value ) { return this . bueroTyp = value ; }
if the value is numeric .
( LageGebiet . Gebiete value ) { this . gebiete = value ; return this ; }
( Gruppe value ) { this . gruppe = value ; }
the agent .
the properties of the given type .
the stand value .
the user defined extend .
the Zeiteinheit value .
the zimmer of the given zimmer .
a list of Haus .
a list of BueroPraxen .
< Gastgewerbe > getGastgewerbe ( ) { return gastgewerbe ; }
the land und forstwirtschaft .
getSonstige ( ) { return sonstige ; }
a list of ZinshausRenditeobjekt .
( List < TerrainType > terrain ) { return terrain ; }
the Umfang value .
the Wohnung . Wohnungtyp value .
the country iso2 code from the given country .
the country iso3 code from the given iso3 code .
the country iso3 code from the given country .
the country iso3 code from the given iso2Code .
the country name from the given country .
the country name .
( ) { return anbieter ; }
the category of the BusinessElement .
a list of URIs .
setAktionart ( AktionArt aktionart ) { return aktionart ; }
the realestateitems .
the pacht value .
to previous version .
summemietenetto elements from previous version .
the content of the given object .
the names of the fields .
getBlick ( ) { return blick ; }
the pauschalmiete value .
( WazTyp . Monatsmiete value ) { this . monatsmiete = value ; }
the StellplatzKategorieTyp .
the lastenaufzug value .
the ZustandArt value .
< Bewertung . Feld > getFeld ( ) { return feld ; }
a validation event .
the records to a file .
the value of the given position .
a list of strings .
the value to the given string .
the type of the object .
setHaustyp ( Haustyp value ) { return setHaustyp ( value ) ; }
the energiepass list of Energiepass .
the keller value .
( GrundstTyp value ) { this . grundstTyp = value ; }
( Geschlecht . GeschlAttr value ) { this . geschlAttr = value ; }
. setHallenTyp ( HallenTyp value ) { this . hallenTyp = value ; return this ; }
wiederholungstermin ( ) { return wiederholungstermin ; }
teilungsversteigerung ( ) { return teilungsversteigerung ; }
Sonstige and Zinshaus Renditeobjekt elements .
< Interessent . Bevorzugt > getBevorzugt ( ) { return bevorzugt ; }
the wunsch .
the Art of the Uebertragung .
the modus of the Uebertragung .
< EmailSonstige > getEmailSonstige ( ) { return emailSonstige ; }
the telSonstige list of telSonstige .
the HandelTyp property .
< preise > elements to previous version .
the apiSuchfeld1 value .
the apiSuchfeld2 value .
the apiSuchfeld3 value .
the row of a ResultSetType . ROW .
( DistanzenSport value ) { this . distanzZuSport = value ; }
anhang list .
objektKategorie2 ( ) { return objektKategorie2; }
ObjektZustandTyp ( ObjektZustandTyp objektzustand ) { return objektzustand ; }
getHausKategorie ( ) { return hausKategorie ; }
getAusstattungsqualitaet ( ) { return ausstattungsqualitaet ; }
< String > getVermarktungsart ( ) { return vermarktungsart ; }
the interessent .
the wert value .
ackerland object .
the bauerwartungsland value .
( JAXBElement < Object > value ) { this . bootsstaende = value ; }
the buero value .
the camping value .
( JAXBElement < Object > value ) { return value ; }
the einfamilienhaus value .
einzelhandelGross ( JAXBElement < Object > value ) { this . einzelhandelGross = value ; }
einzelhandelKlein ( ) { return einzelhandelKlein ; }
the garagen value .
the garten value .
( JAXBElement < Object > value ) { this . gastronomie = value ; }
the gewerbe value .
the hotel value .
the industrie .
( JAXBElement < Object > value ) { return value ; }
the kleingewerbe value .
a JAXBElement < Object > .
( JAXBElement < Object > value ) { this . value = value ; }
( JAXBElement < Object > value ) { this . obstpflanzung = value ; }
( JAXBElement < Object > value ) { this . parkhaus = value ; }
the produktion value .
the reihenhaus value .
the stellplaetze value .
the villa value .
the wald value .
anbieter to the ImmobilienTransferTyp value .
< Wohnung > getWohnung ( ) { return wohnung ; }
a list of grundstuecks .
einzelhandel list of einzelhandel .
< HallenLagerProd > getHallenLagerProd ( ) { return hallenLagerProd ; }
a list of Parken objects .
a list of FreizeitimmobilieGewerblich .
( ) { return this . objektartZusatz ; }
< Stellplatzart > getStellplatzart ( ) { return stellplatzart ; }
( MaxMietdauer . MaxDauer value ) { this . maxDauer = value ; return this ; }
a list of features .
the Zimmer . Zimmertyp value .
< energiepass > elements .
( JAXBElement < Object > value ) { this . keineAngabe = value ; }
the erdwaerme value .
the solarheizung .
the pelletheizung .
the gas from the given gas .
the oel value .
the fernwaerme value .
the strom value .
the kohle value .
a random string .
randomLetters ( ) { return new RandomStringGenerator . Builder ( ) . filteredBy ( LETTERS ) . build ( ) . generate ( length ) ; }
randomNumeric ( int length ) { return new RandomStringGenerator . Builder ( ) . filteredBy ( NUMBERS ) . build ( ) ; }
the wohnung kategorie .
setBENUTZER ( BENUTZER value ) { this . benutzer = value ; return this ; }
( WIS . OBJEKTE value ) { this . objekte = value ; }
a list of Feedindex . Feed objects .
a new Moebliert object .
a list of Serviceleistungen .
getSubAdministrativeArea ( ) { return subAdministrativeArea ; }
the city from the location structure .
the locality .
the OpenImmoDocument to the previous version .
energiepass elements from previous version .
( LandTyp value ) { this . landTyp = value ; }
a list of fields .
Mieteinnahmen elements .
a list of AdType objects .
getGastgewTyp ( ) { return gastgewTyp ; }
a Platzart object .
DatenVerkabelungsTyp . KEINE_ANGABE .
getKlimaanlage ( ) { if ( klimaanlage == null ) { return JaNeinVereinbarungTyp . KEINE_ANGABE ; } return klimaanlage ; }
a list of ImagesType . Image objects .
the price type .
the newDevelopmentAvailability property .
directions to the specified directions .
( String value ) { this . co2Rating = value ; }
( java . lang . String value ) { this . energyRating = value ; }
the viewing details .
the property status .
the pictures .
setBebaubarAttr ( BebaubarAttr value ) { this . bebaubarAttr = value ; return this ; }
anzahl balkon terrassen elements .
the parkenTyp value .
( Alter . AlterAttr value ) { this . alterAttr = value ; }
the FreizeitTyp value from the FreizeitTyp object .
the telefonart value .
( EmailSonstige . Emailart value ) { this . emailart = value ; return this ; }
a new OverseasSales object .
a new OverseasRental object .
a user defined simplefield .
< Fehlerliste . Fehler > getFehler ( ) { return fehler ; }
the Erbpacht value .
< StpSonstige > getStpSonstige ( ) { return stpSonstige ; }
a list of values .
getMinDauer ( ) { return minDauer ; }
the Zinshaus Renditeobjekt ZinsTyp .
the photo from the given URI .
the metadata of the Feed .
( Feed . Projects projects ) { this . projects = projects ; }
getProperties ( ) { return properties ; }
< new _ build > elements to previous version .
the KyeroDocument to the previous version .
a list of Immobilie .
a list of Objekt .
< Fehlerliste > getFehlerliste ( ) { return fehlerliste ; }
the status .
sonstigeTyp ( Sonstige . SonstigeTyp value ) { this . sonstigeTyp = value ; }
( Distanzen . DistanzZu value )
a list of Distanzen objects .
< DistanzenSport > getDistanzenSport ( ) { return distanzenSport ; }
( Throwable ex , Class < ? > [ ] declaredExceptions ) { if ( ex == null ) { return false ; } if ( declaredExceptions != null ) { int i = 0 ; while ( i < declaredExceptions . length ) { if ( declaredExceptions [ i ] . isAssignableFrom ( ex . getClass ( ) ) ) { return true ; } i ++ ; } } return false ; }
the bindings for the given namespace .
a namespace uri to a given prefix .
the default namespace prefix .
the opening tag from the content .
a comment line .
a comment line .
the comment token from the line .
logging to the specified location .
( ) { }
iterator to a composite iterator .
a new Option .
a string option .
an integer option .
a long option .
a double option .
( char shortForm , String longForm ) { addOption ( new Option . BooleanOption ( shortForm , longForm ) ) ; }
the value of a given option .
a singleton instance .
the current concurrency limit .
the target object to the specified class .
the static method from the given class .
matching method .
an unsigned string to a signed string .
the object to a byte array .
an object from a byte array .
( Element ele , String childEleName ) { Assert . notNull ( ele , " Element must not be null " ) ; Assert . notNull ( childEleName , " Element name must not be null " ) ; NodeList nl = ele . getChildNodes ( ) ; for ( int i = 0 ; i < nl . getLength ( ) ; i ++ ) { Node node = nl . item ( i ) ; if ( node instanceof Element && nodeNameMatch ( node , childEleName ) ) { return ( Element ) node ; } } return null ; }
the value of the child element .
the child elements of the given Element .
the name of the node .
the name of the node .
the length of the given string .
handle with release listener .
a new entry to the WeakReferenceMonitor .
the monitor thread alive .
the mobile city from the given mobile number .
a prefix mapping .
endPrefixMapping ( String prefix ) throws SAXException { if ( getContentHandler ( ) != null ) { if ( namespaces . containsKey ( prefix ) ) { getContentHandler ( ) . endPrefixMapping ( prefix ) ; namespaces . remove ( prefix ) ; } } }
a callback to a ListenableFuture .
the tree .
getTextColor ( int item ) { return textColor . getColorForState ( new int [ ] { item } , textColor . getDefaultColor ( ) ) ; }
a new BoringLayout .
the color of the pressed item .
( float size ) { if ( size != textPaint . getTextSize ( ) ) { textPaint . setTextSize ( size ) ; invalidate ( ) ; } }
the x of the item .
the intro text from the remote library .
the keywords from the test library .
the keyword arguments of the remote server .
the keyword documentation of the remote server .
a remote server .
the server .
the Robot Framework remote server .
properties to json .
properties to json .
an InputStream to JSON .
properties to JSON .
a string to a JSON string .
the properties to a JSON string .
the properties to an object map .
the properties to JSON .
the radius of the shadow .
an ApacheOcspFetcher .
the issuer of the certificate .
Markdown files from input directory .
markdown files from the input directory .
the variables in the template .
the title of the current line .
the title to the HTML file .
the initial content with the new content .
relative paths in html .
files from a directory to a directory .
the path .
( View child , int index ) { if ( index == 0 && child . getId ( ) != - 1 ) { mLargeView = ( ViewGroup ) child ; mContainer = new ScrimInsetsRelativeLayout ( getContext ( ) ) ; mContainer . setGravity ( Gravity . START ) ; mContainer . setLayoutParams ( child . getLayoutParams ( ) ) ; mContainer . addView ( mLargeView , ViewGroup . LayoutParams . MATCH_PARENT , ViewGroup . LayoutParams . MATCH_PARENT ) ; mSmallView = new LinearLayout ( getContext ( ) ) ; mContainer . addView ( mSmallView , ViewGroup . LayoutParams . MATCH_PARENT , ViewGroup . LayoutParams . MATCH_PARENT ) ; mLargeView . setAlpha ( 0 ) ; mLargeView . setVisibility ( View . GONE ) ; mContainer . setFitsSystemWindows ( true ) ; mSmallView . setFitsSystemWindows ( true ) ; return mContainer ; } return child ; }
fadeUp ( int duration ) { ResizeWidthAnimation anim = new ResizeWidthAnimation ( mContainer , mMaxWidth , new ApplyTransformationListener ( ) { @ Override public void applyTransformation ( int width ) { overlapViews ( width ) ; } } ) ; anim . setDuration ( duration ) ; mContainer . startAnimation ( anim ) ; return anim ; }
fadeDown ( int duration ) { mContainer . clearAnimation ( ) ; ResizeWidthAnimation anim = new ResizeWidthAnimation ( mContainer , mMinWidth , new ApplyTransformationListener ( ) { @ Override public void applyTransformation ( int width ) { overlapViews ( width ) ; } } ) ; anim . setDuration ( duration ) ; mContainer . startAnimation ( anim ) ; }
( int width ) { if ( width < mMinWidth ) { width = mMinWidth ; } if ( width > mMaxWidth ) { width = mMaxWidth ; } if ( width < mMinWidth ) { width = mMinWidth ; } if ( width < mMinWidth ) { width = mMinWidth ; } if ( width < mMinWidth ) { width = mMinWidth ; } if ( width < mMinWidth ) { width = mMinWidth ; } if ( width < mMinWidth ) { width = mMinWidth ; } if ( width < mMinWidth ) { width = mMinWidth ; } if ( width < mMinWidth ) { width = mMinWidth ; } if ( width < mMinWidth ) { width = mMinWidth ; } if ( width < mMinWidth ) { width = mMinWidth ; } if ( width < mMinWidth ) { width = mMinWidth ; } if (
the width of the view .
a new activity .
an activity .
a TodoListResponse .
facts from the given type .
a file from the response .
the client .
a new AccessControlEntity .
the data model .
a full export .
getExports ( ExportType exportType , UUID userId , Integer pageSize , String cursor , String sorting , String sortDirection ) throws ApiException { Object localVarPostBody = null ; String localVarPath = " / exports " . replaceAll ( " \\ { format \\ } " , " json " ) ; List < Pair > localVarQueryParams = new ArrayList < Pair > ( ) ; Map < String , String > localVarHeaderParams = new HashMap < String , String > ( ) ; Map < String , String > localVarFormParams = new HashMap < String , String > ( ) ; localVarQueryParams . addAll ( apiClient . parameterToPairs ( " " , " exportType " , exportType ) ) ; localVarQueryParams . addAll ( apiClient . parameterToPairs ( " " , " userId " , userId ) ) ; localVarQueryParams . addAll ( apiClient . parameterToPairs ( " " , " pageSize " , pageSize ) ) ;
a new OAuth2TokenClient .
a new ApiClient .
a GraphQLResult from processGraphQLMultipart .
bookmarks for the given bookmarkType .
permissions to the graph .
permissions to the graph .
withRulesets ( SPARQLRuleset ... rulesets ) { if ( rulesets == null ) { this . rulesets = new ArrayList < SPARQLRuleset > ( ) ; } else { this . rulesets = new ArrayList < SPARQLRuleset > ( rulesets . length ) ; } return this ; }
the client .
a SPARQL query .
a dataset graph .
the number of threads per process .
the image to the specified size .
the annotation .
gravity ( final Gravity value ) { if ( value == null ) { throw new IllegalArgumentException ( " Gravity value must be defined " ) ; } gravity ( value . toString ( ) ) ; return this ; }
( ) { final List < String > args = getCmdArgs ( ) ; args . add ( " + profile " ) ; args . add ( " * " ) ; return stripProfiles ( args ) ; }
a font for the given style and color .
an image to the source file .
an image to the given file .
the arguments of the target .
the information of the target class .
the time unit from the given string .
properties from the target .
the given URL .
the given file .
a list of actions from a file .
the list by height and width .
a template .
the slide XML rels .
if the mouse is within the screen region .
( final SlideElement element , final float minOverlapRatio ) { checkNotNull ( element ) ; checkNotNull ( minOverlapRatio ) ; List < SlideElement > elements = new ArrayList < SlideElement > ( ) ; elements . add ( element ) ; elements . add ( element ) ; elements . add ( element ) ; elements . add ( element ) ; elements . add ( element ) ; }
a message to the queue .
a message to a topic .
a file .
a temporary directory .
the value of the given key and value .
the event .
a trace event .
debug ( @ Nullable final String message ) { log ( LogLevel . DEBUG , DEFAULT_EVENT , message , EMPTY_STRING_ARRAY , EMPTY_OBJECT_ARRAY , DEFAULT_THROWABLE ) ; }
event and message .
info ( @ Nullable final String message ) { log ( LogLevel . INFO , DEFAULT_EVENT , message , EMPTY_STRING_ARRAY , EMPTY_OBJECT_ARRAY , DEFAULT_THROWABLE ) ; }
info ( @ Nullable final String event ) { log ( LogLevel . INFO , event , message , EMPTY_STRING_ARRAY , EMPTY_OBJECT_ARRAY , DEFAULT_THROWABLE ) ; return null ; }
the information of the event .
warn ( @ Nullable final String message ) { log ( LogLevel . WARN , DEFAULT_EVENT , message , EMPTY_STRING_ARRAY , EMPTY_OBJECT_ARRAY , DEFAULT_THROWABLE ) ; }
warn ( @ Nullable final String event , @ Nullable final String message ) { log ( LogLevel . WARN , event , message , EMPTY_STRING_ARRAY , EMPTY_OBJECT_ARRAY , DEFAULT_THROWABLE ) ; }
error ( final String message ) { log ( LogLevel . ERROR , DEFAULT_EVENT , message , EMPTY_STRING_ARRAY , EMPTY_OBJECT_ARRAY , DEFAULT_THROWABLE ) ; }
error ( final String event , final String message ) { log ( LogLevel . ERROR , event , message , EMPTY_STRING_ARRAY , EMPTY_OBJECT_ARRAY , DEFAULT_THROWABLE ) ; }
a context line and method to the target log .
the StenoWrapper .
a list of keyValuePairs .
the throwable proxy .
the log value to a log value .
the caller data .
the value to the log value .
a new database .
if the array position is not empty .
( final Cell cell , final Map < String , String > saveCommentsMap ) { if ( cell != null ) { String key = cell . getSheet ( ) . getSheetName ( ) + " ! " + CellUtility . getCellIndexNumberKey ( cell . getColumnIndex ( ) , cell . getRowIndex ( ) ) ; String saveAttr = null ; if ( saveCommentsMap != null ) { saveAttr = ParserUtility . getStringBetweenBracket ( saveCommentsMap . get ( key ) ) ; } if ( ( saveAttr == null ) && ( cell . getCellTypeEnum ( ) == CellType . STRING ) ) { saveAttr = SaveAttrsUtility . parseSaveAttrString ( cell . getStringCellValue ( ) ) ; } if ( ( saveAttr != null ) && ( ! saveAttr . isEmpty ( ) ) ) { return TieConstants . CELL_ADDR_PRE_FIX + cell . getColumnIndex ( ) + " = " + saveAttr ; }
data to object in context .
the sheet row from the context .
( final String strValue ) { if ( strValue != null ) { int first = strValue . indexOf ( TieConstants . METHOD_PREFIX ) ; int end = strValue . lastIndexOf ( TieConstants . METHOD_END ) ; if ( ( first >= 0 ) && ( first == last ) && ( end > 1 ) ) { return strValue . substring ( first + 1 , end ) ; } else if ( ( first >= 0 ) && ( first == last ) && ( end > 2 ) ) { return strValue . substring ( first + 2 , end ) ; } else { return strValue ; } } return null ; }
( final Row row ) { if ( row != null ) { Cell cell = row . getCell ( TieConstants . HIDDEN_SAVE_OBJECTS_COLUMN ) ; if ( cell != null ) { String str = cell . getStringCellValue ( ) ; if ( ( str != null ) && ( ! str . isEmpty ( ) ) ) { return str ; } } } }
the save attribute from the list .
the object in the hidden column .
the attributes to the sheet .
the save attributes for the row .
the data context for the poi cell .
the number to a float .
( final String fullName , final ConfigRangeAttrs attrs , final RowsMapping unitRowsMapping ) { attrs . setUnitRowsMapping ( unitRowsMapping ) ; this . shiftMap . put ( fullName , attrs ) ; }
the Wb to the given workbook .
a new XSSFEvaluationWorkbookWrapper .
a formula evaluator .
( ) { return this . maxColCounts ; }
( final InputStream inputStream , final Map < String , Object > pDataContext ) { }
the web sheet .
.
the exported file .
the form .
the form .
the component attributes .
the current sheet config .
the serialWorkbook .
the locale of the component .
a streamed content .
the cell helper .
the PicturesHelper .
the validation handler .
the chart helper .
to Ptg [ ] .
( final Ptg [ ] ptgs , final int position , final ShiftFormulaRef shiftFormulaRef ) { if ( ptg instanceof Ptg ) { return convertPtgForPtg ( ptgs , position , shiftFormulaRef ) ; } if ( ptg instanceof Ptg ) { return convertPtgForPtg ( ptgs , position , shiftFormulaRef ) ; } if ( ptg instanceof Ptg ) { return convertPtgForPtg ( ptgs , position , shiftFormulaRef ) ; } return convertPtgForPtg ( ptgs , position , shiftFormulaRef ) ; }
( final Ptg [ ] ptgs , final ShiftFormulaRef shiftFormulaRef ) { if ( ptgs == null ) { return singlePtg ( shiftFormulaRef , originalOperandClass , - 1 ) ; } if ( shiftFormulaRef == null ) { return singlePtg ( shiftFormulaRef , originalOperandClass , - 1 ) ; } return singlePtg ( shiftFormulaRef , originalOperandClass , - 1 ) ; }
[ ] singlePtg ( final Object ptg , final byte originalOperandClass , final int formulaChanged ) { Ptg [ ] newPtg = new Ptg [ 1 ] ; if ( originalOperandClass != ( - 1 ) ) { ( ( Ptg ) ptg ) . setClass ( originalOperandClass ) ; } Object ptgAfter = ptg ; if ( ptg instanceof FuncVarPtg ) { FuncVarPtg fptg = ( FuncVarPtg ) ptg ; if ( ( formulaChanged > 0 ) && ( fptg . getNumberOfOperands ( ) != formulaChanged ) ) { ptgAfter = FuncVarPtg . create ( ( ( FuncVarPtg ) ptg ) . getName ( ) , formulaChanged ) ; } } newPtg [ 0 ] = ( Ptg ) ptgAfter ; return newPtg ; }
a list of all rows mapping for the current row .
a list of all rows .
a new RefPtg .
a new Ptg for the given refPtg .
a dynamic row for the given areaPtgBase .
the color of the solidFill .
a color from the SpPr .
( final ThemesTable themeTable , final CTSolidColorFillProperties colorFill ) { return findAutomaticFillColor ( themeTable , colorFill ) ; }
getXColorFromSchemeClr ( final CTSchemeColor ctsColor , final ThemesTable themeTable ) { if ( ctsColor . getVal ( ) != null ) { return getXColorWithSchema ( ctsColor . getVal ( ) . toString ( ) , 0 , ctsColor , themeTable ) ; } return null ; }
getXColorFromRgbClr ( final CTSRgbColor ctrColor ) { if ( ctrColor == null ) { return null ; } int lumOff = 0 ; int lumMod = 0 ; int alphaStr = 0 ; try { byte [ ] rgb = ctrColor . getVal ( ) ; bcolor = new XSSFColor ( rgb ) ; } catch ( Exception ex ) { LOG . log ( Level . SEVERE , " Cannot get rgb color error = " + ex . getLocalizedMessage ( ) , ex ) ; return null ; } return assembleXcolor ( bcolor , 0 , lumOff , lumMod , alphaStr ) ; }
getXColorWithAutomaticFill ( final int index , final ThemesTable themeTable ) { int reminder = ( index + 1 ) % AUTOCOLORSIZE ; if ( reminder == 0 ) { reminder = AUTOCOLORSIZE ; } String schema = AUTOCOLORNAME + reminder ; double tint = getAutomaticTint ( index ) ; return getXColorWithSchema ( schema , tint , null , themeTable ) ; }
xssfClrToClr ( final XSSFColor xssfColor ) { short [ ] rgb = getTripletFromXSSFColor ( xssfColor ) ; return new Color ( rgb [ 0 ] , rgb [ 1 ] , rgb [ 2 ] ) ; }
the Triplet from the xssf color .
the color from the cell .
( final UIComponent component ) { String cname = component . getClass ( ) . getSimpleName ( ) ; if ( supportComponents . contains ( cname ) ) { return cname ; } return null ; }
the attributes of the component .
( final Object obj , final String methodName ) { for ( AttributesType attr : AttributesType . values ( ) ) { try { obj . getClass ( ) . getMethod ( methodName , new Class [ ] { attr . clazz } ) ; return attr ; } catch ( Exception ex ) { LOG . log ( Level . FINE , " error in matchParaMeterOfMethod = " + ex . getLocalizedMessage ( ) , ex ) ; } } return null ; }
the property to the value of the object .
the property value from the given object .
the control attributes for the cell .
the cell validate attributes for the given cell .
( final Sheet sheet1 , final FacesCell fcell , final String fId ) { if ( parent . getPicturesMap ( ) != null ) { setupFacesCellPictureCharts ( sheet1 , fcell , cell , fId ) ; } if ( parent . getCharsData ( ) != null ) { setupFacesCellPictureCharts ( sheet1 , fcell , cell , fId ) ; } if ( parent . getCharsData ( ) . getChartsMap ( ) != null ) { setupFacesCellPictureCharts ( sheet1 , fcell , cell , fId ) ; } }
( final Sheet sheet1 , final FacesCell fcell ) { try { String chartId = parent . getCharsData ( ) . getChartPositionMap ( ) . get ( fId ) ; if ( chartId != null ) { BufferedImage img = parent . getCharsData ( ) . getChartsMap ( ) . get ( chartId ) ; if ( img != null ) { fcell . setChartStyle ( PicturesUtility . generateChartStyle ( sheet1 , fcell , cell , chartId , parent . getCharsData ( ) . getChartAnchorsMap ( ) ) ) ; } else { fcell . setChartStyle ( PicturesUtility . generateChartStyle ( sheet1 , fcell , cell , chartId , parent . getCharsData ( ) . getChartAnchorsMap ( ) ) ) ; } } else { fcell . setChartStyle ( PicturesUtility . generateChartStyle ( sheet1 , fcell
( final Sheet sheet1 , final FacesCell fcell , final Cell cell , final String fId ) { try { Picture pic = parent . getPicturesMap ( ) . get ( fId ) ; if ( pic != null ) { fcell . setContainPic ( true ) ; fcell . setPictureId ( fId ) ; fcell . setPictureStyle ( PicturesUtility . generatePictureStyle ( sheet1 , fcell , cell , pic ) ) ; } } catch ( Exception ex ) { LOG . log ( Level . SEVERE , " setupFacesCell Picture error = " + ex . getMessage ( ) , ex ) ; } }
( final Workbook wb ) { try { if ( wb instanceof XSSFWorkbook ) { initXSSFChartsMap ( ( XSSFWorkbook ) wb , parent . getCharsData ( ) ) ; } } catch ( Exception e ) { LOG . log ( Level . SEVERE , " getChartsMap Error Exception = " + e . getLocalizedMessage ( ) , e ) ; } }
the title of the chart .
( final JFreeChart chart , final int seriesIndex ) { if ( chart . getPlot ( ) instanceof CategoryPlot ) { CategoryPlot categoryPlot = chart . getCategoryPlot ( ) ; CategoryItemRenderer cir = categoryPlot . getRenderer ( ) ; try { cir . setSeriesStroke ( seriesIndex , stroke ) ; } catch ( Exception e ) { LOG . log ( Level . SEVERE , " Error setting style ' " + style + " ' for series ' " + Integer . toString ( seriesIndex ) + " ' of chart ' " + chart . toString ( ) + " ' : " + e . getLocalizedMessage ( ) , e ) ; } } }
a PieChart3D .
the bar style for the chart .
anchors map for all charts .
the chart id from the parent chart .
anchors map .
a single XSSFChart .
the expression to a collection object .
the full name of the row .
( final ConfigBuildRef configBuildRef , final String actionFullName ) { Map < Cell , String > cachedMap = configBuildRef . getCachedCells ( ) ; Map < String , List < RowsMapping > > rowsMap = new HashMap < > ( ) ; for ( Map . Entry < Cell , String > entry : cachedMap . entrySet ( ) ) { Cell cell = entry . getKey ( ) ; String originFormula = entry . getValue ( ) ; if ( originFormula != null ) { setupUpperLevelFormula ( cell , originFormula , actionFullName , rowsMap , configBuildRef ) ; } } }
for the given cell .
( final Sheet sheet , final XSSFEvaluationWorkbook wbWrapper , final ShiftFormulaRef shiftFormulaRef , final String originFormula ) { if ( ( shiftFormulaRef . getWatchList ( ) != null ) && ( ! shiftFormulaRef . getWatchList ( ) . isEmpty ( ) ) ) { Ptg [ ] ptgs = FormulaParser . parse ( originFormula , wbWrapper , FormulaType . CELL , sheet . getWorkbook ( ) . getSheetIndex ( sheet ) ) ; Ptg [ ] convertedFormulaPtg = ShiftFormulaUtility . convertSharedFormulas ( ptgs , shiftFormulaRef ) ; if ( shiftFormulaRef . getFormulaChanged ( ) > 0 ) { cell . setCellFormula ( FormulaRenderer . toFormulaString ( wbWrapper , convertedFormulaPtg ) ) ; } } }
< RowsMapping > gatherRowsMappingByFullName ( final ConfigBuildRef configBuildRef , final String fullName ) { List < RowsMapping > list = new ArrayList < > ( ) ; Map < String , ConfigRangeAttrs > shiftMap = configBuildRef . getShiftMap ( ) ; for ( Map . Entry < String , ConfigRangeAttrs > entry : shiftMap . entrySet ( ) ) { String fname = entry . getKey ( ) ; if ( fname . startsWith ( fullName + " : " ) || fname . equals ( fullName ) ) { ConfigRangeAttrs attrs = entry . getValue ( ) ; list . add ( attrs . getUnitRowsMapping ( ) ) ; } } return list ; }
the index number in the shift map .
( final Map < String , ConfigRangeAttrs > shiftMap , final String addedFullName ) { if ( shiftMap . containsKey ( addedFullName ) ) { return shiftMap . get ( addedFullName ) . getFinalLength ( ) ; } return null ; }
( final ConfigBuildRef configBuildRef , final int startRowIndex , final String fullName , final Map < String , String > changeMap , final int steps ) { String searchName = fullName . substring ( 0 , fullName . lastIndexOf ( ' . ' ) + 1 ) ; Sheet sheet = configBuildRef . getSheet ( ) ; for ( int i = startRowIndex ; i <= sheet . getLastRowNum ( ) ; i ++ ) { Row row = sheet . getRow ( i ) ; String fname = getFullNameFromRow ( row ) ; if ( ( fname != null ) && ( fname . indexOf ( searchName ) >= 0 ) ) { int sindex = fname . indexOf ( searchName ) ; String snum = fname . substring ( sindex + searchName . length ( ) ) ; int sufindex = snum . indexOf ( ' : ' ) ; String suffix = " " ; if ( sufindex > 0 ) { snum = snum
( final Row row ) { Cell cell = row . getCell ( TieConstants . HIDDEN_FULL_NAME_COLUMN , MissingCellPolicy . CREATE_NULL_AS_BLANK ) ; cell . setCellValue ( fullName ) ; return cell ; }
the original row number in the hidden column .
( final Row row ) { Cell cell = row . getCell ( TieConstants . HIDDEN_ORIGIN_ROW_NUMBER_COLUMN , MissingCellPolicy . CREATE_NULL_AS_BLANK ) ; cell . setCellValue ( Integer . toString ( rowNum ) ) ; }
parent rows mapping from shift map .
< RowsMapping > findChildRowsMappingFromShiftMap ( final String fullName , final NavigableMap < String , ConfigRangeAttrs > shiftMap ) { List < RowsMapping > rowsMappingList = new ArrayList < > ( ) ; NavigableMap < String , ConfigRangeAttrs > tailmap = shiftMap . tailMap ( fullName , false ) ; for ( Map . Entry < String , ConfigRangeAttrs > entry : tailmap . entrySet ( ) ) { String key = entry . getKey ( ) ; if ( key . startsWith ( fullName ) ) { rowsMappingList . add ( entry . getValue ( ) . getUnitRowsMapping ( ) ) ; } else { break ; } } return rowsMappingList ; }
( final Collection collection , final int index ) { if ( index >= 0 ) { if ( collection instanceof List ) { List list = ( List ) collection ; return list . get ( index ) ; } int i = 0 ; for ( Object object : collection ) { if ( i == index ) { return object ; } i ++ ; } } return null ; }
the current range .
static boolean isStaticRow ( final ConfigRange sourceConfigRange , final int rowIndex ) { if ( sourceConfigRange . getCommandList ( ) != null ) { for ( int i = 0 ; i < sourceConfigRange . getCommandList ( ) . size ( ) ; i ++ ) { Command command = sourceConfigRange . getCommandList ( ) . get ( i ) ; if ( ( rowIndex >= command . getConfigRange ( ) . getFirstRowAddr ( ) . getRow ( ) ) && ( rowIndex < command . getConfigRange ( ) . getLastRowPlusAddr ( ) . getRow ( ) ) ) { return false ; } } } return true ; }
boolean isStaticRowRef ( final ConfigRange sourceConfigRange ) { if ( sourceConfigRange . getCommandList ( ) != null && sourceConfigRange . getCommandList ( ) . size ( ) > 0 ) { for ( int i = 0 ; i < sourceConfigRange . getCommandList ( ) . size ( ) ; i ++ ) { Command command = sourceConfigRange . getCommandList ( ) . get ( i ) ; int rowIndex = row . getRowNum ( ) ; if ( ( rowIndex >= command . getTopRow ( ) ) && ( rowIndex < ( command . getTopRow ( ) + command . getFinalLength ( ) ) ) ) { return false ; } } } return true ; }
expression with cell value .
the index of the merged region .
a list of skipped region cells .
a skip cell to the region .
( List < TieCommandAlias > tieCommandAliasList ) { if ( tieCommandAliasList == null ) { return ; } for ( Row row : sheet ) { for ( Cell cell : row ) { buildCellCommentFromalias ( tieCommandAliasList , cell ) ; } } }
a comment to the cell .
the configuration for the given sheet .
the sheet configuration .
a form command from the sheetConfig .
the last cell in the row .
( final XSSFSheet sheet , final Map < String , SheetConfiguration > sheetConfigMap , final CellAttributesMap cellAttributesMap ) { if ( ( sheet . getLastRowNum ( ) <= 0 ) && ( sheet . getRow ( 0 ) == null ) ) { return ; } checkAndRepairLastRow ( sheet ) ; }
the last row from the sheet .
a list of commands from a sheet .
the parent for the child command .
whether the command is anEACH command .
command to sheet config form .
the template for the given sheet .
a list of commands for a given cell .
method line .
command line .
( final Cell cell , final Map < String , Map < String , String > > sheetCommentMap , final boolean normalComment ) { String cellKey = cell . getSheet ( ) . getSheetName ( ) + " ! $ " + cell . getColumnIndex ( ) + " $ " + cell . getRowIndex ( ) ; ParserUtility . parseCommentToMap ( cellKey , sheetCommentMap , normalComment ) ; }
a config command .
command line attributes .
getSheetConfigurationFromConfigCommand ( final Sheet sheet , final FormCommand fcommand , final int sheetRightCol ) { SheetConfiguration sheetConfig = new SheetConfiguration ( ) ; sheetConfig . setFormName ( fcommand . getName ( ) ) ; sheetConfig . setSheetName ( sheet . getSheetName ( ) ) ; int leftCol = fcommand . getLeftCol ( ) ; int rightCol = fcommand . getRightCol ( ) ; sheetConfig . setSheetName ( sheet . getSheetName ( ) ) ; sheetConfig . setSheetName ( sheet . getSheetName ( ) ) ; sheetConfig . setSheetName ( sheet . getSheetName ( ) ) ; sheetConfig . setSheetName ( sheet . getSheetName ( ) ) ; sheetConfig . setSheetName ( sheet . getSheetName ( ) ) ; sheetConfig . setSheetName ( sheet . getSheetName ( ) ) ; sheetConfig . setSheetName ( sheet . getSheet
the footer of the form .
the body of the form .
the header range of the form command .
a row .
( final NavigableMap < String , ConfigRangeAttrs > shiftMap ) { this . shiftMap = shiftMap ; }
a list of all the names in the sheet .
( final Map < String , Command > commandIndexMap , final String [ ] varparts ) { if ( varparts . length == TieConstants . DEFAULT_COMMAND_PART_LENGTH ) { return ( EachCommand ) commandIndexMap . get ( TieConstants . EACH_COMMAND_FULL_NAME_PREFIX + varparts [ 1 ] ) ; } return null ; }
empty object in the context .
the object in the context .
the collection data in the context .
the command range .
if a row is allowed to be added .
a template into the given config range .
( final Cell cell , final Map < String , Object > context , final ExpressionEngine engine ) { if ( strValue . contains ( TieConstants . METHOD_PREFIX ) ) { Object evaluationResult = evaluate ( strValue , context , engine ) ; if ( evaluationResult == null ) { evaluationResult = " " ; } CellUtility . setCellValue ( cell , evaluationResult . toString ( ) ) ; createTieCell ( cell , context , engine ) ; } }
user formula .
the user formulas .
a new cell comment .
a Boolean expression .
all rows from the sheet .
a single row from a sheet .
( final Sheet sheet , final int rowIndexStart , final Map < Cell , String > cachedMap ) { Row removingRow = sheet . getRow ( rowIndexStart ) ; if ( removingRow != null ) { for ( Cell cell : removingRow ) { cachedMap . remove ( cell ) ; } } }
all rows in the body .
a picture from the current page .
the chart from the current page .
the value to a string .
the value of the given cell .
the cell value without formatting .
the value of the cell .
the value of the cell .
the value of the cell .
( final Cell c ) { c . setCellType ( CellType . STRING ) ; c . setCellValue ( value ) ; }
( final Cell c , final String value ) { if ( " Y " . equalsIgnoreCase ( value ) || " Yes " . equalsIgnoreCase ( value ) || " True " . equalsIgnoreCase ( value ) ) { c . setCellValue ( true ) ; } else { c . setCellValue ( false ) ; } }
( final Cell c , final String value ) { String date = WebSheetUtility . parseDate ( value ) ; setCellValueString ( c , date ) ; }
( final Cell c , final String value ) { double val = Double . parseDouble ( value . replace ( Character . toString ( ' , ' ) , " " ) ) ; c . setCellType ( CellType . NUMERIC ) ; c . setCellValue ( val ) ; }
all rows to the destination sheet .
a single row to the destination sheet .
the cell to the destination sheet .
the cell value to a new cell .
CellStyle from sourceCell to newCellStyle .
a cell comment .
a comment anchor .
a comment from a cell .
comment settings .
getVmlDrawingFromCell ( final Cell cell ) { XSSFSheet sourceSheet = ( XSSFSheet ) cell . getSheet ( ) ; for ( POIXMLDocumentPart sourcePart : sourceSheet . getRelations ( ) ) { if ( sourcePart != null ) { return ( XSSFVMLDrawing ) sourcePart ; } } return null ; }
a CTShape from VML .
the cell style from the source cell .
a FacesCell to a FacesCell .
the row and column from the UIComponent .
the init rows from the sheet configuration .
( final int row ) { return getFacesRowFromBodyRow ( row , null ) ; }
the faces cell from the body row .
( final int rowIndex , final int colIndex ) { if ( ( sheet1 != null ) && ( sheet1 . getRow ( rowIndex ) != null ) ) { return sheet1 . getRow ( rowIndex ) . getCell ( colIndex ) ; } return null ; }
the key from the poi cell .
a TieCell to the map .
the current data context name .
a Jexl expression .
a Jexl expression .
the row to the output stream .
the row from the map .
the map .
all serial rows .
the type of the chart .
toStroke ( final String style ) { BasicStroke result = null ; if ( style != null ) { float lineWidth = STROKE_DEFAULT_LINE_WIDTH ; float [ ] dash = { STROKE_DEFAULT_DASH_WIDTH } ; float [ ] dot = { lineWidth } ; if ( style . equalsIgnoreCase ( STYLE_LINE ) ) { result = new BasicStroke ( lineWidth , BasicStroke . CAP_BUTT , BasicStroke . JOIN_MITER , STROKE_MITER_LIMIT_STYLE_LINE , dash , STROKE_DEFAULT_DASHPHASE ) ; } else if ( style . equalsIgnoreCase ( STYLE_DOT ) ) { result = new BasicStroke ( lineWidth , BasicStroke . CAP_BUTT , BasicStroke . JOIN_MITER , STROKE_MITER_LIMIT_STYLE_DOT , dot , STROKE_DEFAULT_DASHPHASE ) ;
the chart data .
the chart data .
( final ChartsData charsData ) { Map < String , ClientAnchor > anchortMap = charsData . getChartAnchorsMap ( ) ; Map < String , String > positionMap = charsData . getChartPositionMap ( ) ; anchortMap . clear ( ) ; positionMap . clear ( ) ; for ( int i = 0 ; i < wb . getNumberOfSheets ( ) ; i ++ ) { initXSSFAnchorsMapForSheet ( anchortMap , positionMap , wb . getSheetAt ( i ) ) ; } }
( final Map < String , ClientAnchor > anchortMap , final Map < String , String > positionMap ) { if ( anchortMap == null ) { anchortMap = new HashMap < String , ClientAnchor > ( ) ; positionMap = new HashMap < String , String > ( ) ; } return anchortMap ; }
the chart id associated with a CTTwoCellAnchor .
the chart id from the child node attributes .
a new row into the database .
the data in the context .
the result of the formula .
( final int rowIndex , final int colIndex , final String tabName ) { if ( parent . getWb ( ) != null ) { return CellUtility . getPoiCellFromSheet ( rowIndex , colIndex , parent . getWb ( ) . getSheet ( parent . getSheetConfigMap ( ) . get ( tabName ) . getSheetName ( ) ) ) ; } return null ; }
the FacesCell from the current page .
the current data context .
( final String fullName ) { String [ ] parts = fullName . split ( " : " ) ; String part = parts [ parts . length - 1 ] ; return startRestoreDataContext ( part ) ; }
the current data context .
data context .
( final Sheet sheet , final int shiftnum ) { try { this . setFirstRowRef ( sheet . getRow ( attrs . getFirstRowAddr ( ) . getRow ( ) + shiftnum ) . getCell ( attrs . getFirstRowAddr ( ) . getColumn ( ) , MissingCellPolicy . CREATE_NULL_AS_BLANK ) , false ) ; this . setLastRowRef ( sheet . getRow ( attrs . getLastRowAddr ( ) . getRow ( ) + shiftnum ) . getCell ( attrs . getLastRowAddr ( ) . getColumn ( ) , MissingCellPolicy . CREATE_NULL_AS_BLANK ) , false ) ; } catch ( Exception ex ) { LOG . log ( Level . SEVERE , " shiftRowRef error = " + ex . getLocalizedMessage ( ) , ex ) ; } }
the first row ref .
( final Sheet sheet , final int rightCol ) { if ( sheet != null ) { this . attrs . setLastRowPlusRef ( new SerialCellAddress ( sheet . getRow ( rightCol ) ) ) ; } }
the cells for the given row .
a single cell .
the contents of the serial workbook .
a list of all categories from a given range .
( final List bsers , final ThemesTable themeTable , final ChartObject ctObj ) { List < ChartSeries > lseriesList = new ArrayList < > ( ) ; try { for ( int index = 0 ; index < bsers . size ( ) ; index ++ ) { Object ctObjSer = bsers . get ( index ) ; ChartSeries ctSer = buildChartSeriesInList ( themeTable , ctObj , ctObjSer , index ) ; lseriesList . add ( ctSer ) ; } } catch ( Exception ex ) { LOG . log ( Level . FINE , " failed in buildSeriesList " , ex ) ; } return lseriesList ; }
( final ThemesTable themeTable , final ChartObject ctObj , final int index ) { ChartSeries ctSer = new ChartSeries ( ) ; ctSer . setSeriesLabel ( new ParsedCell ( ctObj . getSeriesLabelFromCTSer ( ctObjSer ) ) ) ; ctSer . setSeriesColor ( ColorUtility . geColorFromSpPr ( index , ctObj . getShapePropertiesFromCTSer ( ctObjSer ) , themeTable , ctObj . isLineColor ( ) ) ) ; ctSer . setSeriesColor ( ColorUtility . geColorFromSpPr ( index , ctObj . getShapePropertiesFromCTSer ( ctObjSer ) , themeTable , ctObj . isLineColor ( ) ) ) ; }
< XColor > getColorListFromDPTList ( final List < CTDPt > dptList , final List < ParsedCell > cells , final ThemesTable themeTable , final ChartObject ctObj ) { List < XColor > colors = new ArrayList < > ( ) ; if ( ( dptList != null ) && ( cells != null ) ) { for ( int index = 0 ; index < cells . size ( ) ; index ++ ) { CTDPt dpt = getDPtFromListWithIndex ( dptList , index ) ; CTShapeProperties ctSpPr = null ; if ( dpt != null ) { ctSpPr = dpt . getSpPr ( ) ; } colors . add ( ColorUtility . geColorFromSpPr ( index , ctSpPr , themeTable , ctObj . isLineColor ( ) ) ) ; } } return colors ; }
the dpt from the list .
the command index map .
( final Workbook wb , final Map < String , Picture > picMap ) { if ( wb instanceof XSSFWorkbook ) { getXSSFPictruesMap ( ( XSSFWorkbook ) wb , picMap ) ; } return ; }
Pictrues Map from the workbook .
the Pictures in the Map .
a picture style .
chart style .
the anchor size from the sheet .
getPattern ( String alias ) { if ( ( this . pattern == null ) && ( alias != null ) ) { this . pattern = Pattern . compile ( " \\ s * " + ParserUtility . wildcardToRegex ( alias ) ) ; } return pattern ; }
a streamed content .
a cell from a sheet .
the row style .
the cell font style .
the color of the font .
the decoration of the font .
the cell style .
the cell style .
the alignment from the poi cell .
the vertical alignment of the cell .
the total height of the sheet .
the cell style .
the input type from the cell .
the resource paths from the context .
resourceAsStream ( final FacesContext context , final String path ) { return context . getExternalContext ( ) . getResourceAsStream ( path ) ; }
the prefix path from the resource .
the input type .
( final String beanName ) { this . beanName = beanName ; }
a short array into a string .
the value to the nearest decimal place .
the type of the tab .
the tab style .
the default date pattern .
the decimal separator .
( ) { return this . getThousandSeparator ( ) ; }
the TieCommandAliasList .
the form watch list for the given sheet .
a watch list to a cell .
a new row to the watch list .
the command string .
( final Cell cell , final String newComment , final CellAttributesMap cellAttributesMap ) { if ( newComment == null ) { return ; } if ( newComment . isEmpty ( ) ) { return ; } int widgetStart = newComment . indexOf ( TieConstants . METHOD_WIDGET_PREFIX ) ; int elStart = newComment . indexOf ( TieConstants . EL_START_BRACKET ) ; if ( ( widgetStart < 0 ) || ( widgetStart >= elStart ) ) { return ; } String type = newComment . substring ( widgetStart + TieConstants . METHOD_WIDGET_PREFIX . length ( ) , elStart ) ; String values = getStringBetweenBracket ( newComment ) ; if ( values == null ) { return ; } String key = getAttributeKeyInMapByCell ( cell ) ; cellAttributesMap . getCellInputType ( ) . put ( key , type ) ; cellAttributesMap . getCellInput
the attribute key from the cell .
( final Cell cell , final String newComment , final CellAttributesMap cellAttributesMap ) { if ( ( newComment == null ) || ( newComment . isEmpty ( ) ) ) { return ; } if ( ! newComment . startsWith ( TieConstants . METHOD_VALIDATE_PREFIX ) && ! newComment . startsWith ( TieConstants . METHOD_VALIDATE_PREFIX + TieConstants . METHOD_VALIDATE_PREFIX + TieConstants . METHOD_VALIDATE_PREFIX + TieConstants . METHOD_VALIDATE_PREFIX + TieConstants . METHOD_VALIDATE_PREFIX + TieConstants . METHOD_VALIDATE_PREFIX + TieConstants . METHOD_VALIDATE_PREFIX + TieConstants . METHOD_VALIDATE_PREFIX + TieConstants . METHOD_VALIDATE_PREFIX + TieConstants . METHOD_VALIDATE_PREFIX + TieConstants . METHOD_VALIDATE_PREFIX + TieConstants . METHOD_VALIDATE
( final String str , final int startPos ) { int bracketNum = 0 ; for ( int i = startPos ; i < str . length ( ) ; i ++ ) { char current = str . charAt ( i ) ; if ( current == TieConstants . EL_START_BRACKET ) { bracketNum ++ ; } else if ( current == TieConstants . EL_END ) { bracketNum -- ; if ( bracketNum <= 0 ) { return i ; } } else if ( current == TieConstants . EL_START_BRACKET ) { bracketNum ++ ; } else if ( current == TieConstants . EL_END_BRACKET ) { bracketNum -- ; if ( bracketNum <= 0 ) { return i ; } } } return - 1 ; }
( final String attrString ) { Map < String , String > attrMap = new LinkedHashMap < > ( ) ; Matcher attrMatcher = TieConstants . ATTR_REGEX_PATTERN . matcher ( attrString ) ; while ( attrMatcher . find ( ) ) { String attrData = attrMatcher . group ( ) ; int attrNameEndIndex = attrData . indexOf ( ' = ' ) ; String attrName = attrData . substring ( 0 , attrNameEndIndex ) . trim ( ) ; String attrValuePart = attrData . substring ( attrNameEndIndex + 1 ) . trim ( ) ; attrMap . put ( attrName , attrValuePart ) ; } return attrMap ; }
( final List < CellFormAttributes > clist , final String controlAttrs ) { clist . clear ( ) ; if ( controlAttrs != null ) { String [ ] cattrs = controlAttrs . split ( TieConstants . SPLIT_SPACE_SEPERATE_ATTRS_REGX , - 1 ) ; for ( String cattr : cattrs ) { String [ ] details = splitByEualSign ( cattr ) ; if ( details . length > 1 ) { CellFormAttributes attr = new CellFormAttributes ( ) ; attr . setType ( details [ 0 ] . trim ( ) ) ; attr . setValue ( details [ 1 ] . replaceAll ( " \\s + " , " " ) ) ; clist . add ( attr ) ; } } } }
( final List < CellFormAttributes > clist , final String controlAttrs ) { if ( controlAttrs == null ) { return ; } String [ ] cattrs = controlAttrs . split ( TieConstants . SPLIT_SPACE_SEPERATE_ATTRS_REGX , - 1 ) ; CellFormAttributes attr = new CellFormAttributes ( ) ; for ( String cattr : cattrs ) { extractValidationAttributes ( attr , cattr ) ; } if ( ( attr . getValue ( ) != null ) && ( ! attr . getValue ( ) . isEmpty ( ) ) ) { clist . add ( attr ) ; } }
the attribute value into a comma separated string .
( final String key , final String type , final List < CellFormAttributes > inputs , final CellAttributesMap cellAttributesMap ) { SpecialAttributes sAttr = new SpecialAttributes ( ) ; for ( CellFormAttributes attr : inputs ) { gatherSpecialAttributes ( type , sAttr , attr ) ; } if ( sAttr . selectLabels != null ) { processSelectItemAttributes ( key , cellAttributesMap , sAttr ) ; } if ( type . equalsIgnoreCase ( TieConstants . WIDGET_CALENDAR ) ) { processCalendarAttributes ( key , cellAttributesMap , sAttr ) ; } }
the default date pattern to the CellAttributesMap .
( final String key , final CellAttributesMap cellAttributesMap , final SpecialAttributes sAttr ) { if ( sAttr . selectValues == null ) { sAttr . selectValues = new LinkedHashMap < > ( ) ; } if ( sAttr . selectLabels == null ) { sAttr . selectLabels = new LinkedHashMap < > ( ) ; } if ( sAttr . selectValues . length == 0 ) { sAttr . selectValues = new LinkedHashMap < > ( ) ; } if ( sAttr . selectLabels . length == 0 ) { sAttr . selectLabels = new LinkedHashMap < > ( ) ; } if ( sAttr . selectValues . length == 0 ) { sAttr . selectValues = new LinkedHashMap < > ( ) ; } if ( sAttr . defaultSelectLabel != null ) { smap . put ( sAttr . defaultSelectLabel , sAttr . defaultSelectValue ) ; } if ( sAttr . selectLabels != null ) {
a special attribute .
( final String cellKey , final String newComment , final Map < String , Map < String , String > > sheetCommentMap , final boolean normalComment ) { if ( ( newComment != null ) && ( ! newComment . trim ( ) . isEmpty ( ) ) ) { String commentKey = TieConstants . NORMAL_COMMENT_KEY_IN_MAP ; if ( ! normalComment ) { commentKey = newComment . substring ( 0 , newComment . indexOf ( TieConstants . EL_START_BRACKET ) ) ; } Map < String , String > map = sheetCommentMap . get ( commentKey ) ; if ( map == null ) { map = new HashMap < > ( ) ; } map . put ( cellKey , newComment ) ; sheetCommentMap . put ( commentKey , map ) ; } }
( String input , int startPosition ) { for ( int i = startPosition ; i < input . length ( ) ; i ++ ) { c = input . charAt ( i ) ; if ( c != ' $ ' && ! Character . isLetterOrDigit ( c ) ) { return i ; } } return - 1 ; }
characters from a string .
the name of the column .
a string to an int .
the cell by reference .
the height of the column .
the date from the given string .
the date from the entry .
true if the given string is numeric .
the value of the parameter .
the property to the value of the given object .
a cell to another cell .
true if the range is inside the parent .
( final Sheet sheet ) { for ( Row row : sheet ) { if ( row . getLastCellNum ( ) > TieConstants . MAX_COLUMNS_IN_SHEET ) { deleteHiddenColumnsInRow ( row ) ; } } }
hidden columns in row .
cell from row .
public final void processEvent ( final SystemEvent event ) { LOGGER . log ( Level . INFO , " Running on TieFaces { 0 } " , AppUtils . getBuildVersion ( ) ) ; }
the status of the form .
a cell in the current page .
a TieWebSheetValidationBean .
the error message from the object in the context .
( final int formRow , final int formCol ) { return validateAllRulesForSingleCell ( formRow , formCol ) ; }
the value of a CellFormAttributes .
a cell in the current page .
the current page .
a row in the current page .
a row .
cached cells in current page .
the cached cells .
the submit mode in the view .
the current page .
the templateCommentMap .
header rows .
header row without configuration tab .
a header cell to the parent .
the header column style .
the width of the cell .
header cells .
the column width style .
the workbook .
a new tab to the form .
the data from the serial data context .
the data for the given sheet .
the data for the given row .
data for cell .
the index of the tab in the parent .
the workbook from the current page .
( ) { if ( parent . getWebFormTabView ( ) != null ) { parent . getWebFormTabView ( ) . setActiveIndex ( tabIndex ) ; } }
the first column of the table .
objs in viewMap .
the row height of the faces row .
body rows .
( final FacesBodyRow facesBodyRow ) { return facesBodyRow ; }
the cached cell .
the cell .
dynamic columns .
a repeat row to a sheet .
body rows in the specified range .
( final RequestContext requestContext ) { if ( requestContext != null ) { LOG . log ( Level . FINE , " run setUnsavedState ( { } ) " , statusFlag . toString ( ) ) ; requestContext . execute ( " setUnsavedState ( " + statusFlag . toString ( ) + " ) " ) ; } }
the unsaved status .
a common constructor for the given type .
the InputStream to the output stream .
a long value to the writer .
a line to the output file .
TrafficStatsTag to TrafficStatsTag .
a BitmapBinaryData to the result .
a binary data to the file descriptor .
the parameter from the result .
a header to the response .
the result .
play ( final Uri uri , final int volume , final Bundle params ) { playing = true ; paused = false ; context . startService ( createPlayIntent ( ) . setData ( uri ) . putExtra ( StreamingPlaybackService . EXTRA_VOLUME , volume ) . putExtra ( StreamingPlaybackService . EXTRA_TRACK_INFO , params ) ) ; }
the service .
to streaming service .
( ) { if ( bindRequested ) { unbind ( ) ; } }
listener .
the image to disk .
streamToString ( InputStream stream , final String charset , final BuffersPool buffersPool ) throws IOException { ByteArrayOutputStream output = new ByteArrayOutputStream ( ) ; transfer ( stream , output , buffersPool ) ; return new String ( output . toByteArray ( ) , charset ) ; }
streamToString ( InputStream stream , final BuffersPool buffersPool ) throws IOException { return streamToString ( stream , UTF_8_NAME , buffersPool ) ; }
data to the server .
the number of bytes in the stream .
the stream .
a byte array .
the stream .
( OutputStream out ) throws IOException { if ( DEBUG ) { Log . v ( TAG , " sendStart ( OutputStream out ) " ) ; } out . write ( EXTRA_BYTES ) ; out . write ( getPartBoundary ( ) ) ; out . write ( CRLF_BYTES ) ; }
( final OutputStream out ) throws IOException { if ( DEBUG ) { Log . v ( TAG , " enter sendDispositionHeader ( OutputStream out ) " ) ; } out . write ( CONTENT_DISPOSITION_BYTES ) ; out . write ( QUOTE_BYTES ) ; out . write ( EncodingUtils . getAsciiBytes ( getName ( ) ) ) ; out . write ( QUOTE_BYTES ) ; out . write ( CONTENT_DISPOSITION_BYTES ) ; out . write ( QUOTE_BYTES ) ; out . write ( CONTENT_DISPOSITION_BYTES ) ; out . write ( CONTENT_DISPOSITION_BYTES ) ; out . write ( CONTENT_DISPOSITION_BYTES ) ; out . write ( CONTENT_DISPOSITION_BYTES ) ; out . write ( CONTENT_DISPOSITION_BYTES ) ; out . write ( CONTENT_DISPOSITION_BYTES ) ; }
( final OutputStream out ) throws IOException { if ( DEBUG ) { Log . v ( TAG , " enter sendContentTypeHeader ( OutputStream out ) " ) ; } final String contentType = getContentType ( ) ; if ( contentType != null ) { out . write ( CRLF_BYTES ) ; out . write ( CONTENT_TYPE_BYTES ) ; out . write ( EncodingUtils . getAsciiBytes ( contentType ) ) ; } }
the transfer encoding header .
( final OutputStream out ) throws IOException { if ( DEBUG ) { Log . v ( TAG , " enter sendEndOfHeader ( OutputStream out ) " ) ; } out . write ( CRLF_BYTES ) ; out . write ( CRLF_BYTES ) ; }
( OutputStream out ) throws IOException { if ( DEBUG ) { Log . v ( TAG , " enter sendEnd ( OutputStream out ) " ) ; } out . write ( CRLF_BYTES ) ; out . write ( CRLF_BYTES ) ; out . write ( CRLF_BYTES ) ; }
a part boundary .
the length of the Parts .
if the given URL is a redirect .
a 304 response to the client .
the date header .
the date and cache headers .
the content type of the file .
the channel .
( OutputStream out ) throws IOException { if ( DEBUG ) { Log . v ( " FilePart " , " enter sendDispositionHeader ( OutputStream out ) " ) ; } super . sendDispositionHeader ( out ) ; final String filename = this . source . getFileName ( ) ; if ( filename != null ) { out . write ( FILE_NAME_BYTES ) ; out . write ( QUOTE_BYTES ) ; out . write ( EncodingUtils . getAsciiBytes ( filename ) ) ; } }
data to the server .
the buffers pool .
a new working directory .
the snapshot of the given request .
a new body stream .
the bitmap .
the WebsockifySslContext .
( String keystore , String password ) throws KeyManagementException , IOException , NoSuchAlgorithmException , CertificateException , KeyStoreException { getSSLContext ( keystore , password ) ; }
replaceScaleType ( final ScaleType type ) { blockLayoutRequests = true ; final ScaleType result = getScaleType ( ) ; setScaleType ( type ) ; blockLayoutRequests = false ; return result ; }
location listening .
( final RequestBuilder < ? > requestBuilder , final int flags ) { return PendingIntent . getService ( context , 0 , getIntent ( requestBuilder ) , flags ) ; }
the connection .
the service to the given context .
the application service .
( ) { final T view = this . view ; if ( view != null && view instanceof ImagesLoadListenerProvider ) { this . listener . notifyAboutViewChanges ( ) ; } }
the target connection .
the response data .
the response from the server .
for the loader to be loaded .
( final TextView view , final CharSequence text ) { if ( TextUtils . isEmpty ( text ) ) { view . setVisibility ( hvisibility ) ; } else { view . setText ( text ) ; view . setVisibility ( View . VISIBLE ) ; } }
( View textView ) { try { final InputMethodManager imm = ( InputMethodManager ) textView . getContext ( ) . getSystemService ( Context . INPUT_METHOD_SERVICE ) ; imm . hideSoftInputFromWindow ( textView . getWindowToken ( ) , 0 ) ; } catch ( final Exception e ) { Log . w ( TAG , " Ignore exception " , e ) ; } }
the keyboard .
( final View textView ) { try { final InputMethodManager imm = ( InputMethodManager ) textView . getContext ( ) . getSystemService ( Context . INPUT_METHOD_SERVICE ) ; imm . toggleSoftInputFromWindow ( textView . getWindowToken ( ) , 0 , 0 ) ; } catch ( final Exception e ) { Log . w ( TAG , " Ignore exception " , e ) ; } }
the width of the pixel .
the direct connection timer .
the cache .
an image from the view .
the image loading .
an image consumer .
the result image .
the loading image .
a new task .
the image from the given url .
the buffer .
a request property to the url connection .
< MT > addParam ( final String name ) { addSimpleParameter ( name , value ) ; return this ; }
to the specified URL .
the MD5 hash of the text .
static String stringFor ( int n ) { switch ( n ) { case CUBLAS_GEMM_ALGO0 : return " CUBLAS _ GEMM _ ALGO0" ; case CUBLAS_GEMM_ALGO1 : return " CUBLAS _ GEMM _ ALGO1" ; case CUBLAS_GEMM_ALGO2 : return " CUBLAS _ GEMM _ ALGO2" ; case CUBLAS_GEMM_ALGO3 : return " CUBLAS _ GEMM _ ALGO3" ; case CUBLAS_GEMM_ALGO4 : return " CUBLAS _ GEMM _ ALGO4" ; case CUBLAS_GEMM_ALGO5 : return " CUBLAS _ GEMM _ ALGO5" ; case CUBLAS_GEMM_ALGO6 : return " CUBLAS _ GEMM
the string for the cublas status .
the result of the operation .
if the CUBLAS_STATUS_SUCCESS is returned .
a new lexeme .
a new ending frequency .
the estimate for the wordform .
the long description of the given token .
( AttributeValues avs , StringBuilder tag , int index , char tagValue , String attribute , String attributeValue ) { if ( avs . isMatchingStrong ( attribute , attributeValue ) ) tag . setCharAt ( index , tagValue ) ; else tag . setCharAt ( index , tagValue ) ; }
toKamolsMarkup ( AttributeValues avs , int defaulti ) { StringBuilder res = new StringBuilder ( ) ; res . append ( avs ) ; if ( res . length ( ) < 1 ) return res . toString ( ) ; return res . toString ( ) ; }
( String tag , FeatureStructure avs , int index , char tagValue , String attribute , String attributeValue ) { if ( index >= tag . length ( ) ) return ; if ( tag . charAt ( index ) == tagValue ) avs . addAttribute ( attribute , attributeValue ) ; }
the KamolsMarkupFormating tag .
the metric data from the given application .
the query string .
< MetricData > process ( JsonNode node ) { List < MetricData > list = new LinkedList < > ( ) ; for ( int i = 0 ; i < dataArray . length ( ) ; i ++ ) { JSONObject data = dataArray . getJSONObject ( i ) ; MetricData metricData = new MetricData ( data . getString ( " count " ) , data . getLong ( " value " ) , data . getLong ( " min " ) , data . getLong ( " sum " ) , data . getLong ( " startTimeInMillis " ) ) ; list . add ( metricData ) ; } return list ; }
( String jsonString ) throws IOException { ObjectMapper mapper = new ObjectMapper ( ) ; return mapper . readValue ( jsonString , new TypeReference < List < AppInfo > > ( ) { } ) ; }
getConnectionConfig ( ) { String appdUsername = getPropertyOrEnv ( " com . signalfx . appd . username " , " APPD _ USERNAME " ) ; if ( StringUtils . isEmpty ( appdUsername ) ) { log . error ( " AppDynamics username not specified . " ) ; isValid = false ; } String appdPassword = getPropertyOrEnv ( " com . signalfx . appd . password " , " APPD _ PASSWORD " ) ; if ( StringUtils . isEmpty ( appdPassword ) ) { log . error ( " AppDynamics password not specified . " ) ; isValid = false ; } return new ConnectionConfig ( appdUsername , appdPassword ) ; }
the data points for the given app .
< com . helger . genericode . v04 . CodeListDocument > gc04CodeList ( ) { return new GenericodeReader < > ( EGenericodeDocumentType . GC04_CODE_LIST , com . helger . genericode . v04 . CodeListDocument . class ) ; }
< com . helger . genericode . v04 . CodeListSetDocument > gc04CodeListSet ( ) { return new GenericodeReader < > ( EGenericodeDocumentType . GC04_CODE_LIST_SET , com . helger . genericode . v04 . CodeListSetDocument . class ) ; }
< com . helger . genericode . v04 . ColumnSetDocument > gc04ColumnSet ( ) { return new GenericodeReader < > ( EGenericodeDocumentType . GC04_COLUMN_SET , com . helger . genericode . v04 . ColumnSetDocument . class ) ; }
< com . helger . genericode . v10 . CodeListDocument > gc10CodeList ( ) { return new GenericodeReader < > ( EGenericodeDocumentType . GC10_CODE_LIST , com . helger . genericode . v10 . CodeListDocument . class ) ; }
< com . helger . genericode . v10 . CodeListSetDocument > gc10CodeListSet ( ) { return new GenericodeReader < > ( EGenericodeDocumentType . GC10_CODE_LIST_SET , com . helger . genericode . v10 . CodeListSetDocument . class ) ; }
< com . helger . genericode . v10 . ColumnSetDocument > gc10ColumnSet ( ) { return new GenericodeReader < > ( EGenericodeDocumentType . GC10_COLUMN_SET , com . helger . genericode . v10 . ColumnSetDocument . class ) ; }
the column element ID of the column element .
the row value of the given column .
( @ Nonnull final ColumnSet aColumnSet , @ Nullable final String sID ) { for ( final Column aColumn : getAllColumns ( aColumnSet ) ) if ( aColumn . getId ( ) . equals ( sID ) ) return aColumn ; return null ; }
all key IDs from a column set .
getKeyOfID ( @ Nonnull final ColumnSet aColumnSet , @ Nullable final String sID ) { if ( sID != null ) for ( final Key aKey : getAllKeys ( aColumnSet ) ) if ( aKey . getId ( ) == sID ) return aKey ; return null ; }
static boolean isKeyColumn ( @ Nonnull final ColumnSet aColumnSet , @ Nullable final String sColumnID ) { if ( sColumnID != null ) for ( final Key aKey : getAllKeys ( aColumnSet ) ) if ( aKey . getColumnRef ( ) instanceof Column ) if ( ( ( Column ) aKey . getColumnRef ( ) ) . getId ( ) . equals ( sColumnID ) ) return true ; return false ; }
a column .
a key .
( @ Nonnegative final int nLinesToSkip ) { ValueEnforcer . isGE0 ( nLinesToSkip , " LinesToSkip " ) ; m_nLinesToSkip = nLinesToSkip ; return this ; }
a new ExcelReadColumn < USE_TYPE > .
< com . helger . genericode . v04 . CodeListDocument > gc04CodeList ( ) { return new GenericodeWriter < > ( EGenericodeDocumentType . GC04_CODE_LIST ) ; }
< com . helger . genericode . v04 . CodeListSetDocument > gc04CodeListSet ( ) { return new GenericodeWriter < > ( EGenericodeDocumentType . GC04_CODE_LIST_SET ) ; }
< com . helger . genericode . v04 . ColumnSetDocument > gc04ColumnSet ( ) { return new GenericodeWriter < > ( EGenericodeDocumentType . GC04_COLUMN_SET ) ; }
< com . helger . genericode . v10 . CodeListDocument > gc10CodeList ( ) { return new GenericodeWriter < > ( EGenericodeDocumentType . GC10_CODE_LIST ) ; }
< com . helger . genericode . v10 . CodeListSetDocument > gc10CodeListSet ( ) { return new GenericodeWriter < > ( EGenericodeDocumentType . GC10_CODE_LIST_SET ) ; }
< com . helger . genericode . v10 . ColumnSetDocument > gc10ColumnSet ( ) { return new GenericodeWriter < > ( EGenericodeDocumentType . GC10_COLUMN_SET ) ; }
< com . helger . genericode . v04 . CodeListDocument > gc04CodeList ( ) { return new GenericodeValidator < > ( EGenericodeDocumentType . GC04_CODE_LIST ) ; }
< com . helger . genericode . v04 . CodeListSetDocument > gc04CodeListSet ( ) { return new GenericodeValidator < > ( EGenericodeDocumentType . GC04_CODE_LIST_SET ) ; }
< com . helger . genericode . v04 . ColumnSetDocument > gc04ColumnSet ( ) { return new GenericodeValidator < > ( EGenericodeDocumentType . GC04_COLUMN_SET ) ; }
< com . helger . genericode . v10 . CodeListDocument > gc10CodeList ( ) { return new GenericodeValidator < > ( EGenericodeDocumentType . GC10_CODE_LIST ) ; }
< com . helger . genericode . v10 . CodeListSetDocument > gc10CodeListSet ( ) { return new GenericodeValidator < > ( EGenericodeDocumentType . GC10_CODE_LIST_SET ) ; }
< com . helger . genericode . v10 . ColumnSetDocument > gc10ColumnSet ( ) { return new GenericodeValidator < > ( EGenericodeDocumentType . GC10_COLUMN_SET ) ; }
the logs to the AppFeedBack .
the level of the logger .
the log level .
the current capture .
( final int bytes ) { if ( bytes >= logFileMaxSize ) { logFileMaxSize = bytes ; } if ( null != context ) { SharedPreferences prefs = context . getSharedPreferences ( SHARED_PREF_KEY , Context . MODE_PRIVATE ) ; prefs . edit ( ) . putInt ( SHARED_PREF_KEY_logFileMaxSize , logFileMaxSize ) . commit ( ) ; } }
the message of the given class .
jsonMetadata object .
a JSON object .
the location .
user identity with anonymous user collection enabled .
the byte array from the given file .
location updates .
the size of the region .
the size of the partitioned region .
the size of the region .
a snapshot record .
a list of time stamps .
getTimeValuesSinceIdx ( int idx ) { int resultSize = this . count - idx ; double [ ] result = new double [ resultSize ] ; for ( int i = 0 ; i < resultSize ; i ++ ) { result [ i ] = getMilliTimeStamp ( idx + i ) ; } return result ; }
GfStatsReader to a GfStatsReader .
a pool for the given servername .
a pool for locator .
an existing region on the server .
the member of the given name .
< String > listHosts ( JMX jmx ) { Set < ObjectName > objectNames = jmx . searchObjectNames ( " GemFire : type = Member , member = * " ) ; if ( objectNames == null || objectNames . isEmpty ( ) ) { return null ; } HashSet < String > hostLists = new HashSet < String > ( objectNames . size ( ) ) ; MemberMXBean memberMXBean = null ; for ( ObjectName objectName : objectNames ) { memberMXBean = jmx . newBean ( MemberMXBean . class , objectName ) ; hostLists . add ( memberMXBean . getHost ( ) ) ; } return hostLists ; }
the host name from the bundle .
the error message to the sender .
function with results .
the input into flatten output .
< ReturnType > query ( Query queryObj , RegionFunctionContext rfc , Object ... params ) throws FunctionDomainException , TypeMismatchException , NameResolutionException , QueryInvocationTargetException { SelectResults < ReturnType > selectResults = null ; if ( params == null || params . length == 0 ) { selectResults = ( SelectResults < ReturnType > ) queryObj . execute ( rfc ) ; } else { selectResults = ( SelectResults < ReturnType > ) queryObj . execute ( rfc , params ) ; } if ( selectResults == null || selectResults . isEmpty ( ) ) return null ; return selectResults ; }
< K , V > forAfterPut ( Consumer < EntryEvent < K , V > > consumer ) { return new CacheListenerBridge < K , V > ( consumer , null ) ; }
< K , V > forAfterDelete ( Consumer < EntryEvent < K , V > > consumer ) { return new CacheListenerBridge < K , V > ( null , consumer ) ; }
the data error from the request .
the list of onRegionFilterKeyFacts .
the function .
< String > listHosts ( JMX jmx ) { Set < ObjectName > memberObjects = jmx . searchObjectNames ( " GemFire : type = Member , member = * " ) ; if ( memberObjects == null || memberObjects . isEmpty ( ) ) { return null ; } HashSet < String > hostList = new HashSet < String > ( memberObjects . size ( ) ) ; MemberMXBean bean = null ; for ( ObjectName objectName : memberObjects ) { bean = jmx . newBean ( MemberMXBean . class , objectName ) ; try { hostList . add ( bean . getHost ( ) ) ; } catch ( UndeclaredThrowableException e ) { } } return hostList ; }
a function on a region .
the app name of the given resource .
the security client auth .
< K , V > getRegion ( String regionName ) { if ( regionName == null || regionName . length ( ) == 0 ) return null ; Region < K , V > region = ( Region < K , V > ) clientCache . getRegion ( regionName ) ; return region ; }
< K , V > getRegion ( ClientCache clientCache , String regionName ) { if ( regionName == null || regionName . length ( ) == 0 ) return null ; region = ( Region < K , V > ) clientCache . createClientRegionFactory ( ClientRegionShortcut . PROXY ) . create ( regionName ) ; return region ; }
a comparison of the sourceChecksumMap and the targetChecksumMap .
the value time stamps into the table .
the stream .
a list of stats files to a csv file .
a GfStatsReader from an archive file .
the cache .
all members on the given host .
down member .
the DistributedSystemMXBean .
down redundancy zone .
a paginated map .
results by page .
a region .
if remoteLocators and locators match .
the checkSumMap function .
buildCheckSumMap ( Region < Serializable , Object > region ) { if ( region == null ) { return null ; } if ( region . getAttributes ( ) . getDataPolicy ( ) . withPartitioning ( ) ) { region = PartitionRegionHelper . getLocalData ( region ) ; } Set < Serializable > keySet = region . keySet ( ) ; if ( keySet == null || keySet . isEmpty ( ) ) return null ; HashMap < Serializable , BigInteger > regionCheckSumMap = new HashMap < Serializable , BigInteger > ( keySet . size ( ) ) ; for ( Map . Entry < Serializable , Object > entry : region . entrySet ( ) ) { if ( entry . getKey ( ) . equals ( entry . getValue ( ) . getClass ( ) ) ) { continue ; } if ( entry . getKey ( ) . equals ( entry . getValue ( ) . getClass ( ) ) ) { continue ; } if ( entry . getKey ( ) . equals ( entry . getKey ( ) )
the value of the specified column .
the type of the given type .
the object to a byte array .
a byte array .
a new instance of the given class .
the table id for the given element .
the type of the column element .
the super type of the element .
a schema for the given table .
( Writer writer ) throws IOException { logger . d ( " brewJava " ) ; JavaWriter javaWriter = new JavaWriter ( writer ) ; javaWriter . setCompressingTypes ( false ) ; return javaWriter ; }
function .
an Observable < T > .
the column name of the table .
valueOrDefault ( String string , String defaultString ) { return isBlank ( string ) ? defaultString : string ; }
( String string ) { if ( string == null ) { return null ; } if ( string . length ( ) == 0 ) { return string ; } if ( string . length ( ) == 1 ) { return string ; } if ( string . length ( ) == 2 ) { return string . substring ( 0 , 1 ) ; } if ( string . length ( ) == 3 ) { return string . substring ( 0 , 1 ) ; } if ( string . length ( ) == 2 ) { return string . substring ( 0 , 1 ) ; } if ( string . length ( ) == 3 ) { return string . substring ( 0 , 1 ) ; } return string ; }
the type of the given type .
whether the query is descending or ascending .
the temperature from the device .
the current cursor method .
a message to the console .
the error message .
a list of icons .
< IconCode > getIcons ( ) { List < IconCode > list = new ArrayList < IconCode > ( ) ; for ( IconCode icon : GoogleMaterialDesignIcons . values ( ) ) { list . add ( icon ) ; } }
a Sld editor layout .
the background decororation of the HTMLFlow .
raise ( final double px , final int pexponent ) { double x = px ; int exponent = pexponent ; if ( exponent < 0 ) return 1 / raise ( x , - exponent ) ; double power = 1 ; while ( exponent > 0 ) { if ( ( exponent & 1 ) == 1 ) power *= x ; x *= x ; exponent >>= 1 ; } return power ; }
the values to a float array .
static BigDecimal intPower ( @ Nonnull final BigDecimal px , final long pexponent , final int scale ) { BigDecimal x = px . setScale ( scale , RoundingMode . HALF_EVEN ) ; x = x . setScale ( scale , RoundingMode . HALF_EVEN ) ; x = x . setScale ( scale , RoundingMode . HALF_EVEN ) ; x = x . setScale ( scale , RoundingMode . HALF_EVEN ) ; return x ; }
a BigDecimal to an int .
the factorial of the x power .
( @ Nonnull final BigDecimal x , final int scale ) { if ( x . signum ( ) <= 0 ) { throw new IllegalArgumentException ( " x < = 0 : " + x ) ; } final int magnitude = x . toString ( ) . length ( ) - x . scale ( ) - 1 ; if ( magnitude < 3 ) { return _lnNewton ( x , scale ) . setScale ( scale , RoundingMode . HALF_EVEN ) ; } if ( magnitude < 3 ) { return _lnNewton ( x , scale ) . setScale ( scale , RoundingMode . HALF_EVEN ) ; } return _lnNewton ( x , scale ) . setScale ( scale , RoundingMode . HALF_EVEN ) . setScale ( scale , RoundingMode . HALF_EVEN ) ; }
a newton .
( @ Nonnull final BigDecimal x , final int scale ) { if ( x . abs ( ) . compareTo ( BigDecimal . ONE ) >= 0 ) { throw new IllegalArgumentException ( " | x | > = 1 : " + x ) ; } if ( x . signum ( ) == - 1 ) { return arctan ( x . negate ( ) , scale ) . negate ( ) ; } return _arctanTaylor ( x , scale ) ; }
( final BigDecimal x ) { if ( x . compareTo ( BigDecimal . ZERO ) < 0 ) { return x ; } if ( x . compareTo ( BigDecimal . ZERO ) > 0 ) { return x ; } if ( x . compareTo ( BigDecimal . ZERO ) < 0 ) { return x ; } if ( x . compareTo ( BigDecimal . ZERO ) < 0 ) { return x ; } if ( x . compareTo ( BigDecimal . ZERO ) > 0 ) { return x ; } if ( x . compareTo ( BigDecimal . ZERO ) < 0 ) { return x ; } if ( x . compareTo ( BigDecimal . ZERO ) > 0 ) { return x ; } if ( x . compareTo ( BigDecimal . ZERO ) < 0 ) { return x ; } if ( x . compareTo ( BigDecimal . ZERO ) > 0 ) { return x ; } if ( x . compareTo ( BigDecimal . ZERO ) < 0 ) { return x ; } if ( x . compareTo (
( @ Nonnull final BigDecimal x ) { if ( x . signum ( ) < 0 ) { throw new IllegalArgumentException ( " x < 0 : " + x ) ; } if ( x . signum ( ) > 0 ) { throw new IllegalArgumentException ( " x > 0 : " + x ) ; } return new BigDecimal ( x , scale ) ; }
the pi string .
the timestamp of the current time .
( final float rMin , final float rMax ) { this . m_fMin = rMin ; this . m_fMax = rMax ; }
a float r into a matrix .
all counters to the console .
( final Complex z ) { return new Complex ( m_fReal + z . real ( ) , m_fImaginary + z . imaginary ( ) ) ; }
( final Complex z ) { return new Complex ( m_fReal - z . real ( ) , m_fImaginary - z . imag ( ) ) ; }
multiply ( final Complex z ) { return new Complex ( m_fReal * z . real ( ) - m_fImaginary * z . imaginary ( ) , m_fReal * z . imaginary ( ) + m_fImaginary * z . real ( ) ) ; }
a Complex by its real and imaginary values .
a matrix .
a row vector .
a column from a matrix .
a float array .
transpose ( ) { return transpose ( ) ; }
a matrix to the given matrix .
a matrix .
a matrix by k .
a matrix .
the value of the column .
a new image into the DOM .
Coefficients .
( ) { m_fPrevXn = m_fXn ; m_fXn = m_fGn ; m_fGn = m_aFunction . at ( m_fXn ) ; }
the raw Sld .
a StyledLayerDescriptorInfo to a RawSld .
a StyledLayerDescriptorInfo to a StyledLayerDescriptorInfo .
a StyledLayerDescriptorInfo .
a raw Sld .
the area of the given x1 and y1 .
a matrix .
the values to a float array .
inverse ( ) throws MatrixException { final InvertibleMatrix inverse = new InvertibleMatrix ( m_nRows ) ; final IdentityMatrix identity = new IdentityMatrix ( m_nRows ) ; for ( int c = 0 ; c < m_nCols ; ++ c ) { final ColumnVector col = solve ( identity . getColumn ( c ) , true ) ; inverse . setColumn ( col , c ) ; } return inverse ; }
the determinant of a matrix .
the norm of the matrix .
a column vector .
the decomposed matrix .
( final float scales [ ] ) throws MatrixException { for ( int rPivot = 0 ; rPivot < m_nRows - 1 ; ++ rPivot ) { float largestScaledElmt = 0 ; int rLargest = 0 ; for ( int r = rPivot ; r < m_nRows ; ++ r ) { final int pr = m_aPermutation [ r ] ; final float absElmt = Math . abs ( m_aLU . at ( pr , rPivot ) ) ; final float scaledElmt = absElmt * scales [ pr ] ; if ( largestScaledElmt < scaledElmt ) { largestScaledElmt = scaledElmt ; rLargest = r ; } } if ( largestScaledElmt == 0 ) { throw new MatrixException ( MatrixException . SINGULAR ) ; } if ( rLargest != rPivot ) { final int rPivot =
substitution of a column vector to a column vector .
a new ColumnVector .
the residuals of a column .
a square matrix to a matrix .
( ) { for ( ; ; ) { if ( ( n & 1 ) == 0 ) { return GENERATOR . nextFloat ( ) ; } else if ( ( n & 2 ) == 0 ) { return GENERATOR . nextFloat ( ) ; } else if ( ( n & 3 ) == 0 ) { return GENERATOR . nextFloat ( ) ; } else if ( ( n & 4 ) == 0 ) { return GENERATOR . nextFloat ( ) ; } else if ( ( n & 5 ) == 0 ) { return GENERATOR . nextFloat ( ) ; } else if ( ( n & 6 ) == 0 ) { return GENERATOR . nextFloat ( ) ; } else if ( ( n & 7 ) == 0 ) { return GENERATOR . nextFloat ( ) ; } else { return GENERATOR . nextFloat ( ) ; } } }
the fXNeg and fPos values .
( ) { m_fPrevXFalse = m_fXFalse ; m_fXFalse = m_fXPos - m_fPos * ( m_fXNeg - m_fXPos ) / ( m_fNeg - m_fPos ) ; }
( ) throws AbstractRootFinder . PositionUnchangedException { if ( EqualsHelper . equals ( m_fXFalse , m_fPrevXFalse ) ) { throw new AbstractRootFinder . PositionUnchangedException ( ) ; } }
the next position .
the interval .
a new addend .
multipliers a and b .
the given exponent .
over the number of elements in the matrix .
a new SldManager instance .
a long to a char array .
the bits .
a double value to a PW .
the biased exponent .
( final int unbiased ) throws IEEE754Exception { if ( unbiased < - IEEE754Constants . FLOAT_EXPONENT_BIAS + 1 ) || ( unbiased > IEEE754Constants . FLOAT_EXPONENT_BIAS ) { throw new IEEE754Exception ( " The unbiased exponent value should be " + - ( IEEE754Constants . FLOAT_EXPONENT_BIAS - 1 ) + " through " + IEEE754Constants . FLOAT_EXPONENT_BIAS + " . " ) ; } }
the biased exponent .
a double unbiased exponent .
a SldGwtServiceAsync .
the mean of the central point .
the next polar .
the ratio of the given x and y .
static boolean [ ] primeSieve ( final int n ) { final int halfN = ( n + 1 ) >> 1 ; final boolean sieve [ ] = new boolean [ n + 1 ] ; for ( int i = 2 ; i <= n ; ++ i ) sieve [ i ] = true ; int prime = 2 ; while ( prime < halfN ) { for ( int composite = prime << 1 ; composite <= n ; composite += prime ) sieve [ composite ] = false ; } while ( prime < halfN ) { for ( int composite = prime << 1 ; composite <= n ; composite += prime ) sieve [ composite ] = false ; while ( ( ++ prime < halfN ) && ( ! sieve [ prime ] ) ) { } } return sieve ; }
the factors of the given pn .
the fX and fPos of the fMid .
( ) { m_fPrevXMid = m_fXMid ; m_fXMid = m_aFunction . at ( m_fXMid ) ; }
( ) throws AbstractRootFinder . PositionUnchangedException { if ( EqualsHelper . equals ( m_fXMid , m_fPrevXMid ) ) { throw new AbstractRootFinder . PositionUnchangedException ( ) ; } }
the JavaFxApplication to the specified JavaFxApplication .
the configuration .
the default configuration .
the fxml loader .
latlng ( Double lat , Double lng ) { parameters . put ( " latlng " , lat + " , " + lng ) ; return this ; }
the host port pair from the service instance .
the applicable attribute for the given attributeDefinition .
the attribute filter .
a String to a String .
address ( String address ) { parameters . put ( " address " , address != null ? address . replace ( ' ' , ' + ' ) : address ) ; return this ; }
the components of the given component .
< String > queryForNames ( ) throws Exception { Set < String > names = new HashSet < String > ( ) ; Iterator < Service > services = client . getServicesClient ( ) . list ( new MethodOptions ( 100 , null ) ) ; while ( services . hasNext ( ) ) { Service service = services . next ( ) ; if ( ! service . getTags ( ) . contains ( typeTag ) ) { names . add ( service . getName ( ) ) ; } } return names ; }
< ServiceInstance < T > > queryForInstances ( String typeTag ) throws Exception { List < ServiceInstance < T > > serviceInstances = new ArrayList < ServiceInstance < T > > ( ) ; Iterator < Service > services = client . getServicesClient ( ) . list ( new MethodOptions ( 100 , null ) ) ; while ( services . hasNext ( ) ) { Service service = services . next ( ) ; if ( service . getTags ( ) . contains ( typeTag ) && service . getMetadata ( ) . get ( ServiceTracker . NAME ) . equals ( name ) ) { serviceInstances . add ( convert ( service ) ) ; } } return serviceInstances ; }
< Collaboration > getAllToByLoggedIn ( ) { CollaborationListing collaborationListing = new CollaborationListing ( ) ; if ( this . serviceTicket != null ) { collaborationListing . setServiceTicket ( this . serviceTicket ) ; } return new CollaborationListing ( ) ; }
getMetaDataForDecimalAs ( String metaDataPrefixParam , double minParam , double maxParam , double stepFactorParam ) { StringBuffer returnBuffer = new StringBuffer ( ) ; if ( metaDataPrefixParam != null && ! metaDataPrefixParam . isEmpty ( ) ) { returnBuffer . append ( metaDataPrefixParam ) ; returnBuffer . append ( FieldMetaData . Decimal . UNDERSCORE ) ; returnBuffer . append ( FieldMetaData . Decimal . MIN ) ; returnBuffer . append ( FieldMetaData . Decimal . SQ_OPEN ) ; returnBuffer . append ( minParam ) ; returnBuffer . append ( FieldMetaData . Decimal . SQ_CLOSE ) ; returnBuffer . append ( FieldMetaData . Decimal . UNDERSCORE ) ; returnBuffer . append ( FieldMetaData . Decimal . MAX ) ; returnBuffer . append ( FieldMetaData . Decimal . SQ_OPEN ) ; returnBuffer . append ( maxParam ) ; returnBuffer . append ( FieldMetaData . Decimal . SQ_CLOSE ) ; return
password for logged in user .
all users from the given serviceTicket .
the gravatar for the given email .
the gravatar for the given user .
( JSONObject jsonObjectParam , List < Field > formFieldsParam ) throws JSONException { throw new FluidElasticSearchException ( " Method not implemented . Make use of ' populateFromElasticSearchJson ( JSONObject jsonObjectParam ) ' method . " ) ; }
the ElasticSearch type .
a flow step .
the flow step .
a FlowStep from the given flowStepId .
the flow step by the given serviceTicket .
( Flow flowParam ) { if ( this . serviceTicket != null && flowParam != null ) { flowParam . setServiceTicket ( this . serviceTicket ) ; } return new FlowStepListing ( this . postJson ( flowParam , WS . Path . FlowStep . Version1 . getAllStepsByFlow ( ) ) ) ; }
the flow step .
the flow step .
all table records .
ABaseES Connection .
the error message from the given object .
a FluidClientException .
a list of messages from the returnValue .
< FluidItem > getPersonalInventoryItems ( ) { User loggedInUser = new User ( ) ; if ( this . serviceTicket != null ) { loggedInUser . setServiceTicket ( this . serviceTicket ) ; } try { return new FluidItemListing ( this . postJson ( loggedInUser , WS . Path . PersonalInventory . getAllByLoggedInUser ( ) ) ) . getListing ( ) ; } catch ( JSONException jsonExcept ) { throw new FluidClientException ( jsonExcept . getMessage ( ) , FluidClientException . ErrorCode . JSON_PARSING ) ; } }
a new table record .
the form container .
< FormFlowHistoricData > getFormFlowHistoricData ( ) { if ( formParam != null && this . serviceTicket != null ) { formParam . setServiceTicket ( this . serviceTicket ) ; } return new FormFlowHistoricDataListing ( this . postJson ( formParam , WS . Path . FlowItemHistory . getByFormContainer ( ) ) ) . getListing ( ) ; }
< FormHistoricData > getFormHistoricData ( Form formParam , boolean includeCurrentParam ) { if ( formParam != null && this . serviceTicket != null ) { formParam . setServiceTicket ( this . serviceTicket ) ; } return new FormHistoricDataListing ( this . postJson ( formParam , WS . Path . FormHistory . Version1 . getByFormContainer ( includeCurrentParam ) ) ) . getListing ( ) ; }
( Form formParam ) { if ( formParam != null && this . serviceTicket != null ) { formParam . setServiceTicket ( this . serviceTicket ) ; } return new FormHistoricData ( this . postJson ( formParam , WS . Path . FormHistory . Version1 . get ( ) ) ) ; }
( Form formParam , JobView jobViewParam ) { return lockFormContainer ( formParam , jobViewParam , null ) ; }
( Form formParam , boolean unlockAsyncParam ) { if ( unlockAsyncParam ) { this . unlockFormContainer ( formParam ) ; } else { this . unlockFormContainer ( formParam ) ; } }
the form container .
a new form to the database .
a string to a list of roles .
a form definition .
the form definition .
a new FormDefinition from the given formDefinitionId .
a new FormDefinition from the given formDefinitionName .
< Form > getAllByLoggedInUser ( boolean includeTableRecordTypesParam ) { Form form = new Form ( ) ; if ( this . serviceTicket != null ) { form . setServiceTicket ( this . serviceTicket ) ; } if ( includeTableRecordTypesParam ) { return new FormListing ( this . postJson ( form , WS . Path . FormDefinition . Version1 . getAllByLoggedInUserIncludeTableTypes ( ) ) ) . getListing ( ) ; } else { return new FormListing ( this . postJson ( form , WS . Path . FormDefinition . Version1 . getAllByLoggedInUser ( ) ) ) . getListing ( ) ; } }
the form definition .
the storage key from the formDefIdParam .
a Memcached client .
the MemCache client .
a string to a long .
the input document to PDF .
( Long formIdParam , List < FormFieldListing > listingReturnFieldValsPopulatedParam , Form [ ] formsToFetchForLocalCacheArrParam ) { if ( formIdParam == null || formIdParam . longValue ( ) < 1 ) { return null ; } if ( listingReturnFieldValsPopulatedParam == null || listingReturnFieldValsPopulatedParam . isEmpty ( ) ) { return null ; } if ( formsToFetchForLocalCacheArrParam == null || formsToFetchForLocalCacheArrParam . length == 0 ) { return null ; } for ( Form formIter : formsToFetchForLocalCacheArrParam ) { if ( formIdParam . equals ( formIter . getId ( ) ) ) { String echoToUse = formIter . getEcho ( ) ; for ( FormFieldListing fieldListing : listingReturnFieldValsPopulatedParam ) { if ( echoToUse . equals ( fieldListing . getEcho ( )
a flow step entry rule .
a flow step rule .
a flow step rule .
flowStepEntryRule ( FlowStepRule flowStepRuleParam ) { if ( this . serviceTicket != null ) { flowStepRuleParam . setServiceTicket ( this . serviceTicket ) ; } return new FlowStepRule ( this . postJson ( flowStepRuleParam , WS . Path . FlowStepRule . Version1 . flowStepRuleUpdateEntry ( ) ) ) ; }
FlowStepExitRule ( FlowStepRule flowStepRuleParam ) { this . flowStepRuleParam = flowStepRuleParam ; }
flowStepViewRule ( FlowStepRule flowStepRuleParam ) { if ( flowStepRuleParam != null && this . serviceTicket != null ) { flowStepRuleParam . setServiceTicket ( this . serviceTicket ) ; } return new FlowStepRule ( flowStepRuleParam ) ; }
( FlowStepRule flowStepRuleParam ) { if ( flowStepRuleParam != null && this . serviceTicket != null ) { flowStepRuleParam . setServiceTicket ( this . serviceTicket ) ; } return new FlowStepRule ( this . postJson ( flowStepRuleParam , WS . Path . FlowStepRule . Version1 . flowStepRuleMoveEntryUp ( ) ) ) ; }
flowStepEntryRuleDown ( FlowStepRule flowStepRuleParam ) { if ( flowStepRuleParam != null && this . serviceTicket != null ) { flowStepRuleParam . setServiceTicket ( this . serviceTicket ) ; } return new FlowStepRule ( this . postJson ( flowStepRuleParam , WS . Path . FlowStepRule . Version1 . flowStepRuleMoveEntryDown ( ) ) ) ; }
FlowStepEntryRule ( FlowStepRule flowStepRuleParam ) { this . flowStepRuleParam = flowStepRuleParam ; }
( FlowStepRule flowStepRuleParam ) { if ( flowStepRuleParam != null && this . serviceTicket != null ) { flowStepRuleParam . setServiceTicket ( this . serviceTicket ) ; } }
( FlowStepRule flowStepRuleParam ) { this . flowStepRuleParam = flowStepRuleParam ; }
the auth encrypted data .
all user queries .
all roles for a given serviceTicket .
the service ticket from the given serviceTicket .
a new form field .
a field text barcode .
a decimal spinner for a form field .
a FieldDecimalSlider .
a form field table .
field text masked value .
the field text barcode .
fieldDecimalSpinner ( Field formFieldParam , double minParam , double maxParam , double stepFactorParam , String prefixParam ) { if ( formFieldParam != null && this . serviceTicket != null ) { formFieldParam . setServiceTicket ( this . serviceTicket ) ; } if ( formFieldParam != null ) { formFieldParam . setTypeAsEnum ( Field . Type . Decimal ) ; formFieldParam . setTypeMetaData ( this . getMetaDataForDecimalAs ( FieldMetaData . Decimal . SPINNER , minParam , maxParam , stepFactorParam , prefixParam ) ) ; } }
fieldDecimalSlider ( Field formFieldParam , double minParam , double maxParam , double stepFactorParam ) { if ( formFieldParam != null && this . serviceTicket != null ) { formFieldParam . setServiceTicket ( this . serviceTicket ) ; } if ( formFieldParam != null ) { formFieldParam . setTypeAsEnum ( Field . Type . Decimal ) ; formFieldParam . setTypeMetaData ( this . getMetaDataForDecimalAs ( FieldMetaData . Decimal . SLIDER , minParam , maxParam , stepFactorParam , null ) ) ; } return new Field ( this . postJson ( formFieldParam , WS . Path . FormField . Version1 . formFieldUpdate ( ) ) ) ; }
the form field table .
the field by the given name .
fields by form name and logged in user .
( Long formTypeIdParam ) { Form form = new Form ( ) ; form . setFormTypeId ( formTypeIdParam ) ; if ( this . serviceTicket != null ) { form . setServiceTicket ( this . serviceTicket ) ; } return form ; }
the field .
the field .
getMetaDataForTableField ( Form formDefinitionParam ) { StringBuilder returnBuffer = new StringBuilder ( ) ; returnBuffer . append ( FieldMetaData . TableField . UNDERSCORE ) ; returnBuffer . append ( FieldMetaData . TableField . SUM_DECIMALS ) ; returnBuffer . append ( FieldMetaData . Decimal . SQ_OPEN ) ; returnBuffer . append ( sumDecimalsParam ) ; returnBuffer . append ( FieldMetaData . Decimal . SQ_CLOSE ) ; returnBuffer . append ( FieldMetaData . TableField . UNDERSCORE ) ; returnBuffer . append ( FieldMetaData . TableField . SUM_DECIMALS ) ; returnBuffer . append ( FieldMetaData . Decimal . SQ_OPEN ) ; returnBuffer . append ( sumDecimalsParam ) ; returnBuffer . append ( FieldMetaData . Decimal . SQ_CLOSE ) ; return returnBuffer . toString ( ) ; }
the userFieldValue .
a new index .
a flow .
the flow .
the flow from the given flowId .
the flow from the given name .
the flow .
the flow .
the global field value .
< Field > getAllGlobalFieldValues ( ) { Field field = new Field ( ) ; field . setFieldValue ( new MultiChoice ( ) ) ; if ( this . serviceTicket != null ) { field . setServiceTicket ( this . serviceTicket ) ; } return new GlobalFieldListing ( ) ; }
getFormDefinitionIdAndTitle ( ) { return getFormDefinitionIdAndTitle ; }
the encrypted data .
ABaseClientWebSocket Connection .
a new request .
all return data for a given uniqueReqId .
a new admin user .
the user token .
the user profile info .
a JSON body .
a POST request .
the JSON response from the given URL .
if the connection is valid .
self signed trust material .
the trust store for the fluid system .
the connection .
< FluidItemListing > getFluidItemsForView ( JobView jobViewParam , int queryLimitParam , int offsetParam , String sortFieldParam , String sortOrderParam ) { if ( this . serviceTicket != null && jobViewParam != null ) { jobViewParam . setServiceTicket ( this . serviceTicket ) ; } try { return new FluidItemListing ( this . postJson ( jobViewParam , WS . Path . FlowItem . Version1 . getByJobView ( queryLimitParam , offsetParam , sortFieldParam , sortOrderParam ) ) ) ; } catch ( JSONException jsonExcept ) { throw new FluidClientException ( jsonExcept . getMessage ( ) , FluidClientException . ErrorCode . JSON_PARSING ) ; } }
the form to the flow .
the user session .
the handler for the given message .
a message to the Fluid client .
a message to the remote server .
the session .
( NativeSQLQueryParam nativeSQLQueryParam ) { if ( nativeSQLQueryParam == null ) { return null ; } if ( nativeSQLQueryParam . getDatasourceName ( ) == null || nativeSQLQueryParam . getDatasourceName ( ) . isEmpty ( ) ) { throw new FluidClientException ( " No data - source name provided . Not allowed . " , FluidClientException . ErrorCode . FIELD_VALIDATE ) ; } if ( ( nativeSQLQueryParam . getQuery ( ) == null || nativeSQLQueryParam . getQuery ( ) . isEmpty ( ) ) && ( nativeSQLQueryParam . getStoredProcedure ( ) == null || nativeSQLQueryParam . getStoredProcedure ( ) . isEmpty ( ) ) ) { return null ; } this . setEchoIfNotSet ( nativeSQLQueryParam ) ; String uniqueReqId = this . initNewRequest ( ) ; this . sendMessage ( nativeSQLQueryParam , uniqueReqId ) ; }
the license request .
the license .
a new field .
a paragraph text .
a paragraph text HTML document .
a multi choice selectMany route field .
a fieldDateTimeDate .
field textPlain ( Field routeFieldParam ) { if ( routeFieldParam != null && this . serviceTicket != null ) { routeFieldParam . setServiceTicket ( this . serviceTicket ) ; } if ( routeFieldParam != null ) { routeFieldParam . setTypeMetaData ( FieldMetaData . Text . PLAIN ) ; } return new Field ( routeFieldParam ) ; }
the paragraph text HTML .
FieldDateTimeDateAndTime ( Field routeFieldParam ) { if ( routeFieldParam != null && this . serviceTicket != null ) { routeFieldParam . setServiceTicket ( this . serviceTicket ) ; } if ( routeFieldParam != null ) { routeFieldParam . setTypeAsEnum ( Field . Type . DateTime ) ; routeFieldParam . setTypeMetaData ( FieldMetaData . DateTime . DATE_AND_TIME ) ; } return new Field ( routeFieldParam ) ; }
fieldDecimalPlain ( Field routeFieldParam ) { if ( routeFieldParam != null && this . serviceTicket != null ) { routeFieldParam . setServiceTicket ( this . serviceTicket ) ; } if ( routeFieldParam != null ) { routeFieldParam . setTypeMetaData ( FieldMetaData . Decimal . PLAIN ) ; } return new Field ( this . postJson ( routeFieldParam , Version1 . routeFieldUpdate ( ) ) ) ; }
the routeFieldValueParam .
a route field .
the configuration .
all configurations .
a new attachment .
( Long attachmentIdParam ) { Attachment attachment = new Attachment ( attachmentIdParam ) ; if ( this . serviceTicket != null ) { attachment . setServiceTicket ( this . serviceTicket ) ; } return new Attachment ( this . postJson ( attachment , WS . Path . Attachment . Version1 . getById ( attachmentIdParam ) ) ) ; }
the attachment .
the attachment .
the XSD file .
the classloader of the jar file .
rule2 ( ) { if ( ! ( parent instanceof XsdSchema ) && name != null ) { throw new ParsingException ( XSD_TAG + " element : The " + NAME_TAG + " should only be used when the parent of the " + XSD_TAG + " is the " + XsdSchema . XSD_TAG + " element . " ) ; } }
rule3 ( ) { if ( parent instanceof XsdSchema && name == null ) { throw new ParsingException ( XSD_TAG + " element : The " + NAME_TAG + " should is required the parent of the " + XSD_TAG + " is the " + XsdSchema . XSD_TAG + " element . " ) ; } }
( ) { if ( attributesMap . containsKey ( REF_TAG ) && ( simpleType != null || form != null || type != null ) ) { throw new ParsingException ( XSD_TAG + " element : If " + REF_TAG + " attribute is present , simpleType element , form attribute and type attribute cannot be present at the same time . " ) ; } }
the schema node from the given file .
rule7 ( ) { if ( parent instanceof XsdSchema && attributesMap . containsKey ( FORM_TAG ) ) { throw new ParsingException ( XSD_TAG + " element : The " + FORM_TAG + " attribute can only be present when the parent of the " + xsdElementIsXsdSchema ) ; } else if ( parent instanceof XsdSchema && attributesMap . containsKey ( FORM_TAG ) ) { throw new ParsingException ( XSD_TAG + " element : The " + FORM_TAG + " attribute can only be present when the parent of the " + xsdElementIsXsdSchema ) ; } }
rule3 ( ) { if ( parent instanceof XsdSchema && attributesMap . containsKey ( REF_TAG ) ) { throw new ParsingException ( XSD_TAG + " element : The " + REF_TAG + " attribute cannot be present when the parent of the " + xsdElementIsXsdSchema ) ; } else if ( parent instanceof XsdSchema && attributesMap . containsKey ( REF_TAG ) ) { throw new ParsingException ( XSD_TAG + " element : The " + REF_TAG + " attribute cannot be present when the parent of the " + xsdElementIsXsdSchema ) ; } else if ( parent instanceof XsdSchema && attributesMap . containsKey ( REF_TAG ) ) { throw new ParsingException ( XSD_TAG + " element : The " + REF_TAG + " attribute cannot be present when the parent of the " + xsdElementIsXsdSchema ) ; } }
a value to a given type .
< O > createCli ( final Class < O > klass ) throws InvalidOptionSpecificationException { return new CliInterface < O > ( klass ) ; }
< O > createCliUsingInstance ( final O options ) throws InvalidOptionSpecificationException { return new CliInstanceImpl < O > ( options ) ; }
arguments .
( final O options , final String ... arguments ) throws ArgumentValidationException , InvalidOptionSpecificationException { return createCliUsingInstance ( options ) . parseArguments ( arguments ) ; }
a url builder for the given path .
the footer view from the grid .
the value of the given p .
the gradient noise3D .
the number of noise in the given seed .
valueNoise3D ( int x , int y , int z , int seed ) { return intValueNoise3D ( x , y , z , seed ) / 2147483647.0 ; }
( double n0 , double n1 , double n2 , double n3 , double a ) { double p = ( n3 - n2 ) - ( n0 - n1 ) ; double q = ( n0 - n1 ) - p ; double r = n2 - n0 ; return p * a * a + q * a * a + r * a + n1 ; }
a curve .
( double currentLower , double currentUpper , double newLower , double newUpper ) { if ( currentLower == currentUpper ) { throw new IllegalArgumentException ( " currentLower must not equal currentUpper . Both are " + currentUpper ) ; } if ( newLower == newUpper ) { throw new IllegalArgumentException ( " newLowerBound must not equal newUpperBound . Both are " + newUpper ) ; } if ( newLower == newUpper ) { throw new IllegalArgumentException ( " newLowerBound must not equal newUpperBound . Both are " + newLower ) ; } currentLowerBound = currentLower ; currentUpperBound = currentUpper ; newLowerBound = newLower ; newUpperBound = newUpper ; recalculateScaleBias ( ) ; }
a CloudTrail event .
the CloudTrail event .
the account id of the event .
< ViolationEntity , Boolean > apply ( final ViolationEntity violationEntity ) { final List < Predicate < ViolationEntity > > predicates = newArrayList ( ) ; trimOptional ( ruleEntity . getAccountId ( ) ) . map ( WhitelistRulesEvaluator :: accountIsEqual ) . ifPresent ( predicates :: add ) ; trimOptional ( ruleEntity . getRegion ( ) ) . map ( WhitelistRulesEvaluator :: regionIsEqual ) . ifPresent ( predicates :: add ) ; trimOptional ( ruleEntity . getViolationTypeId ( ) ) . map ( WhitelistRulesEvaluator :: violationTypeIdIsEqual ) . ifPresent ( predicates :: add ) ; trimOptional ( ruleEntity . getImageName ( ) ) . map ( WhitelistRulesEvaluator :: imageNameMatches ) . ifPresent ( predicates :: add ) ; trimOptional ( ruleEntity . getImageOwner ( ) ) . map ( WhitelistRulesEvaluator :: imageOwnerIsEqual ) . ifPresent ( predicates :: add )
the event serializer .
a new file .
a new directory .
restore properties .
< K , V > createImplementation ( ) { if ( delegate instanceof HashMap == false ) return new HashMap < K , V > ( delegate ) ; return delegate ; }
a SoftObject to the collection .
the value of the property .
the array of the given string .
the state of the given action .
( ) { ComparableSoftReference cr ; while ( ( cr = ( ComparableSoftReference ) gcqueue . poll ( ) ) != null ) { map . remove ( cr . getKey ( ) ) ; } }
the type of the given type .
a parameterized type .
( TypeVariable < D > type ) { return get ( type . getBounds ( ) [ 0 ] ) ; }
the nested throwable .
the nested throwable .
a RemoteObject with a RemoteObject .
a task .
the wait type of the task .
if the task is accepted .
the task .
the task .
the completed task .
the task .
the job of the current job .
a job item to the current job .
toBlockingMode ( String name ) { BlockingMode mode = null ; if ( name . equalsIgnoreCase ( " run " ) ) { mode = RUN ; } else if ( name . equalsIgnoreCase ( " wait " ) ) { mode = WAIT ; } else if ( name . equalsIgnoreCase ( " discard " ) ) { mode = DISCARD ; } else if ( name . equalsIgnoreCase ( " discardOldest " ) ) { mode = DISCARD_OLDEST ; } else if ( name . equalsIgnoreCase ( " abort " ) ) { mode = ABORT ; } return mode ; }
a blocking mode .
a new SAXCatalogReader .
a new reader .
Readers to a new Catalog .
a new catalog .
system catalogs .
catalog .
( ) throws MalformedURLException { if ( catalogFiles . isEmpty ( ) && ! localDelegate . isEmpty ( ) ) { Vector newQueue = new Vector ( ) ; Enumeration e = localDelegate . elements ( ) ; while ( e . hasMoreElements ( ) ) { newQueue . addElement ( q . nextElement ( ) ) ; } for ( int curCat = 0 ; curCat < catalogFiles . size ( ) ; curCat ++ ) { String catfile = ( String ) catalogFiles . elementAt ( curCat ) ; newQueue . addElement ( catfile ) ; } catalogFiles = newQueue ; localDelegate . clear ( ) ; } }
catalog file .
the keywords from the catalog .
( ) throws MalformedURLException { if ( catalogs . size ( ) > 0 ) { for ( int catPos = 0 ; catPos < catalogs . size ( ) ; catPos ++ ) { Catalog c = null ; try { c = ( Catalog ) catalogs . elementAt ( catPos ) ; } catch ( ClassCastException e ) { String catfile = ( String ) catalogs . elementAt ( catPos ) ; c = newCatalog ( ) ; c . parseCatalog ( catfile ) ; c . parseAllCatalogs ( ) ; } } } }
( String entityName , String publicId , String systemId ) throws MalformedURLException { catalogManager . debug . message ( 3 , " resolveDoctype ( " + entityName + " , " + publicId + " , " + systemId + " ) " ) ; if ( publicId != null && publicId . startsWith ( " urn : publicid : " ) ) { publicId = PublicId . decodeURN ( publicId ) ; } if ( systemId != null && systemId . startsWith ( " urn : publicid : " ) ) { systemId = PublicId . decodeURN ( systemId ) ; } }
the specified document .
the specified system .
to delegated catalog entries .
subordinate catalogs .
the absolute URL of the specified sysid .
the URI .
the encoded byte .
a delegate to a catalog entry .
< K , V > create ( K key , V val , ReferenceQueue < V > q ) { if ( val == null ) return null ; else return new SoftValueRef < K , V > ( key , val , q ) ; }
( int type , Throwable t ) { Object [ ] list = listeners . toArray ( ) ; for ( int i = 0 ; i < list . length ; i ++ ) { ( ( ThrowableListener ) list [ i ] ) . onThrowable ( type , t ) ; } }
a new throwable .
a new List < T > .
int compareTo ( Object other ) { if ( other == this ) return 0 ; TimerTask t = ( TimerTask ) other ; long diff = getNextExecutionTime ( ) - t . getNextExecutionTime ( ) ; return ( int ) diff ; }
InetAddress . getByName ( String text ) { if ( text == null ) { return null ; } if ( text . startsWith ( " / " ) ) { text = text . substring ( 1 ) ; } return InetAddress . getByName ( StringPropertyReplacer . replaceProperties ( text ) ) ; }
the object from the list .
a SoftObject to a SoftObject .
the SoftObject from the list .
a new entry type .
the entry type for the given name .
the number of arguments of the given type .
the entry arg .
( final ClassLoader cl ) { AccessController . doPrivileged ( new PrivilegedAction ( ) { public Object run ( ) { thread . setContextClassLoader ( cl ) ; return null ; } } ) ; }
( int a , int b ) { if ( a == b ) { return this ; } if ( a < b ) { return this ; } if ( b < a ) { return this ; } if ( a < b ) { return this ; } if ( b < a ) { return this ; } if ( a < b ) { return this ; } if ( b < a ) { return this ; } return this ; }
a node from the queue .
( TimeoutExtImpl timeout ) { if ( timeout != null ) timeout . target = null ; return timeout ; }
( String className , boolean resolve ) throws ClassNotFoundException { if ( className == null || className . length ( ) == 0 ) throw new ClassNotFoundException ( ) ; Class < ? > clazz = null ; try { clazz = parent . loadClass ( className ) ; } catch ( ClassNotFoundException e ) { clazz = findLoadedClass ( className ) ; if ( clazz == null ) throw e ; } if ( resolve ) resolveClass ( clazz ) ; return clazz ; }
the specified protocol .
a new URLStreamHandler .
the handlerPkgs property .
the value of the given class .
< T > createImplementation ( Set < T > delegate ) { if ( delegate instanceof HashSet == false ) return new HashSet < T > ( delegate ) ; return delegate ; }
a synchronized LongCounter .
makeDirectional ( final LongCounter counter , final boolean increasing ) { if ( increasing ) { temp = new Wrapper ( counter ) { private static final long serialVersionUID = - 8902748795144754375L ; public long decrement ( ) { throw new UnsupportedOperationException ( ) ; } public void reset ( ) { throw new UnsupportedOperationException ( ) ; } } ; } else { temp = new Wrapper ( counter ) { private static final long serialVersionUID = 2584758778978644599L ; public long increment ( ) { throw new UnsupportedOperationException ( ) ; } public void reset ( ) { throw new UnsupportedOperationException ( ) ; } } ; } return temp ; }
the extension namespace .
if the stream notification has been received .
the given name .
( Object obj ) throws Exception { if ( obj instanceof Reference ) { Reference ref = ( Reference ) obj ; RefAddr addr = ref . get ( " nns " ) ; String key = ( String ) addr . getContent ( ) ; Object target = wrapperMap . get ( key ) ; if ( target != null ) { return target ; } } return null ; }
a string to a Range .
the string into an array of strings .
a byte array .
the object .
a BlockingMode object .
a new entry map .
the value of a TimedEntry .
the value of a TimedEntry .
( Object key ) { TimedEntry entry = ( TimedEntry ) entryMap . remove ( key ) ; if ( entry != null ) entry . destroy ( ) ; }
the map .
a list of valid keys .
the resolution of the timer .
a TimedEntry .
all children of the given element .
a unique child of the given element .
( Element element , String tagName ) throws Exception { return getOptionalChild ( element , tagName , null ) ; }
the content of the element .
the content of the element .
( Element element , String tagName ) throws Exception { return getElementContent ( getOptionalChild ( element , tagName ) ) ; }
the maximum size of the queue .
( String name , BlockingMode blockingMode ) { this . name = name ; this . blockingMode = blockingMode ; }
( String name , BlockingMode blockingMode ) { this . blockingMode = blockingMode ; }
the task wrapper .
the system .
public String resolvePublic ( String publicId , String systemId ) throws MalformedURLException { String resolved = super . resolvePublic ( publicId , systemId ) ; if ( resolved != null ) { return resolved ; } Enumeration enumt = catalogEntries . elements ( ) ; while ( enumt . hasMoreElements ( ) ) { CatalogEntry e = ( CatalogEntry ) enumt . nextElement ( ) ; if ( e . getEntryType ( ) == RESOLVER ) { if ( systemId != null ) { resolved = resolveExternalSystem ( systemId , e . getEntryArg ( 0 ) ) ; if ( resolved != null ) { return resolved ; } } resolved = resolveExternalPublic ( publicId , e . getEntryArg ( 0 ) ) ; if ( resolved != null ) { return resolved ; } } } return super . resolvePublic ( publicId , systemId ) ; }
external system .
External Public .
query resolver .
a new Vector to the existing one .
all subordinate catalogs .
the system reverse .
all system resolutions .
all local systems .
all subordinate catalogs .
the catalog file .
a SAX catalog .
to a file .
getOutputStream ( ) throws IOException { SecurityManager sm = System . getSecurityManager ( ) ; if ( sm != null ) { FilePermission p = new FilePermission ( file . getPath ( ) , " write " ) ; sm . checkPermission ( p ) ; } return new FileOutputStream ( file ) ; }
the next node .
( Node < K , V > b , Node < K , V > f ) { if ( f == next && this == b . next ) { if ( f == null || f . value != f ) appendMarker ( f ) ; else b . casNext ( this , f . next ) ; } }
( ) { Object v = value ; if ( v == this || v == BASE_HEADER ) return null ; return ( V ) v ; }
< K , V > createSnapshot ( ) { V v = getValidValue ( ) ; if ( v == null ) return null ; return new SnapshotEntry ( key , v ) ; }
the right index .
a logger for the given class .
a list of all objects .
the short name of the class .
( ) { StringBuilder buffer = new StringBuilder ( ) ; buffer . append ( getClassShortName ( ) ) . append ( ' @ ' ) ; buffer . append ( Integer . toHexString ( System . identityHashCode ( this ) ) ) ; buffer . append ( ' { ' ) ; toString ( buffer ) ; buffer . append ( ' } ' ) ; return buffer . toString ( ) ; }
the names of the properties .
( final String basename ) { return props . getPropertyGroup ( basename ) ; }
( final Class type ) { try { return type . getConstructor ( new Class [ ] { valueType } ) ; } catch ( Exception ignore ) { try { return type . getConstructor ( new Class [ ] { valueType } ) ; } catch ( Exception ignore2 ) { } } }
a copy of the object .
deref ( final Object obj , Class < T > expected ) { Object result = deref ( obj ) ; if ( result == null ) return null ; return expected . cast ( result ) ; }
the JndiMap .
the JNDI cache for the given name .
keySet ( final boolean includeDefaults ) { if ( includeDefaults ) { Set set = new HashSet ( ) ; set . addAll ( defaults . keySet ( ) ) ; set . addAll ( super . keySet ( ) ) ; return Collections . synchronizedSet ( set ) ; } return super . keySet ( ) ; }
entrySet ( final boolean includeDefaults ) { if ( includeDefaults ) { Set set = new HashSet ( ) ; set . addAll ( defaults . entrySet ( ) ) ; set . addAll ( super . entrySet ( ) ) ; return Collections . synchronizedSet ( set ) ; } return super . entrySet ( ) ; }
the property listener .
( List list , PropertyEvent event ) { if ( list == null ) return ; int size = list . size ( ) ; for ( int i = 0 ; i < size ; i ++ ) { PropertyListener listener = ( PropertyListener ) list . get ( i ) ; listener . propertyAdded ( event ) ; } }
( List list , PropertyEvent event ) { if ( list == null ) return ; int size = list . size ( ) ; for ( int i = 0 ; i < size ; i ++ ) { PropertyListener listener = ( PropertyListener ) list . get ( i ) ; listener . propertyRemoved ( event ) ; } }
( List list ) { if ( list == null ) return ; int size = list . size ( ) ; for ( int i = 0 ; i < size ; i ++ ) { PropertyListener listener = ( PropertyListener ) list . get ( i ) ; listener . propertyChanged ( event ) ; } }
( PropertyChangeEvent event ) { if ( event . getPropertyName ( ) != null ) { List list = ( List ) boundListeners . get ( event . getPropertyName ( ) ) ; if ( list != null ) { firePropertyChanged ( list , event ) ; } } firePropertyChanged ( unboundListeners , event ) ; }
a prefixed property name .
properties from a PropertyReader .
the properties file .
a property group .
boolean isEntityResolved ( ) { return true ; }
the systemId from the classpath resource .
systemId as a URL .
the classpath name from the given systemId .
( String text ) { Document d = getAsDocument ( text ) ; setValue ( d . getDocumentElement ( ) ) ; }
the publicId .
static String encodeURN ( String publicId ) { String urn = PublicId . encodeURN ( publicId ) ; urn = PublicId . encodeURN ( urn ) ; urn = PublicId . encodeURN ( urn ) ; urn = PublicId . encodeURN ( urn ) ; urn = PublicId . encodeURN ( urn ) ; urn = PublicId . encodeURN ( urn ) ; urn = PublicId . encodeURN ( urn ) ; urn = PublicId . encodeURN ( urn ) ; urn = PublicId . encodeURN ( urn ) ; urn = PublicId . encodeURN ( urn ) ; urn = PublicId . encodeURN ( urn ) ; urn = PublicId . encodeURN ( urn ) ; return urn ; }
static String decodeURN ( String urn ) { String publicId = " " ; if ( urn . startsWith ( " urn : publicid : " ) ) { publicId = PublicId . stringReplace ( publicId , " urn : publicid : " , " urn : publicid : " ) ; } else if ( urn . startsWith ( " urn : publicid : " ) ) { publicId = PublicId . stringReplace ( publicId , " urn : publicid : " , " urn : publicid : " ) ; } else { publicId = PublicId . stringReplace ( publicId , " urn : publicid : " , " urn : publicid : " ) ; } return publicId ; }
a string with a new string .
a new thread .
the program .
a StopWatch object .
int compareTo ( final Object obj ) throws ClassCastException { HashCode hashCode = ( HashCode ) obj ; return compareTo ( hashCode . value ) ; }
a hashcode from a byte array .
the hashcode of the array .
a new list .
the value of the field .
the token from the catfile .
the DateEditor .
a vertex to the verticies array .
< Vertex < T > > getRootVertex ( ) { return rootVertex ; }
a vertex from the graph .
the depth first search for the given vertex .
( Vertex < T > v , DFSVisitor < T > visitor ) { if ( visitor != null ) visitor . visit ( this , v ) ; for ( int i = 0 ; i < v . getOutgoingEdgeCount ( ) ; i ++ ) { Edge < T > e = v . getOutgoingEdge ( i ) ; if ( ! e . getTo ( ) . visited ( ) ) { if ( visitor != null ) visitor . visit ( this , v , e ) ; e . mark ( ) ; dfsSpanningTree ( e . getTo ( ) , visitor ) ; } } }
a vertex by data .
all cycles in the graph .
the string .
the XML string .
the root element of the XML document .
the root element of the document .
createElement ( String localPart ) { Document doc = getOwnerDocument ( ) ; log . trace ( " createElement { } " + localPart ) ; return doc . createElement ( localPart ) ; }
a QName for the specified element .
the attributes of the specified element .
if the node has child elements .
the children of the given node .
the text content of the node .
getChildElements ( Node node , String nodeName ) { return getChildElementsIntern ( node , new QName ( nodeName ) ) ; }
the parent element .
( Object holder , Resource resource ) { synchronized ( waiting ) { waiting . put ( holder , resource ) ; } }
the catalog XML file .
the catalog file .
the address of the local host .
an entity .
the system property class value .
( Class clazz ) { if ( clazz . getClassLoader ( ) != null ) { results . append ( clazz . getClassLoader ( ) ) ; } else { results . append ( clazz . getName ( ) ) ; } }
the given class .
( final String classname ) { int idx = classname . lastIndexOf ( PACKAGE_SEPARATOR ) ; if ( idx != - 1 ) return classname . substring ( idx + 1 , classname . length ( ) ) ; return classname ; }
the package name from the classname .
the given type .
the primitive wrapper for the given type .
all interfaces of the given class .
all unique interfaces of the given class .
the primitive wrapper for the given type .
a new instance of the given class .
a getter for a given attribute .
the attribute setter .
a java class to a java class .
the value of the property .
the filenames of a given property .
( ) { WeakObject weak ; while ( ( weak = ( WeakObject ) queue . poll ( ) ) != null ) { set . remove ( weak ) ; } }
iterator ( ) { return new Iterator ( ) { Iterator iter = set . iterator ( ) ; Object UNKNOWN = new Object ( ) ; Object next = UNKNOWN ; public boolean hasNext ( ) { if ( next != UNKNOWN ) { return true ; } while ( iter . hasNext ( ) ) { WeakObject weak = ( WeakObject ) iter . next ( ) ; Object obj = null ; if ( weak != null && ( obj = weak . get ( ) ) == null ) { next = obj ; return true ; } } return false ; } public Object next ( ) { if ( ( next == UNKNOWN ) && ! hasNext ( ) ) { throw new NoSuchElementException ( ) ; } Object obj = next ; next = UNKNOWN ; return obj ; } public void remove ( ) { iter . remove ( ) ; } }
a URLLister .
entrySet ( ) { return new Set ( ) { public Set entrySet ( ) { return entrySet ( ) ; } public Set entrySet ( ) { return entrySet ( ) ; } public Set entrySet ( ) { return entrySet ( ) ; } public Set entrySet ( ) { return entrySet ( ) ; } }
a listener to the bound property .
the bound property listener .
true if the value is null .
the editor for the given type .
the editor .
a string to a property editor .
the current ClassLoader .
the ApplicationDeadlockException .
a timeout for the given time .
a TimeoutWorker .
a subcontext from the given name .
a lookup for a given name .
if the object is an instance of the given class .
( StringBuffer buffer , Class clazz ) { buffer . append ( " class = " ) . append ( clazz . getName ( ) ) ; buffer . append ( " classloader = " ) . append ( clazz . getClassLoader ( ) ) ; buffer . append ( " interfaces = { " ) ; Class [ ] interfaces = clazz . getInterfaces ( ) ; for ( int i = 0 ; i < interfaces . length ; ++ i ) { if ( i > 0 ) buffer . append ( " , " ) ; buffer . append ( " interface = " ) . append ( interfaces [ i ] . getName ( ) ) ; buffer . append ( " classloader = " ) . append ( interfaces [ i ] . getClassLoader ( ) ) ; } buffer . append ( " }
the transition for the given name .
the properties file .
the specified verbosity .
( ) { return true ; }
the list of catalogs from properties file .
catalogs from properties file .
( String pPrefer ) { if ( pPrefer == null || pPrefer . length ( ) == 0 || pPrefer . length ( ) == 0 || pPrefer . length ( ) == 0 || pPrefer . length ( ) == 0 || pPrefer . length ( ) == 0 || pPrefer . length ( ) == 0 ) return defaultPreferPublic ; try { prefer = resources . getString ( " prefer " ) ; } catch ( MissingResourceException e ) { return defaultPreferPublic ; } if ( prefer == null ) { return defaultPreferPublic ; } return ( prefer . equalsIgnoreCase ( " public " ) ) ; }
static catalog .
the publicId of the specified system .
a URL from the given href .
the absolute path of the given URI .
the specified class .
the value of the property .
the name of the element .
the namespace of the node .
the namespace of the element .
list ( Enumeration e ) { ArrayList result = new ArrayList ( ) ; while ( e . hasMoreElements ( ) ) result . add ( e . nextElement ( ) ) ; return result ; }
the InputStream of the given filename .
properties from the given filename .
the properties file .
Edge < T > to Edge < T > .
outgoing edge .
incoming edge .
the edges of the given edge .
the edge from the graph .
Edge < T > findEdge ( Vertex < T > dest ) { for ( Edge < T > e : outgoingEdges ) { if ( e . getTo ( ) == dest ) return e ; } return null ; }
Edge < T > findEdge ( Edge < T > e ) { if ( outgoingEdges . contains ( e ) ) return e ; else return null ; }
the cost of the edge .
a jar file from a directory .
true if hasNext ( ) { for ( int index = 0 ; index < iters . length ; index ++ ) { if ( iters [ index ] != null ) { return true ; } } return false ; }
a new event to the queue .
( ) { }
the parent folder .
an action to the current thread .
the action stream .
a path for the given viewType .
oneToMany ( Collection < ? extends Record > rights , ListKey < Record > manyKey ) { return oneToMany ( rights . stream ( ) , manyKey ) ; }
< T2 < L , R > > manyToOne ( Collection < ? extends R > rights ) { return manyToOne ( rights . stream ( ) ) ; }
strictManyToOne ( Collection < ? extends R > rights ) { if ( rights . size ( ) == 1 ) { return strictManyToOne ( rights . iterator ( ) . next ( ) ) ; } else { return strictManyToOne ( rights ) ; } }
strictOneToOne ( Collection < ? extends R > rights ) { if ( rights . size ( ) == 1 ) { return strictOneToOne ( rights . iterator ( ) . next ( ) ) ; } else { return strictOneToOne ( rights ) ; } }
( ServletContext servletContext , HttpServletRequest request , HttpServletResponse response ) throws ServletException , IOException { return PageUtils . findAllowRobots ( servletContext , request , response ) ; }
the instruction generated .
a complex analyzer .
a MMSeg from a given path .
the sum degree of the word .
the superclass args .
the JdbcResourceLoader .
whether the data source is valid or not .
< T > iterableOf ( final Class < T > type ) { return PrivateGenerate . FIXTURE . createMany ( type ) ; }
NonNull public static < T > T [ ] arrayOf ( final Class < T > clazz ) { assertIsNotParameterized ( clazz , ErrorMessages . msg ( " arrayOf " ) ) ; return PrivateGenerate . manyAsArrayOf ( TypeToken . of ( clazz ) ) ; }
< T > listOf ( final Class < T > clazz ) { assertIsNotParameterized ( clazz , ErrorMessages . msg ( " listOf " ) ) ; return PrivateGenerate . manyAsListOf ( TypeToken . of ( clazz ) ) ; }
< T > collectionOf ( final InstanceOf < T > typeToken , final InlineConstrainedGenerator < T > omittedValues ) { return PrivateGenerate . manyAsListOf ( typeToken , omittedValues ) ; }
< T > listOf ( Class < T > clazz ) { assertIsNotParameterized ( clazz , msg ( " listOf " ) ) ; return io . vavr . collection . List . ofAll ( Any . listOf ( clazz ) ) ; }
< T , U > left ( Class < T > leftType ) { assertIsNotParameterized ( leftType , msgInline ( " left " ) ) ; return Either . left ( Any . instanceOf ( leftType ) ) ; }
< T , U > right ( final Class < U > rightType ) { assertIsNotParameterized ( rightType , msgInline ( " right " ) ) ; return Either . right ( Any . instanceOf ( rightType ) ) ; }
< T , U > validationFailed ( final Class < T > type ) { assertIsNotParameterized ( type , msgInline ( " validationFailed " ) ) ; return Validation . invalid ( type ) ; }
validation success .
a Try < T > object .
( String dataBaseId , String url , String driverClassName , String username , String password ) throws ReflectiveOperationException { SimpleDriverDataSource dataSource = new SimpleDriverDataSource ( ) ; dataSource . setUrl ( url ) ; dataSource . setUsername ( username ) ; dataSource . setPassword ( password ) ; this . templateMap . put ( dataBaseId , new JdbcTemplate ( dataSource ) ) ; return true ; }
the sql in the database .
the result of the query .
a boolean array .
< T > byExample ( T obj ) { if ( obj != null ) { return dao . getTableHelper ( ) . buildFilter ( this , obj ) ; } return this ; }
( final SQLiteDatabase db , final int oldVersion , final int newVersion ) { if ( oldVersion != newVersion ) { db . execSQL ( upgradeSql ( oldVersion , newVersion ) ) ; } }
the table .
a CSV file into a SQLite database .
the empty text .
the data to a csv file .
( String str ) { if ( str == null ) return null ; if ( ! ( str . charAt ( 0 ) == QUOTE && str . charAt ( str . length ( ) - 1 ) == QUOTE ) ) return str ; String quoteless = str . substring ( 1 , str . length ( ) - 1 ) ; return quoteless . trim ( ) ; }
the values of the csv row .
a Map < String , String > .
the map to CSV .
a list of strings .
the list .
the database information .
the index to the database .
a field annotated with @ Id .
the base dao class .
the bind type .
a CSV file .
all tables to csv .
all tables from CSV .
index file .
createQuery ( final EntityManager manager ) { if ( manager == null ) { throw new NullPointerException ( " Entity Manager required " ) ; } final Query query = manager . createQuery ( render ( ) ) ; for ( Parameter < ? > parameter : parameters ) { parameter . apply ( query ) ; } return query ; }
createQuery ( final EntityManager manager , Class < T > type ) { if ( manager == null ) { throw new NullPointerException ( " Entity Manager required " ) ; } TypedQuery < T > result = manager . createQuery ( render ( ) , type ) ; for ( Parameter < ? > parameter : parameters ) { parameter . apply ( result ) ; } return result ; }
the query .
a record from a table .
a new object to the database .
a row in a table .
notIn ( final String expression , final V ... array ) { items . add ( new WhereIn ( builder ( ) , expression , true , array ) ) ; return this ; }
a subquery of the given lhs predicate .
the next active stack .
getEmptyIntentionStack ( ) { if ( getActiveStack ( ) . isEmpty ( ) ) { return getActiveStack ( ) ; } Stack255 stack = new Stack255 ( ( byte ) 8 , ( byte ) 2 ) ; stacks . push ( stack ) ; return stack ; }
a new Belief to the plan .
the selected plan .
the plan variables for the given plan .
the plan variables .
getResultAtIndex ( Set < Belief > results , int index ) { Belief belief = null ; if ( ! ( results == null || index < 0 || index >= results . size ( ) ) ) { int idx = 0 ; for ( Belief b : results ) { if ( idx == index ) { belief = b ; break ; } idx ++ ; } } return belief ; }
a byte array of parents .
a byte array of children .
a new byte [ 1 ] .
a new logger .
step ( ) { return this . step ( ) ; }
the goals to a byte array .
( ) { System . out . println ( " pauseForUserInput " ) ; }
( int nagents ) { Main . poolsize = ( nagents > ncores ) ? ( nagents / ncores ) : 1 ; Main . npools = ( nagents > ncores ) ? ncores : nagents ; }
( ) { }
the intention selection thread .
( ) { for ( int i = 0 ; i < Main . npools ; i ++ ) { Main . intentionSelectors [ i ] . shutdown ( ) ; } }
a Jill extension .
the agent types and goal types .
the current agent .
Plans for Goal Type .
the agents in the catalog .
< ? > loadClass ( String className , Class < ? > classType ) { Class < ? > aclass = null ; try { aclass = Class . forName ( className ) ; } catch ( ClassNotFoundException e ) { logger . error ( " Class not found : " + className , e ) ; return null ; } if ( ! classType . isAssignableFrom ( aclass ) ) { logger . error ( " Class ' " + className + " ' is not of type " + classType . getName ( ) ) ; return null ; } return aclass ; }
extension .
if a name is equal to another name .
public static String usage ( ) { return GlobalConstant . APP_HEADER + " \n \n " + " usage : " + Main . class . getName ( ) + " [ options ] - - agent - class < agentclass > - - num - agents < numagents > " + " \n " + " - - config < string > load configuration from string " + " \n " + " - - configfile < file > load configuration from file " + " \n " + " - - exit - on - idle < boolean > forces system exit when all agents are " + " idle ( default is ' " + GlobalConstant . EXIT_ON_IDLE + " ' ) \n " + " - - help print this usage message and exit \n " ; }
a configuration file .
the config file .
the given query .
the object from the array .
the object with the given name .
a new object to the stack .
the object from the given index .
a new object onto the stack .
( ) { if ( isEmpty ( ) ) { return null ; } size -- ; Object obj = objects [ size ] ; objects [ size ] = null ; return obj ; }
the type of the object .
a Belief with a query .
the text from the console .
a string to a byte array .
a goal to the stack .
a message to an agent .
a message to the specified agent .
a list of goals .
( String name , BeliefSetField [ ] fields ) throws BeliefBaseException { beliefbase . createBeliefSet ( getId ( ) , name , fields ) ; }
Belief to the beliefbase .
the result of the query .
the agent .
BeliefSetFieldByName ( String name ) { BeliefSetField field = null ; for ( int i = 0 ; i < fields . length ; i ++ ) { if ( name . equals ( fields [ i ] . getName ( ) ) { field = fields [ i ] ; break ; } } return field ; }
for the beliefset .
the name of the male or females .
all inactive agents from the pool .
whether the execution stack is valid .
( Set < Integer > toRemove ) { if ( ! toRemove . isEmpty ( ) ) { for ( int i : toRemove ) { activeAgents . remove ( i ) ; } } }
goals for a given node .
the pool .
the agent idle .
disc to the board .
the program .
( ) { long t0 = System . currentTimeMillis ( ) ; synchronized ( poolsIdle ) { while ( ! arePoolsIdle ( ) ) { try { poolsIdle . wait ( ) ; } catch ( InterruptedException e ) { logger . error ( " Failed to wait on termination condition : " + e . getMessage ( ) ) ; } } } }
the extension .
whether the pool is idle or not .
the poolid of the agent .
a new expression .
the expression .
the given attribute .
< ? , ? > joinRecursively ( String [ ] properties , Join < ? , ? > join ) { if ( index < properties . length - 1 ) { return joinRecursively ( properties , findOrCreateJoin ( properties [ index ] , join ) , index + 1 ) ; } else { return join ; } }
( String property , From < ? , ? > from ) { for ( Join < ? , ? > rootJoin : from . getJoins ( ) ) { if ( rootJoin . getAttribute ( ) . getName ( ) . equals ( property ) ) { return rootJoin ; } } return null ; }
boolean isEndReached ( ) { if ( to == null || from == null ) { return true ; } if ( length == null ) { return false ; } return to == length - 1 ; }
the uploaded stream .
the request .
whether a parameter has a value .
the name of the parameter .
the content type parameters .
public void config ( Config config ) throws Exception { log . trace ( " config ( Config . Element ) " ) ; log . debug ( " Configure transaction manager | % s | . " , transactionManager . getClass ( ) ) ; transactionManager . config ( config ) ; }
the target file for the given artifact .
a generated artifact to a target file .
an instance field to a managed class .
the declared constructor .
a string representation of the given descriptor .
the interface method .
the type of the field .
the dependency value for the given type .
a temporary file .
the default link for the given URI .
the default link template for the given rel .
the links .
header links .
links from json body .
a link template for a given object .
the value of the given key .
( HttpResponse response ) { allowedMethods = unmodifiableSet ( stream ( response . getHeaders ( " Allow " ) ) . filter ( x -> x . getName ( ) . equals ( " Allow " ) ) . flatMap ( x -> stream ( x . getElements ( ) ) ) ) ; }
Optional < Boolean > isMethodAllowed ( String method ) { if ( allowedMethods == null ) { return Optional . empty ( ) ; } return Optional . of ( allowedMethods . contains ( method ) ) ; }
a new instance processor .
a new instance factory .
a new instance processor .
a new class processor .
the instance of the given interface class .
a new argument .
a target file list .
a JaxbHelper to the given XML file .
the SrcGen4J template .
a reference to a template .
a ParameterizedTemplateModel .
a new ParameterizedTemplateModel .
the request path .
a StoppableObservable < TEntity > .
asObject ( String string , Class < T > valueType ) { return asObject ( string , valueType ) ; }
the value of the field .
a capture appender to the logger .
the appender from the logger .
the appender .
the arguments from the given file .
EMF model files .
all proxies .
a list of files from a directory .
a directory .
whether the model is fully resolved .
all the contents of a ResourceSet .
a list of modelDirs .
a list of file extensions .
the model resources .
true if the line is not empty .
a string array to the specified value .
( String parameterName , Boolean value ) throws SQLException { if ( value == null ) { setNull ( parameterName , Types . BIT ) ; } else { setBoolean ( parameterName , value . booleanValue ( ) ) ; } }
( String sql , int [ ] columnIndexes ) throws SQLException { return this . stat . executeLargeUpdate ( sql , columnIndexes ) ; }
a string to an instance type .
a Velocity template to a given filename .
the model directory .
the template directory .
the document to the output stream .
a web ui .
the width and height of the WebWindow .
the page .
a byte array to the OutputStream .
public Object invoke ( Object proxy , Method method , Object [ ] args ) { T instance = appFactory . getInstance ( interfaceClass ) ; return method . invoke ( instance , args ) ; }
a request to a given URL .
( ) { if ( attached ) { return ; } attached = false ; }
getCookies ( ) { if ( cookies == null ) { cookies = new Cookies ( httpRequest , httpResponse ) ; } return cookies ; }
the request context .
all invocations of a managed method .
the EventStreamConfig .
the remote host .
the value of the event stream parameter .
the prefix from the path .
the common directory .
the abs path from the given path .
the rel path .
the depth of the given path .
error on HTTP request .
a JSON object to the server .
a new ParameterizedTemplateModel .
a new ParameterizedTemplateModel to the list .
a new ParameterizedTemplateModel .
all references to a given template .
the entity to the database .
the selected item .
the element .
a new instance from the managed class .
a list of files from a FitFileCount .
getSummary ( ) { Counts result = new Counts ( ) ; for ( FileCount fileCount : results ) { if ( fileCount . getCounts ( ) != null ) { result . tally ( fileCount . getCounts ( ) ) ; } } return result ; }
( ) { return getSummaryRow ( ) ; }
the summary row for the given path .
a new instance of the managed class .
the setup class .
the model dirs .
the model resources .
< T > setCandidates ( Collection < T > candidates ) { this . candidates = candidates ; return this ; }
configuration document from file .
void onError ( Exception ex ) { Notification . show ( " Error " , ex . getLocalizedMessage ( ) , Notification . Type . ERROR_MESSAGE ) ; }
the type of the object .
a JSON file .
a JSON object .
the cell parameter .
( ) { return this . q . getHints ( ) ; }
if the request is a XHR request .
the user agent .
the entity type from the message .
< PropertyDescriptor > getPropertiesWithAnnotation ( Class < ? > beanType , Class < TAnnotation > annotationType ) { LinkedList < PropertyDescriptor > result = new LinkedList < > ( ) ; getProperties ( beanType ) . forEach ( property -> { if ( property . getReadMethod ( ) != null && property . getReadMethod ( ) . getAnnotation ( annotationType ) != null || isFieldAnnotated ( beanType , property . getName ( ) , annotationType ) ) { result . add ( property ) ; } } ) ; return result ; }
< TAnnotation > getAnnotation ( Class < ? > beanType , PropertyDescriptor property ) { Optional < TAnnotation > annotation = stream ( property . getReadMethod ( ) . getAnnotationsByType ( annotationType ) ) . findAny ( ) ; return annotation . isPresent ( ) ? annotation : getAnnotationOnField ( beanType , property . getName ( ) , annotationType ) ; }
a message to the server .
the Whois result from the specified domain .
whether a JRubyWhois host has a parser .
the managed class .
the managed method .
( ) { }
if the message contains the given string .
getBoolean2 ( String columnLabel ) throws SQLException { boolean value = this . rs . getBoolean ( columnLabel ) ; return value ; }
( java . lang . Class < ? > arg0 ) throws SQLException { return this . rs . isWrapperFor ( arg0 ) ; }
the response .
the value of a Cookie .
a Cookie to the response .
a cookie from the HTTP response .
< Cookie > iterator ( ) { if ( cookies == null ) { return Collections . emptyIterator ( ) ; } return cookies . iterator ( ) ; }
a TargetFileListProducer .
a field to the class .
< ? > compile ( ) { if ( result == null ) { ClassLoader loader = ClassLoader . getSystemClassLoader ( ) ; try { result = loader . loadClass ( cg . getClassName ( ) ) ; } catch ( ClassNotFoundException e ) { throw new RuntimeException ( e ) ; } } return result ; }
( String token ) { if ( tokenedImageFiles . containsKey ( token ) ) { return true ; } else { return false ; } }
the value of the given file .
a new URI with a trailing slash .
with username and password .
the HttpServletRequest .
a transactional method .
a transactional method .
an immutable transactional method .
the files from the directory .
the last file from the directory .
the concrete configuration type .
if the request path contains a path component .
< ArtifactFactory < MODEL > > getFactories ( final Class < MODEL > modelType ) { final List < ArtifactFactory < MODEL > > list = new ArrayList < ArtifactFactory < MODEL > > ( ) ; if ( factoryConfigs != null ) { for ( final ArtifactFactoryConfig factoryConfig : factoryConfigs ) { if ( modelType . isAssignableFrom ( factoryConfig . getModelType ( ) ) ) { list . add ( ( ArtifactFactory < MODEL > ) factory ) ; } } } return list ; }
a session for the given instance .
the response to a file .
the meta file .
the request .
( ) throws Exception { if ( statement != null ) { statement . close ( ) ; statement = null ; } super . tearDown ( ) ; }
close stale event streams .
whether the endpoint is allowed or not .
the blob .
the data from the server .
column parameters from a FitRow .
the argument names .
PeriodicTask ( final PeriodicTask periodicTask ) { this . periodicTask = periodicTask ; return periodicTask ; }
the timeout task .
views repository configuration .
the next file .
the application .
( ) { StringBuffer banner = new StringBuffer ( ) ; banner . append ( " Welcome to ChameRIA .
( ) { System . out . println ( " " ) ; }
a ChameRIA .
for Chameleon .
a notification .
the trigger event .
a new FitRow into a FitTable .
getCounts ( ) { Counts counts = new Counts ( ) ; for ( FileCount fileCount : results ) { counts . tally ( fileCount . getCounts ( ) ) ; } return counts ; }
( double v ) { if ( Summary_Type . featOkTst && ( ( Summary_Type ) jcasType ) . casFeat_score == null ) jcasType . jcas . throwFeatMissing ( " score " , " edu . cmu . lti . oaqa . type . answer . Summary " ) ; jcasType . ll_cas . ll_setDoubleValue ( addr , ( ( Summary_Type ) jcasType ) . casFeatCode_score , v ) ; }
the variants of the answer .
the variants of the answer .
the question type .
( String v ) { if ( Question_Type . featOkTst && ( ( Question_Type ) jcasType ) . casFeat_questionType == null ) jcasType . jcas . throwFeatMissing ( " questionType " , " edu . cmu . lti . oaqa . type . input . Question " ) ; jcasType . jcas . throwFeatMissing ( " questionType " , " edu . cmu . lti . oaqa . type . input . Question " ) ; jcasType . ll_cas . ll_setStringValue ( addr , ( ( Question_Type ) jcasType ) . casFeatCode_questionType , v ) ; }
( int addr ) { if ( ( ( Focus_Type ) jcasType ) . casFeatCode_token == null ) jcasType . jcas . throwFeatMissing ( " token " , " edu . cmu . lti . oaqa . type . nlp . Focus " ) ; return ( Token ) ( jcasType . ll_cas . ll_getRefValue ( addr , ( ( Focus_Type ) jcasType ) . casFeatCode_token ) ) ; }
the depLabel of the token .
( String v ) { if ( Token_Type . featOkTst && ( ( Token_Type ) jcasType ) . casFeat_depLabel == null ) jcasType . jcas . throwFeatMissing ( " depLabel " , " edu . cmu . lti . oaqa . type . nlp . Token " ) ; jcasType . ll_cas . ll_setStringValue ( addr , ( ( Token_Type ) jcasType ) . casFeatCode_depLabel , v ) ; }
( ) { return semanticType ; }
semanticType ( String v ) { if ( Token_Type . featOkTst && ( ( Token_Type ) jcasType ) . casFeat_semanticType == null ) jcasType . jcas . throwFeatMissing ( " semanticType " , " edu . cmu . lti . oaqa . type . nlp . Token " ) ; jcasType . ll_cas . ll_setStringValue ( addr , ( ( Token_Type ) jcasType ) . casFeatCode_semanticType , v ) ; return this ; }
the sections of the document .
getSections ( StringArray v ) { if ( Document_Type . featOkTst && ( ( Document_Type ) jcasType ) . casFeat_sections == null ) jcasType . jcas . throwFeatMissing ( " sections " , " edu . cmu . lti . oaqa . type . retrieval . Document " ) ; jcasType . ll_cas . ll_setRefValue ( addr , ( ( Document_Type ) jcasType ) . casFeatCode_sections , jcasType . ll_cas . ll_getFSRef ( v ) ) ; return this ; }
the sections of the given Document .
the sections of the given document .
the uris of the given type .
( StringList v ) { if ( Concept_Type . featOkTst && ( ( Concept_Type ) jcasType ) . casFeat_uris == null ) jcasType . jcas . throwFeatMissing ( " uris " , " edu . cmu . lti . oaqa . type . kb . Concept " ) ; jcasType . jcas . throwFeatMissing ( " uris " , " edu . cmu . lti . oaqa . type . kb . Concept " ) ; jcasType . ll_cas . ll_setRefValue ( addr , ( ( Concept_Type ) jcasType ) . casFeatCode_uris , jcasType . ll_cas . ll_getFSRef ( v ) ) ; }
the types of the given type .
( FSList v ) { if ( Concept_Type . featOkTst && ( ( Concept_Type ) jcasType ) . casFeatCode_types == null ) jcasType . jcas . throwFeatMissing ( " types " , " edu . cmu . lti . oaqa . type . kb . Concept " ) ; jcasType . ll_cas . ll_setRefValue ( addr , ( ( Concept_Type ) jcasType ) . casFeatCode_types , v ) ; }
the target type of the answer .
the target type .
the rank of the SearchResult .
( int v ) { if ( SearchResult_Type . featOkTst && ( ( SearchResult_Type ) jcasType ) . casFeat_rank == null ) jcasType . jcas . throwFeatMissing ( " rank " , " edu . cmu . lti . oaqa . type . retrieval . SearchResult " ) ; jcasType . ll_cas . ll_setIntValue ( addr , ( ( SearchResult_Type ) jcasType ) . casFeatCode_rank , v ) ; }
the query string .
the query string .
the candidateAnswers of the SearchResult .
( int addr ) { if ( SearchResult_Type . featOkTst && ( ( SearchResult_Type ) jcasType ) . casFeatCode_candidateAnswers == null ) jcasType . jcas . throwFeatMissing ( " candidateAnswers " , " edu . cmu . lti . oaqa . type . retrieval . SearchResult " ) ; jcasType . ll_cas . ll_setRefValue ( addr , ( ( SearchResult_Type ) jcasType ) . casFeatCode_candidateAnswers ) ; }
the candidate answers for the given type .
( int i ) { if ( SearchResult_Type . featOkTst && ( ( SearchResult_Type ) jcasType ) . casFeatCode_candidateAnswers == null ) jcasType . jcas . throwFeatMissing ( " candidateAnswers " , " edu . cmu . lti . oaqa . type . retrieval . SearchResult " ) ; jcasType . ll_cas . ll_setRefArrayValue ( jcasType . ll_cas . ll_getRefValue ( addr , ( ( SearchResult_Type ) jcasType ) . casFeatCode_candidateAnswers ) , i , jcasType . ll_cas . ll_getFSRef ( v ) ) ; }
the query from the given type .
the query string from the given type .
the hitList from the searched type .
( FSArray v ) { if ( Search_Type . featOkTst && ( ( Search_Type ) jcasType ) . casFeatCode_hitList == null ) jcasType . jcas . throwFeatMissing ( " hitList " , " edu . cmu . lti . oaqa . type . retrieval . Search " ) ; if ( Search_Type . featOkTst && ( ( Search_Type ) jcasType ) . casFeatCode_hitList == null ) jcasType . jcas . throwFeatMissing ( " hitList " , " edu . cmu . lti . oaqa . type . retrieval . Search " ) ; jcasType . ll_cas . ll_setRefValue ( addr , ( ( Search_Type ) jcasType ) . casFeatCode_hitList , jcasType . ll_cas . ll_getFSRef ( v ) ) ; }
the hitList from the searched type .
( int i , SearchResult v ) { if ( Search_Type . featOkTst && ( ( Search_Type ) jcasType ) . casFeatCode_hitList == null ) jcasType . jcas . throwFeatMissing ( " hitList " , " edu . cmu . lti . oaqa . type . retrieval . Search " ) ; jcasType . ll_cas . ll_setRefArrayValue ( jcasType . ll_cas . ll_getRefValue ( addr , ( ( Search_Type ) jcasType ) . casFeatCode_hitList ) , i , jcasType . ll_cas . ll_getFSRef ( v ) ) ; }
the abstract query for the given type .
( AbstractQuery v ) { if ( Search_Type . featOkTst && ( ( Search_Type ) jcasType ) . casFeatCode_abstractQuery == null ) jcasType . jcas . throwFeatMissing ( " abstractQuery " , " edu . cmu . lti . oaqa . type . retrieval . Search " ) ; jcasType . jcas . throwFeatMissing ( " abstractQuery " , " edu . cmu . lti . oaqa . type . retrieval . Search " ) ; jcasType . ll_cas . ll_setRefValue ( addr , ( ( Search_Type ) jcasType ) . casFeatCode_abstractQuery , jcasType . ll_cas . ll_getFSRef ( v ) ) ; }
the searchId .
( String v ) { if ( Search_Type . featOkTst && ( ( Search_Type ) jcasType ) . casFeat_searchId == null ) jcasType . jcas . throwFeatMissing ( " searchId " , " edu . cmu . lti . oaqa . type . retrieval . Search " ) ; if ( Search_Type . featOkTst && ( ( Search_Type ) jcasType ) . casFeatCode_searchId == null ) jcasType . jcas . throwFeatMissing ( " searchId " , " edu . cmu . lti . oaqa . type . retrieval . Search " ) ; jcasType . ll_cas . ll_setStringValue ( addr , ( ( Search_Type ) jcasType ) . casFeatCode_searchId , v ) ; }
( String v ) { if ( Passage_Type . featOkTst && ( ( Passage_Type ) jcasType ) . casFeatCode_docId == null ) jcasType . jcas . throwFeatMissing ( " docId " , " edu . cmu . lti . oaqa . type . retrieval . Passage " ) ; jcasType . ll_cas . ll_setStringValue ( addr , ( ( Passage_Type ) jcasType ) . casFeatCode_docId , v ) ; }
( ) { if ( Passage_Type . featOkTst && ( ( Passage_Type ) jcasType ) . casFeat_offsetInBeginSection == null ) jcasType . jcas . throwFeatMissing ( " offsetInBeginSection " , " edu . cmu . lti . oaqa . type . retrieval . Passage " ) ; return jcasType . ll_cas . ll_getIntValue ( addr , ( ( Passage_Type ) jcasType ) . casFeatCode_offsetInBeginSection ) ; }
( int v ) { if ( Passage_Type . featOkTst && ( ( Passage_Type ) jcasType ) . casFeat_offsetInBeginSection == null ) jcasType . jcas . throwFeatMissing ( " offsetInBeginSection " , " edu . cmu . lti . oaqa . type . retrieval . Passage " ) ; jcasType . ll_cas . ll_setIntValue ( addr , ( ( Passage_Type ) jcasType ) . casFeatCode_offsetInBeginSection , v ) ; }
( int offsetInEndSection ) { if ( Passage_Type . featOkTst && ( ( Passage_Type ) jcasType ) . casFeat_offsetInEndSection == null ) jcasType . jcas . throwFeatMissing ( " offsetInEndSection " , " edu . cmu . lti . oaqa . type . retrieval . Passage " ) ; return jcasType . ll_cas . ll_getIntValue ( addr , offsetInEndSection ) ; }
( int v ) { if ( Passage_Type . featOkTst && ( ( Passage_Type ) jcasType ) . casFeat_offsetInEndSection == null ) jcasType . jcas . throwFeatMissing ( " offsetInEndSection " , " edu . cmu . lti . oaqa . type . retrieval . Passage " ) ; jcasType . ll_cas . ll_setIntValue ( addr , ( ( Passage_Type ) jcasType ) . casFeatCode_offsetInEndSection , v ) ; }
the begin section of the Passage .
( String v ) { if ( Passage_Type . featOkTst && ( ( Passage_Type ) jcasType ) . casFeat_beginSection == null ) jcasType . jcas . throwFeatMissing ( " beginSection " , " edu . cmu . lti . oaqa . type . retrieval . Passage " ) ; jcasType . ll_cas . ll_setStringValue ( addr , ( ( Passage_Type ) jcasType ) . casFeatCode_beginSection , v ) ; }
getEndSection ( ) { return ( Passage_Type ) jcasType ; }
the end section of the given Passage .
the aspects of the Passage type .
the aspects of the Passage type .
a TripleSearchResult .
( Triple v ) { if ( TripleSearchResult_Type . featOkTst && ( ( TripleSearchResult_Type ) jcasType ) . casFeatCode_triple == null ) jcasType . jcas . throwFeatMissing ( " triple " , " edu . cmu . lti . oaqa . type . retrieval . TripleSearchResult " ) ; jcasType . jcas . throwFeatMissing ( " triple " , " edu . cmu . lti . oaqa . type . retrieval . TripleSearchResult " ) ; jcasType . ll_cas . ll_setRefValue ( addr , ( ( TripleSearchResult_Type ) jcasType ) . casFeatCode_triple , jcasType . ll_cas . ll_getFSRef ( v ) ) ; }
the sourceRelation of the Passage from relation .
setSourceRelation ( int addr ) { if ( PassageFromRelation_Type . featOkTst && ( ( PassageFromRelation_Type ) jcasType ) . casFeat_sourceRelation == null ) jcasType . jcas . throwFeatMissing ( " sourceRelation " , " edu . cmu . lti . oaqa . type . retrieval . PassageFromRelation " ) ; jcasType . ll_cas . ll_setRefValue ( addr , ( ( PassageFromRelation_Type ) jcasType ) . casFeatCode_sourceRelation , jcasType . ll_cas . ll_getFSRef ( addr ) ) ; return this ; }
the subject of the Triple .
( String v ) { if ( Triple_Type . featOkTst && ( ( Triple_Type ) jcasType ) . casFeat_subject == null ) jcasType . jcas . throwFeatMissing ( " subject " , " edu . cmu . lti . oaqa . type . kb . Triple " ) ; jcasType . jcas . throwFeatMissing ( " subject " , " edu . cmu . lti . oaqa . type . kb . Triple " ) ; jcasType . ll_cas . ll_setStringValue ( addr , ( ( Triple_Type ) jcasType ) . casFeatCode_subject , v ) ; }
the predicate of the Triple .
the predicate of the Triple .
the isObjUri of the Triple .
isObjUri ( int addr ) { if ( Triple_Type . featOkTst && ( ( Triple_Type ) jcasType ) . casFeatCode_isObjUri == null ) jcasType . jcas . throwFeatMissing ( " isObjUri " , " edu . cmu . lti . oaqa . type . kb . Triple " ) ; return ( ( Triple_Type ) jcasType ) . casFeatCode_isObjUri ; }
getOperator ( ) { if ( ComplexQueryConcept_Type . featOkTst && ( ( ComplexQueryConcept_Type ) jcasType ) . casFeatCode_operator == null ) jcasType . jcas . throwFeatMissing ( " operator " , " edu . cmu . lti . oaqa . type . retrieval . ComplexQueryConcept " ) ; jcasType . jcas . throwFeatMissing ( " operator " , " edu . cmu . lti . oaqa . type . retrieval . ComplexQueryConcept " ) ; return ( QueryOperator ) ( jcasType . ll_cas . ll_getRefValue ( addr , ( ( ComplexQueryConcept_Type ) jcasType ) . casFeatCode_operator ) ) ; }
( QueryOperator v ) { if ( ComplexQueryConcept_Type . featOkTst && ( ( ComplexQueryConcept_Type ) jcasType ) . casFeatCode_operator == null ) jcasType . jcas . throwFeatMissing ( " operator " , " edu . cmu . lti . oaqa . type . retrieval . ComplexQueryConcept " ) ; jcasType . ll_cas . ll_setRefValue ( addr , ( ( ComplexQueryConcept_Type ) jcasType ) . casFeatCode_operator , v ) ; }
( ) { return operatorArgs ; }
( FSList v ) { if ( ComplexQueryConcept_Type . featOkTst && ( ( ComplexQueryConcept_Type ) jcasType ) . casFeatCode_operatorArgs == null ) jcasType . jcas . throwFeatMissing ( " operatorArgs " , " edu . cmu . lti . oaqa . type . retrieval . ComplexQueryConcept " ) ; jcasType . ll_cas . ll_setRefValue ( addr , ( ( ComplexQueryConcept_Type ) jcasType ) . casFeatCode_operatorArgs , jcasType . ll_cas . ll_getFSRef ( v ) ) ; }
Concept from ConceptMention_Type .
the score of the ConceptMention .
the text of the candidate answer occurrence .
the text of the CandidateAnswerOccurrence .
the id of the ConceptType .
the id of the ConceptType .
the name of the Concept Type .
the abbreviation of the given type .
( String v ) { if ( ConceptType_Type . featOkTst && ( ( ConceptType_Type ) jcasType ) . casFeatCode_abbreviation == null ) jcasType . jcas . throwFeatMissing ( " abbreviation " , " edu . cmu . lti . oaqa . type . kb . ConceptType " ) ; jcasType . jcas . throwFeatMissing ( " abbreviation " , " edu . cmu . lti . oaqa . type . kb . ConceptType " ) ; jcasType . ll_cas . ll_setStringValue ( addr , ( ( ConceptType_Type ) jcasType ) . casFeatCode_abbreviation , v ) ; }
( Concept v ) { if ( ConceptSearchResult_Type . featOkTst && ( ( ConceptSearchResult_Type ) jcasType ) . casFeatCode_concept == null ) jcasType . jcas . throwFeatMissing ( " concept " , " edu . cmu . lti . oaqa . type . retrieval . ConceptSearchResult " ) ; jcasType . jcas . throwFeatMissing ( " concept " , " edu . cmu . lti . oaqa . type . retrieval . ConceptSearchResult " ) ; jcasType . ll_cas . ll_setRefValue ( addr , ( ( ConceptSearchResult_Type ) jcasType ) . casFeatCode_concept , jcasType . ll_cas . ll_getFSRef ( v ) ) ; }
the variants of the answer .
the variants of the answer .
the named entity types .
( StringList v ) { if ( QueryConcept_Type . featOkTst && ( ( QueryConcept_Type ) jcasType ) . casFeat_namedEntityTypes == null ) jcasType . jcas . throwFeatMissing ( " namedEntityTypes " , " edu . cmu . lti . oaqa . type . retrieval . QueryConcept " ) ; jcasType . ll_cas . ll_setRefValue ( addr , ( ( QueryConcept_Type ) jcasType ) . casFeatCode_namedEntityTypes , jcasType . ll_cas . ll_getFSRef ( v ) ) ; }
the concept type .
( String v ) { if ( QueryConcept_Type . featOkTst && ( ( QueryConcept_Type ) jcasType ) . casFeatCode_conceptType == null ) jcasType . jcas . throwFeatMissing ( " conceptType " , " edu . cmu . lti . oaqa . type . retrieval . QueryConcept " ) ; jcasType . ll_cas . ll_setStringValue ( addr , ( ( QueryConcept_Type ) jcasType ) . casFeatCode_conceptType , v ) ; }
( ) { if ( CandidateAnswerVariant_Type . featOkTst && ( ( CandidateAnswerVariant_Type ) jcasType ) . casFeatCode_occurrences == null ) jcasType . jcas . throwFeatMissing ( " occurrences " , " edu . cmu . lti . oaqa . type . answer . CandidateAnswerVariant " ) ; return ( FSList ) ( jcasType . ll_cas . ll_getFSForRef ( jcasType . ll_cas . ll_getRefValue ( addr , ( ( CandidateAnswerVariant_Type ) jcasType ) . casFeatCode_occurrences ) ) ) ; }
( FSList v ) { if ( CandidateAnswerVariant_Type . featOkTst && ( ( CandidateAnswerVariant_Type ) jcasType ) . casFeatCode_occurrences == null ) jcasType . jcas . throwFeatMissing ( " occurrences " , " edu . cmu . lti . oaqa . type . answer . CandidateAnswerVariant " ) ; jcasType . ll_cas . ll_setRefValue ( addr , ( ( CandidateAnswerVariant_Type ) jcasType ) . casFeatCode_occurrences , jcasType . ll_cas . ll_getFSRef ( v ) ) ; }
the concepts of the given type .
( FSList v ) { if ( AbstractQuery_Type . featOkTst && ( ( AbstractQuery_Type ) jcasType ) . casFeatCode_concepts == null ) jcasType . jcas . throwFeatMissing ( " concepts " , " edu . cmu . lti . oaqa . type . retrieval . AbstractQuery " ) ; jcasType . ll_cas . ll_setRefValue ( addr , ( ( AbstractQuery_Type ) jcasType ) . casFeatCode_concepts , jcasType . ll_cas . ll_getFSRef ( v ) ) ; }
the original text .
( String v ) { if ( AtomicQueryConcept_Type . featOkTst && ( ( AtomicQueryConcept_Type ) jcasType ) . casFeat_originalText == null ) jcasType . jcas . throwFeatMissing ( " originalText " , " edu . cmu . lti . oaqa . type . retrieval . AtomicQueryConcept " ) ; jcasType . jcas . throwFeatMissing ( " originalText " , " edu . cmu . lti . oaqa . type . retrieval . AtomicQueryConcept " ) ; jcasType . ll_cas . ll_setStringValue ( addr , ( ( AtomicQueryConcept_Type ) jcasType ) . casFeatCode_originalText , v ) ; }
the args of the query operator .
( StringList v ) { if ( QueryOperator_Type . featOkTst && ( ( QueryOperator_Type ) jcasType ) . casFeatCode_args == null ) jcasType . jcas . throwFeatMissing ( " args " , " edu . cmu . lti . oaqa . type . retrieval . QueryOperator " ) ; jcasType . ll_cas . ll_setRefValue ( addr , ( ( QueryOperator_Type ) jcasType ) . casFeatCode_args , v ) ; }
the label of the SemanticRole_Type .
the label of the SemanticRole .
the next clear bit .
the word from the given index .
the mapped buffer .
CacheValue newInstance ( CacheDirectory directory , String fileName ) { return newInstance ( directory , fileName , getCacheBlockSize ( directory , fileName ) ) ; }
the size of the array .
a list of MonomerNotations .
the brackets in the annotation section .
details to the given string .
toHELM2 ( ) { if ( isAnnotationTrue ( ) ) { return sourceId . getId ( ) + " , " + targetId . getId ( ) + " , " + sourceUnit + " : " + rGroupSource + " - " + targetUnit + " : " + rGroupTarget ; } else if ( isAnnotationFalse ( ) ) { return sourceId . getId ( ) + " , " + targetId . getId ( ) + " , " + sourceUnit + " : " + rGroupSource + " - " + targetUnit + " : " + rGroupTarget ; } else { return sourceId . getId ( ) + " , " + targetId . getId ( ) + " , " + sourceUnit + " : " + rGroupSource + " - " + targetUnit + " : " + rGroupTarget ; } }
a new element to the group .
HELM1 to HELM2 .
if the polymerId is valid .
if the polymerid is valid .
if the connection ' s details are valid .
if the groupID is valid .
if the given string matches the given pattern .
or RNA .
the notation container to JSON .
getSimplePolymer ( String string ) { for ( PolymerNotation polymer : listOfPolymers ) { if ( polymer . getPolymerID ( ) . getId ( ) . equals ( string ) ) { return polymer ; } } return null ; }
getCurrentGroupingNotation ( ) { if ( listOfGroupings . size ( ) == 0 ) { return null ; } return listOfGroupings . get ( listOfGroupings . size ( ) - 1 ) ; }
HELM2 to HELM2 .
polymer toHELM2 .
the connection toHELM2 .
a list of groupings .
annotation toHELM2 .
( ) { List < String > listOfIDs = new ArrayList < String > ( ) ; for ( PolymerNotation polymer : listOfPolymers ) { listOfIDs . add ( polymer . getPolymerID ( ) ) ; } for ( GroupingNotation grouping : listOfGroupings ) { listOfIDs . add ( grouping . getGroupID ( ) ) ; } return listOfIDs ; }
getPolymerNotation ( String id ) { for ( PolymerNotation polymer : listOfPolymers ) { if ( polymer . getPolymerID ( ) . getId ( ) . equals ( id ) ) { return polymer ; } } return null ; }
polymerElements ( ) { if ( polymerID instanceof RNAEntity ) { this . polymerElements = new PolymerListElements ( polymerID ) ; } else { this . polymerElements = new PolymerSingleElements ( polymerID ) ; } }
a string to a string .
the annotation .
the count of a given string .
decideWhichMonomerNotation ( String str , String type ) throws NotationException { MonomerNotation mon = null ; if ( str . startsWith ( " ( " ) && str . endsWith ( " ) " ) ) { String str2 = str . substring ( 1 , str . length ( ) - 1 ) ; Pattern patternAND = Pattern . compile ( " \\ + " ) ; Pattern patternOR = Pattern . compile ( " , " ) ; if ( patternAND . matcher ( str ) . find ( ) ) { mon = new MonomerNotationGroupMixture ( str2 , type ) ; } else if ( patternOR . matcher ( str ) . find ( ) ) { mon = new MonomerNotationGroupOr ( str2 , type ) ; } else { if ( str . contains ( " . " ) ) { mon = new MonomerNotationList ( str2 , type ) ; }
decideWhichMonomerNotation ( String str , String type , double one , double two , boolean interval , boolean isDefault ) throws NotationException { MonomerNotation element ; element = decideWhichMonomerNotation ( str , type ) ; if ( interval ) { return new MonomerNotationGroupElement ( element , one , two ) ; } else { return new MonomerNotationGroupElement ( element , one ) ; } }
decideWhichEntity ( String str ) throws NotationException { if ( str . toUpperCase ( ) . matches ( " Peptide [ 1-9 ] [ 0-9 ] * " ) ) { item = new PeptideEntity ( str . toUpperCase ( ) ) ; } else if ( str . toUpperCase ( ) . matches ( " RNA [ 1-9 ] [ 0-9 ] * " ) ) { item = new RNAEntity ( str . toUpperCase ( ) ) ; } else if ( str . toUpperCase ( ) . matches ( " BLOB [ 1-9 ] [ 0-9 ] * " ) ) { item = new BlobEntity ( str . toUpperCase ( ) ) ; } else if ( str . toUpperCase ( ) . matches ( " CHEM [ 1-9 ] [ 0-9 ] * " ) ) { item = new ChemEntity ( str . toUpperCase ( ) ) ; } else if ( str . toUpperCase ( ) . matches ( " G [ 1-9 ] [ 0-9 ] *
the value of the interval .
the HELM2 standard .
a new MonomerNotationUnit to the list .
( String a ) throws NotationException { setAmbiguity ( new GroupingMixture ( a ) ) ; }
getStatistics ( ) { return new AWorkerThreadStatistics ( getState ( ) , getId ( ) , stat_numTasksExecuted , stat_numSharedTasksExecuted , stat_numSteals , stat_numExceptions , stat_numParks , stat_numFalseAlarmUnparks , stat_numSharedQueueSwitches , stat_numLocalSubmits ) ; }
a new ADiGraph .
a new ADiGraph < N , E > .
incoming and outgoing paths .
a sorted list of nodes sorted by reachability .
to the specified pattern .
subscribe count from the specified pattern .
the given pattern .
the response .
a return sync .
the poll request .
the server .
the local handling of the exception .
( int oldRunState , int newRunState ) { if ( ! U . compareAndSwapInt ( this , RUNSTATE , oldRunState , newRunState ) ) { Object lock = stealCounter ; runState = newRunState ; if ( lock != null ) { lock . notifyAll ( ) ; } } }
a new ForkJoinWorkerThread .
a worker to the current thread .
registerWorker ( ForkJoinWorkerThread wt , ForkJoinWorkerThread ueh ) { if ( ueh != null ) wt . setUncaughtExceptionHandler ( ueh ) ; return wt ; }
( ForkJoinWorkerThread wt ) { ForkJoinTask . helpExpungeStaleExceptions ( ) ; ForkJoinTask . rethrow ( null ) ; }
( WorkQueue [ ] ws ) { while ( true ) { if ( ws == null ) break ; if ( ws . length <= ( i = sp & SMASK ) ) break ; if ( ws . length <= ( i = sp & SMASK ) ) break ; } }
( WorkQueue w ) { w . growArray ( ) ; int seed = w . hint ; int r = ( seed == 0 ) ? 1 : seed ; for ( ForkJoinTask < ? > t ; ) { if ( ( t = scan ( w , r ) ) != null ) w . runTask ( t ) ; else if ( ! awaitWork ( w , r ) ) break ; r ^= r << 13 ; r ^= r >>> 17 ; } }
for work to be completed .
the task count of the ForkJoinWorkerThread .
a new work queue .
helpComplete ( CountedCompleter < ? > task ) { WorkQueue [ ] ws ; int n ; int r = ThreadLocalRandomHelper . getProbe ( ) ; return ( ( ws = workQueues ) == null || ( n = ws . length ) == 0 ) ? 0 : helpComplete ( ws [ ( n - 1 ) & r & SQMASK ] , task , maxTasks ) ; }
< T > submit ( ForkJoinTask < T > task ) { if ( task == null ) throw new NullPointerException ( ) ; return task ; }
a common ForkJoinPool .
the result of the given timeout .
a string .
getStatistics ( ) { return getStatistics ( ) ; }
< T > create ( T ... elements ) { return create ( Arrays . asList ( elements ) ) ; }
the list .
static < T , E extends Throwable > boolean forAll ( Iterable < T > coll , APredicate < ? super T , E > pred ) throws E { for ( T o : coll ) { if ( ! pred . apply ( o ) ) { return false ; } } return true ; }
( Iterable < T > coll , R startValue , AFunction2 < R , ? super T , R , E > f ) throws E { R result = startValue ; for ( T e : coll ) { result = f . apply ( result , e ) ; } return result ; }
the result of the fold function .
a task to the queue .
< T > fromNullable ( T nullable ) { return nullable != null ? some ( nullable ) : AOption . < T > none ( ) ; }
< V > fromKeysAndValues ( Iterable < ? extends Number > keys , Iterable < V > values ) { if ( keys == null ) { return ALongHashMap . empty ( ) ; } if ( values == null ) { return ALongHashMap . empty ( ) ; } return fromKeysAndValues ( keys , values ) ; }
< K , V > empty ( ) { return empty ; }
< K , V > fromKeysAndValues ( AEquality equality , Iterable < ATuple2 < K , V > > elements ) { AListMap < K , V > result = empty ( equality ) ; for ( ATuple2 < K , V > el : elements ) { result = result . updated ( el . _1 , el . _2 ) ; } return result ; }
< K , V > fromKeysAndValues ( AEquality equality , Iterable < K > keys , Iterable < V > values ) { final Iterator < K > ki = keys . iterator ( ) ; final Iterator < V > vi = values . iterator ( ) ; AListMap < K , V > result = empty ( equality ) ; while ( ki . hasNext ( ) ) { final K key = ki . next ( ) ; final V value = vi . next ( ) ; result = result . updated ( key , value ) ; } return result ; }
< K > keySet ( ) { return new AbstractSet < K > ( ) { @ Override public Iterator < K > iterator ( ) { return new Iterator < K > ( ) { final Iterator < AMapEntry < K , V > > it = inner . iterator ( ) ; @ Override public boolean hasNext ( ) { return it . hasNext ( ) ; } @ Override public K next ( ) { return it . next ( ) . getKey ( ) ; } @ Override public void remove ( ) { throw new UnsupportedOperationException ( ) ; } } ; } @ Override public int size ( ) { return inner . size ( ) ; } }
the name of the resource .
a BoundType to a String .
a string with the length of the given string .
< T > forList ( final List < T > list ) { return new BinarySearch < T > ( ) { @ Override @ SuppressWarnings ( { " unchecked " } ) protected int compare ( int index , T element ) { return list . get ( index ) . compareTo ( element ) ; } @ Override protected int getLastIndex ( ) { return list . size ( ) - 1 ; } } ; }
< T > forList ( final List < T > list , final Comparator < T > comparator ) { return new BinarySearch < T > ( ) { @ Override @ SuppressWarnings ( { " unchecked " } ) protected int compare ( int index , T element ) { return comparator . compare ( list . get ( index ) , element ) ; } @ Override protected int getLastIndex ( ) { return list . size ( ) - 1 ; } } ; }
email .
a message to the specified email .
a pattern to the given route .
a filter to the given handler .
a tag body for a given subject .
static int getInt ( Long l ) { return ( l == null || l > Integer . MAX_VALUE ) ? 0 : l . intValue ( ) ; }
duplicate strings from array .
static String like ( String value ) { return StringPool . PERCENT + Strings . nullToEmpty ( value ) + StringPool . PERCENT ; }
another run .
the password of the given user .
login user from cookie .
the login user .
if the password matches the given salt .
a cookie to the user .
the login key for the user .
the cookie user for the given uuid .
a request to the WebContext .
a file separator to the path .
the value of the given parameter .
the message .
getCallerInformations ( ) { StackTraceElement [ ] callStack = Thread . currentThread ( ) . getStackTrace ( ) ; StackTraceElement caller = callStack [ level ] ; return new CallInfo ( caller . getClassName ( ) , caller . getMethodName ( ) ) ; }
a string to a byte array .
a string to a byte array .
a byte array to a char array .
a string to a byte array .
the locale data from the given code .
a Promise < V > .
the cropped image .
invoke ( final Invocation invocation , long millis ) { return executor . schedule ( invocation , millis , TimeUnit . MILLISECONDS ) ; }
the invocation in a thread .
the rest of the client .
( String error , Exception e ) { renderJson ( AjaxMessage . error ( error , e ) ) ; }
( String message , T data ) { renderJson ( AjaxMessage . forbidden ( message , data ) ) ; }
the template for the given view .
the current action path .
a datatable .
( DTCriterias criterias ) { Preconditions . checkNotNull ( criterias , " datatable criterias is must be not null . " ) ; renderJson ( criterias ) ; }
the items in the ComboBox .
the response to the given url .
< T > list ( Class < ? > type ) { List < T > r = new ArrayList < T > ( ) ; for ( Injector i = injector ; i != null ; i = i . getParent ( ) ) { for ( Entry < Key < ? > , Binding < ? > > e : i . getBindings ( ) . entrySet ( ) ) { if ( e . getKey ( ) . getTypeLiteral ( ) . equals ( type ) ) r . add ( ( T ) e . getValue ( ) . getProvider ( ) . get ( ) ) ; } } return r ; }
the current method .
unused memory .
the metrics to the collection .
the length of the value .
the charset of the given file .
the input stream to the output stream .
the contents of the input stream to the output stream .
( InputStream input , OutputStream output ) throws IOException { copy ( input , output , Const . DEFAULT_ENCODING ) ; }
the contents of a Reader to a Writer .
a char array to a Writer .
( Reader input , OutputStream output ) throws IOException { copy ( input , output , Const . DEFAULT_ENCODING ) ; }
the input to the output .
input1 and input2 .
input1 and input2 .
< T , T > apply ( T io ) { logger . debug ( " Pipeline started " ) ; try { for ( int i = 0 ; i < stages . size ( ) ; i ++ ) { Object stage = stages . get ( i ) ; String name = names . get ( stage ) ; logger . debug ( " Stage - " + i + ( ( name != null && ! name . isEmpty ( ) ) ? " [ " + name + " ] " : " " ) + " processing " ) ; if ( stage instanceof Function ) { if ( ( io = ( ( Function < T , T > ) stage ) . apply ( io ) ) == null ) { return io ; } } else if ( stage instanceof Predicate ) { if ( ! ( ( Predicate < T > ) stage ) . apply ( io ) ) { return io ; } } } return io ; } finally { logger . debug ( " Pipeline ended " ) ; } }
the sql for the given groupNameAndsqlId .
a string to a JAXB object .
( File zipFile , File destDir , String ... patterns ) throws IOException { ZipFile zip = new ZipFile ( zipFile ) ; ZipEntry zipEntry = zip . getNextEntry ( ) ; if ( zipEntry != null && zipEntry . isDirectory ( ) ) { zipEntry = zipEntry . getNextEntry ( ) ; } if ( zipEntry != null && zipEntry . isDirectory ( ) ) { zipEntry = zipEntry . getNextEntry ( ) ; } if ( zipEntry != null && zipEntry . isDirectory ( ) ) { zipEntry = zipEntry . getNextEntry ( ) ; } if ( zipEntry != null && zipEntry . isDirectory ( ) ) { zipEntry = zipEntry . getNextEntry ( ) ; } if ( zipEntry != null && zipEntry . isDirectory ( ) ) { zipEntry = zipEntry . getNextEntry ( ) ; } if ( zipEntry != null && zipEntry . isDirectory ( ) ) { zipEntry = zipEntry . getNextEntry ( ) ; } if
static PermissionDialogFragment getInstance ( PermBean bean ) { if ( bean == null ) throw new NullPointerException ( " Permission Beans cannot be null ! " ) ; Bundle extras = new Bundle ( 3 ) ; HashMap < Permission , String > map = ( HashMap < Permission , String > ) bean . getPermissions ( ) ; extras . putSerializable ( PERMISSION , map ) ; extras . putInt ( REQUEST , requestCode ) ; PermissionDialog fragment = new PermissionDialogFragment ( ) ; fragment . setArguments ( extras ) ; return fragment ; }
public void onResume ( ) { super . onResume ( ) ; getDialog ( ) . setOnKeyListener ( new DialogInterface . OnKeyListener ( ) { @ Override public boolean onKey ( DialogInterface dialog , int keyCode , KeyEvent keyEvent ) { return keyCode != KeyEvent . ACTION_DOWN ; } } ) ; }
( Class < ? > clazz , Converter converter ) { ConvertUtils . register ( converter , clazz ) ; }
true if the value matches the regex .
static boolean isMobile ( String value ) { String check = " ^ ( ( ( 13[0-9 ] { 1 } ) | ( 15[0-9 ] { 1 } ) | ( 18[0-9 ] { 1 } ) ) + \\ d { 8 } ) $ " ; return match ( check , Pattern . CASE_INSENSITIVE , value ) ; }
static boolean isPhone ( String value ) { String telcheck = " ^ \\ d { 3,4 } - ? \\ d { 7,9 } $ " ; String mobilecheck = " ^ ( ( ( 13[0-9 ] { 1 } ) | ( 15[0-9 ] { 1 } ) | ( 18[0-9 ] { 1 } ) ) + \\ d { 8 } ) $ " ; return match ( telcheck , Pattern . CASE_INSENSITIVE , value ) ; }
static boolean isBirthDay ( String value ) { if ( value . length ( ) == 0 ) { return false ; } if ( value . length ( ) == 1 ) { return true ; } if ( value . length ( ) == 2 ) { return true ; } if ( value . length ( ) == 3 ) { return true ; } if ( value . length ( ) == 4 ) { return true ; } if ( value . length ( ) == 5 ) { return true ; } if ( value . length ( ) == 6 ) { return true ; } if ( value . length ( ) == 7 ) { return true ; } if ( value . length ( ) == 8 ) { return true ; } if ( value . length ( ) == 9 ) { return true ; } if ( value . length ( ) == 10 ) { return true ; } if ( value . length ( ) == 11 ) { return true ; } if ( value . length ( ) ==
static boolean isUrl ( String value ) { if ( value == null ) { return false ; } if ( value . length ( ) == 0 ) { return false ; } return true ; }
static boolean isDateTime ( String value ) { String check = " ^ ( \\ d { 4 } ) ( / | - | \\ . | 年 ) ( \\ d { 1,2 } ) ( / | - | \\ . | 月 ) ( \\ d { 1,2 } ) ( 日 ) ? ( \\ s + \\ d { 1,2 } ( : | 时 ) \\ d { 1,2 } ( : | 分 ) ? ( \\ d { 1,2 } ( 秒 ) ? ) ? ) ? $ " ; return match ( check , Pattern . CASE_INSENSITIVE , value ) ; }
a filter to the WebContext .
the base64 string .
the base64 string .
hex string to byte array .
the properties from the file .
( InputStream is ) { String res = null ; try { res = IOUtils . toString ( is , encoding ) ; } catch ( Exception e ) { throw new RuntimeException ( e ) ; } finally { try { is . close ( ) ; } catch ( Exception e ) { } } return res ; }
the content of the given file .
a byte array to a file .
a directory to the target .
the XML document .
a Document object from an XML file .
Document object from xml data .
Document object from xml data .
an XML signature .
an XML document .
static boolean isCacheSafe ( Class < ? > clazz ) { return isCacheSafe ( clazz . getClassLoader ( ) ) ; }
true if the class is a primitive array .
a boolean primitive wrapper .
the primitive type to the wrapper .
< ? > isAssignable ( Class < ? > lhsType , Class < ? > rhsType ) { Preconditions . checkNotNull ( lhsType , " Left - hand side type must not be null " ) ; Preconditions . checkNotNull ( rhsType , " Right - hand side type must not be null " ) ; if ( lhsType . isAssignableFrom ( rhsType ) ) { return true ; } if ( lhsType . isPrimitive ( ) ) { Class < ? > resolvedPrimitive = primitiveWrapperTypeMap . get ( lhsType ) ; if ( resolvedPrimitive != null && lhsType . equals ( resolvedPrimitive ) ) { return true ; } } if ( rhsType . isPrimitive ( ) ) { Class < ? > resolvedPrimitive = primitiveWrapperTypeMap . get ( rhsType ) ; if ( resolvedPrimitive != null && lhsType . equals ( resolvedPrimitive ) ) { return true ; } } return false ; }
whether a value is a primitive type .
all interfaces for the given class .
all interfaces for the given class .
a temporary configuration file .
the variables from the uri .
PermBean put ( Permission permission , String message ) { if ( permission == null ) throw new IllegalArgumentException ( " Permission can ' t be null " ) ; mPermissions . put ( permission , message ) ; return this ; }
a DruidPlugin for the given database .
a loader module to a given extension point .
the context for the given type .
the primitive value of the given type .
an object to a given type .
the object to a String .
the parameters from the request .
the cookie value from the request .
the session attribute .
the database .
a shared variable for FreeMarkerRender .
( String field , Condition condition , Object value ) { this . params . add ( Triple . of ( field , condition , value ) ) ; }
( String field , Object value ) { this . setParam ( field , Condition . EQ , value ) ; }
the dialog .
true if all values are granted .
whether a value is denied or not .
all records for a given SqlSelect .
the record for the given SqlSelect .
a new instance of the given model .
whether a method declares an exception .
( ) { while ( ( sv = ( SoftValue < ? , ? > ) queue . poll ( ) ) != null ) { map . remove ( sv . key ) ; } }
a SoftValue < V , K > .
match ( String string , String pattern ) { if ( string . equals ( pattern ) ) { return true ; } return false ; }
the given arguments .
the protobuf entity .
static final boolean isProtbufEntity ( Class < ? > clazz ) { final ProtobufEntity protoBufEntity = getProtobufEntity ( clazz ) ; if ( protoBufEntity != null ) { return true ; } return false ; }
all protbuf fields from the given class .
for field .
the setter for the field .
the mapper .
a new JsonFactory .
the json string .
the borders of the window .
the user record from the given domain .
out attributes .
out mbean attribute values .
( String key ) { if ( key == null ) return null ; return m_properties . getProperty ( key ) ; }
the property value .
app to the JFrame .
a token to the database .
the access token .
the default ClassLoader .
the resource from the given name .
the resource from the given name .
the class from the classpath .
the URI .
a scheme .
a path from a string .
the scheme .
the userinfo .
the host to the specified port .
the port to the specified port .
a path to the given string .
the query string .
the fragment for the given URI .
the URI spec .
createByIterator ( Connection conn , String sql , Iterator < ? > parameters ) throws SQLException { PreparedStatement ps = conn . prepareStatement ( sql ) ; if ( parameters != null ) { int index = 1 ; while ( parameters . hasNext ( ) ) { Object parameter = parameters . next ( ) ; if ( parameter == null ) { ps . setObject ( index , null ) ; } else { ps . setObject ( index , parameter ) ; } index ++ ; } } if ( parameters != null ) { int index = 1 ; while ( parameters . hasNext ( ) ) { Object parameter = parameters . next ( ) ; if ( parameter == null ) { ps . setObject ( index , null ) ; } else { ps . setObject ( index , parameter ) ; } index ++ ; } } return ps ; }
the persistence service .
the Muffin value from a URL .
the file contents from the given URL .
the clipboard contents .
clipboard contents .
a file from the given path .
the services from the given class .
setServiceParams ( ParametrizedOperation op ) { if ( op != null ) { for ( Map . Entry < String , Object > entry : params . entrySet ( ) ) { op . setParam ( entry . getKey ( ) , entry . getValue ( ) ) ; } } return op ; }
the parameters of a ParametrizedOperation .
the parametrized service .
the class of the service .
query response .
< E > iterator ( ) { return new Iterator < E > ( ) { int iteratorIndex ; int iteratorBufferIndex ; int iteratorOffset ; @ Override public boolean hasNext ( ) { return iteratorIndex < size ; } @ Override public E next ( ) { if ( iteratorIndex >= size ) { throw new NoSuchElementException ( ) ; } E [ ] buf = buffers [ iteratorBufferIndex ] ; E result = buf [ iteratorOffset ] ; iteratorIndex ++ ; iteratorOffset ++ ; if ( iteratorOffset >= buf . length ) { iteratorOffset = 0 ; iteratorBufferIndex ++ ; } return result ; } @ Override public void remove ( ) { throw new UnsupportedOperationException ( ) ; } }
the encoding of the xml string .
the parent logger .
getInstance ( Connection conn ) { if ( conn instanceof JdbcLogConnection ) { return ( JdbcLogConnection ) conn ; } }
the authorization code from the authorization url .
a package declaration .
the type of the given class .
the type of the executable .
getOption ( final String key ) { return getOption ( key , null ) ; }
static DeclarationFilter getFilter ( final Collection < Modifier > mods ) { return new DeclarationFilter ( ) { public boolean matches ( Declaration d ) { return d . getModifiers ( ) . containsAll ( mods ) ; } } ; }
static DeclarationFilter getFilter ( final Class < ? extends Declaration > kind ) { return new DeclarationFilter ( ) { public boolean matches ( Declaration d ) { return kind . isInstance ( d ) ; } } ; }
and ( DeclarationFilter f ) { final DeclarationFilter f1 = this ; final DeclarationFilter f2 = f ; return new DeclarationFilter ( ) { public boolean matches ( Declaration d ) { return f1 . matches ( d ) && f2 . matches ( d ) ; } } ; }
or ( DeclarationFilter f ) { final DeclarationFilter f1 = this ; final DeclarationFilter f2 = f ; return new DeclarationFilter ( ) { public boolean matches ( Declaration d ) { return f1 . matches ( d ) || f2 . matches ( d ) ; } } ; }
< String , V > getMap ( ) { Map < String , V > result = map ; if ( result == null ) { synchronized ( this ) { result = map ; if ( result == null ) { map = ( result = initialize ( ) ) ; } } } return result ; }
static < T > void makeAccessible ( final Constructor < T > constructor ) { if ( ! Modifier . isPublic ( constructor . getModifiers ( ) ) || ! Modifier . isPublic ( constructor . getDeclaringClass ( ) . getModifiers ( ) ) ) { constructor . setAccessible ( true ) ; } }
a query to poll an MBean object that has no attributes .
slashes with hyphens .
a string representation of a byte array .
the indexes of the given name .
( String sql ) { this . sql = sql ; }
a Collection toProtobufs .
the protobuf field value .
a protobuf value to a POJO .
the extension of the given pathname .
the ResultSet instance .
< ExpectedLabels , Integer > mapLabels ( final List < String > labels ) { final Map < ExpectedLabels , Integer > map = new EnumMap < > ( ExpectedLabels . class ) ; final List < ExpectedLabels > unusedLabels = new ArrayList < > ( Arrays . asList ( ExpectedLabels . values ( ) ) ) ; for ( int index = 0 ; index < labels . size ( ) ; index ++ ) { final String next = labels . get ( index ) ; try { final ExpectedLabels labelValue = ExpectedLabels . valueOf ( next ) ; unusedLabels . remove ( labelValue ) ; if ( map . containsKey ( labelValue ) ) { LOGGER . warn ( " Duplicate state label : { } ( { } ) " , next , labels ) ; } map . put ( labelValue , index ) ; } catch ( final IllegalArgumentException e ) { LOGGER . warn ( " Unexpected state label : { } " , next ) ; } } return map ; }
the values from a ZonedDateTime .
the generic supertype of the given type .
a batch of objects .
one object at a time .
the field of the given class .
[ ] getDeclaredMethods ( Class < ? > clazz , boolean recursively ) { List < Method > methods = new LinkedList < Method > ( ) ; Method [ ] declaredMethods = clazz . getDeclaredMethods ( ) ; Collections . addAll ( methods , declaredMethods ) ; Class < ? > superClass = clazz . getSuperclass ( ) ; if ( superClass != null && recursively ) { Method [ ] declaredMethodsOfSuper = getDeclaredMethods ( superClass , recursively ) ; Collections . addAll ( methods , declaredMethodsOfSuper ) ; } return methods . toArray ( new Method [ methods . size ( ) ] ) ; }
getDeclaredMethod ( Class < ? > clazz , String methodName , Class < ? > ... parameterTypes ) { try { return clazz . getDeclaredMethod ( methodName , parameterTypes ) ; } catch ( SecurityException e ) { log . error ( " { } " , e . getMessage ( ) , e ) ; } }
annotated annotated methods .
a list of all annotated constructors .
( byte b , boolean passThrough ) { if ( passThrough == true ) { System . out . print ( ' \t ' ) ; } if ( b < 0 ) { b += 128 ; } if ( b < 0x10 ) { System . out . print ( '0' ) ; } System . out . print ( b ) ; }
( String s ) { if ( s == null ) { return - 1 ; } if ( s . length ( ) == 0 ) { return - 1 ; } if ( s . length ( ) == 0 ) { return - 1 ; } if ( s . length ( ) == 0 ) { return - 1 ; } if ( s . length ( ) == 0 ) { return - 1 ; } if ( s . length ( ) == 0 ) { return - 1 ; } if ( s . length ( ) == 0 ) { return - 1 ; } return s . length ( ) ; }
the characters from the string .
the state .
the audit class .
a message queue .
the password validator .
the password authenticator .
( final Locale locale ) { return resolveLocaleCode ( locale . getLanguage ( ) , locale . getCountry ( ) , locale . getVariant ( ) ) ; }
the LocaleInfo for the given code .
a new instance of JdbcLogStatement .
the elements of the array .
the element into the array .
the element from the array .
the input file .
( Properties properties ) { if ( properties == null ) properties = new Properties ( ) ; if ( args == null ) return properties ; for ( int i = 0 ; i < args . length ; i ++ ) AppUtilities . addParam ( properties , args [ i ] , false ) ; return properties ; }
true if the pattern matches the given tokens .
( int xofs , int yofs ) { x1 += xofs ; y1 += yofs ; y2 += yofs ; }
encloses ( Rectangular other ) { return x1 <= other . x1 && y1 <= other . y1 && x2 >= other . x2 && y2 >= other . y2 ; }
boolean contains ( int x , int y ) { return x1 <= x && y1 <= y && x2 >= x && y2 >= y ; }
( Rectangular other ) { if ( this . intersects ( other ) ) { return new Rectangular ( Math . max ( x1 , other . x1 ) , Math . max ( y1 , other . y1 ) , Math . min ( x2 , other . x2 ) , Math . min ( y2 , other . y2 ) ) ; } else { return new Rectangular ( ) ; } }
a Rectangular into a Rectangular .
x1 and x2 in a Rectangular .
( Rectangular other ) { if ( other == null ) return this ; if ( other . y1 == null ) return this ; if ( other . y2 == null ) return this ; if ( other . y1 == null ) return this ; if ( other . y2 == null ) return this ; if ( other . y1 == null ) return this ; if ( other . y2 == null ) return this ; if ( other . y1 == null ) return this ; if ( other . y2 == null ) return this ; if ( other . y1 == null ) return this ; if ( other . y2 == null ) return this ; if ( other . y1 == null ) return this ; if ( other . y2 == null ) return this ; return this ; }
the width of the specified column .
the row of the given height .
getCellBoundsRelative ( int x , int y ) { int x1 = getColOfs ( x ) ; int y1 = getRowOfs ( y ) ; int x2 = ( x == width - 1 ) ? abspos . getWidth ( ) - 1 : x1 + cols [ x ] - 1 ; int y2 = ( y == height - 1 ) ? abspos . getHeight ( ) - 1 : y1 + rows [ y ] - 1 ; return getCellBoundsRelative ( x1 , y1 ) ; }
columns for the given area .
rows for the given area .
( Throwable t ) { if ( t instanceof InvocationTargetException ) { e = ( ( InvocationTargetException ) t ) . getTargetException ( ) ; } else if ( t instanceof UndeclaredThrowableException ) { e = ( ( UndeclaredThrowableException ) t ) . getUndeclaredThrowable ( ) ; } else { return t ; } }
main ( String [ ] args ) { try { Main main = new Main ( ) ; main . start ( ) ; Runtime . getRuntime ( ) . addShutdownHook ( main . getShutdownHook ( ) ) ; main . awaitTermination ( 1 , TimeUnit . DAYS ) ; } catch ( InterruptedException e ) { e . printStackTrace ( ) ; } }
the given code buffer .
and resize the code buffer .
instructions .
the application properties .
a new QueryParameter .
a child to the tree .
the children .
< E > next ( ) { if ( exhausted ) { return null ; } nextSolution = nextInSequence ( ) ; if ( nextSolution == null ) { exhausted = true ; } return nextSolution ; }
instructions to the body .
instructions to parent .
the state of the WorkPanel .
( WorkPanel panel ) { this . panel = panel ; }
the present component flags .
a new BigDecimalType instance .
whether a variable is bound or anonymous .
instructions .
the two collections .
the content of the given request .
doStartTag ( ) throws JspException { log . fine ( " doStartTag ( ) : called " ) ; TagUtils tagUtils = TagUtils . getInstance ( ) ; PagedList list = ( PagedList ) tagUtils . lookup ( pageContext , name , property , scope ) ; log . fine ( " list = " + list ) ; try { url = tagUtils . computeURL ( pageContext , null , null , action , null , null , false ) ; } catch ( MalformedURLException e ) { throw new JspException ( " Got malformed URL exception : " , e ) ; } renderButton ( renderFirst , 0 , 0 , openDelimFirst , url , firstText , list . getCurrentPage ( ) != 0 ) ; renderButton ( renderBack , list . getCurrentPage ( ) - 1 , ( ( list . getCurrentPage ( ) - 1 ) < list . getCurrentIndex ( ) ) ? ( list . getCurrentIndex ( ) - maxPages )
a button .
the machine to train .
the training examples .
the index of the key .
the index of the given key .
< V > set ( int index , V value ) { if ( index >= data . size ( ) ) { throw new IndexOutOfBoundsException ( ) ; } return data . set ( index , value ) ; }
the key from the map .
a key from the list .
the properties of the given object .
the setter method for the property .
the property of the callee .
whether the primitive type is a wrapper or primitive type .
the setters .
decide ( State state ) { if ( state . getProperty ( propertyName ) != null ) { return decide ( state ) ; } return decide ( state ) ; }
a lookup for a DecisionTreeElement .
the given query .
the left and right functors .
( Variable leftVar , Term rightTerm , List < Variable > leftTrail , List < Variable > rightTrail ) { if ( leftTerm . isVar ( ) && ( ( Variable ) leftTerm ) . isBound ( ) ) { return unifyInternal ( leftVar , rightTerm . getValue ( ) , leftTrail , rightTrail ) ; } else if ( rightTerm . isVar ( ) && ( ( Variable ) rightTerm ) . isBound ( ) ) { return unifyInternal ( leftVar , rightTerm . getValue ( ) , leftTrail , rightTrail ) ; } else { leftVar . setSubstitution ( rightTerm ) ; leftTrail . add ( leftVar . getStorageCell ( leftVar ) ) ; return true ; } }
a query .
the maximum number of arguments in the clause .
.
( Term clause ) { PositionalTermTraverser positionalTraverser = new PositionalTermTraverserImpl ( ) ; PositionAndOccurrenceVisitor positionAndOccurrenceVisitor = new PositionAndOccurrenceVisitor ( interner , symbolTable , positionalTraverser ) ; positionalTraverser . setContextChangeVisitor ( positionAndOccurrenceVisitor ) ; return positionalTraverser ; }
( String predicate ) { if ( predicate == null ) { return null ; } if ( predicate . length ( ) == 0 ) { return null ; } if ( predicate . length ( ) == 0 ) { return null ; } return predicate ; }
( String query ) { if ( query != null && query . length ( ) > 0 ) { result = new StringBuffer ( ) ; PositionalTermVisitor displayVisitor = new WAMCompiledQueryPrintingVisitor ( interner , symbolTable , result ) ; TermWalkers . positionalWalker ( displayVisitor ) . walk ( query ) ; } }
PaddedInt32AsString ( ByteBuffer buffer , int value ) { if ( value < 0 ) { buffer . put ( MINUS_ASCII ) ; } else { buffer . put ( value ) ; } }
the string representation of the buffer .
the value of the attribute .
the value of the enumerated string attribute .
the Lojix term .
whether the class exists and is loadable .
if a class is a subtype of another class .
the type of the given parent and child .
the type of the child class .
< ? > forName ( String className ) { try { return Class . forName ( className ) ; } catch ( ClassNotFoundException e ) { throw new ReflectionUtilsException ( " ClassNotFoundException whilst finding class : " + className + " . " , e ) ; } }
a new instance of the given class .
a new instance of the given class .
methodOverridingIllegalAccess ( Object o , String method , Object [ ] params , Class [ ] paramClasses ) { try { Method m = cls . getDeclaredMethod ( method , paramClasses ) ; m . setAccessible ( true ) ; return m . invoke ( o , params ) ; } catch ( NoSuchMethodException e ) { throw new IllegalStateException ( e ) ; } catch ( InvocationTargetException e ) { throw new IllegalStateException ( e ) ; } }
the specified method .
( Method method ) { try { return method . invoke ( null ) ; } catch ( IllegalAccessException e ) { throw new IllegalStateException ( e ) ; } }
< T > getConstructor ( Class < T > cls ) { try { return cls . getConstructor ( args ) ; } catch ( NoSuchMethodException e ) { throw new IllegalStateException ( e ) ; } }
the setters of the given class .
the transactional queue .
( ) { }
getTypeFromObject ( Object o ) { return getTypeFromObject ( o ) ; }
the search algorithm .
the state of the given path .
a new instance of the given type .
support of TZ to the end point .
a timezone to the alternate dimension .
a dimension to the table .
free variables for a given query .
( Term query ) { QueueBasedSearchMethod < Term , Term > freeVarSearch = new DepthFirstSearch < Term , Term > ( ) ; freeVarSearch . reset ( ) ; freeVarSearch . addStartState ( query ) ; freeVarSearch . setGoalPredicate ( new FreeNonAnonymousVariablePredicate ( ) ) ; return ( Set < Variable > ) Searches . setOf ( freeVarSearch ) ; }
the SearchNode object1 and SearchNode object2 .
to the output file .
a string from a BufferedInputStream .
< O , T > createSearchNode ( T state ) { return new HeuristicSearchNode < O , T > ( state , heuristic ) ; }
the trace indent .
argument registers .
isLastBodyTerm ( Term var , Functor body ) { return body == symbolTable . get ( var . getSymbolKey ( ) , SymbolTableKeys . SYMKEY_VAR_LAST_ARG_FUNCTOR ) ; }
the majority classification for the given property .
whether all attributes have the same classification .
the gain of a given input property .
functor ( String name ) { int internedName = interner . internFunctorName ( name , args . length ) ; return new Functor ( internedName , args ) ; }
a new variable for the given name .
the action with error handling .
< E > get ( int index ) { int originalSize = original . size ( ) ; int size = ( originalSize / pageSize ) + ( ( ( originalSize % pageSize ) == 0 ) ? 0 : 1 ) ; if ( ( index == 0 ) && ( originalSize == 0 ) ) { return new ArrayList < E > ( ) ; } if ( ( index >= size ) || ( index < 0 ) ) { throw new IndexOutOfBoundsException ( " Index " + index + " is less than zero or more than the number of pages : " + size ) ; } return original . subList ( index , size ) ; }
( Paint obj ) { if ( obj instanceof GradientPaint ) { texture = new GradientPaint ( 0 , 0 , Color . white , getSize ( ) . width * 2 , 0 , Color . green ) ; } else { texture = obj ; } }
( ) { return this ; }
a BufferedImage from a given image type .
a Graphics2D .
a binary image .
a SGISurface .
( QueueSearchAlgorithm < O , T > algorithm ) { algorithm . setPeekAtHead ( true ) ; algorithm . setReverseEnqueueOrder ( true ) ; return algorithm ; }
search ( QueueSearchState < O , T > initSearch , Collection < T > startStates , int maxSteps , int searchSteps ) throws SearchNotExhaustiveException { for ( float bound = startBound ; ; ) { maxBound = bound ; { int numStepsSoFar = initSearch . getStepsTaken ( ) ; initSearch . resetEnqueuedOnceFlag ( ) ; SearchNode node = super . search ( initSearch , startStates , maxSteps , numStepsSoFar ) ; if ( node != null ) { return node ; } else { return null ; } } } }
< O , T > search ( QueueSearchState < O , T > initSearch , Collection < T > startStates , boolean peekAtHead , boolean reverseEnqueue ) throws SearchNotExhaustiveException { Queue < SearchNode < O , T > > queue = initSearch . enqueueStartStates ( startStates ) ; UnaryPredicate < T > goalPredicate = initSearch . getGoalPredicate ( ) ; while ( ! queue . isEmpty ( ) ) { SearchNode < O , T > headNode = peekAtHead ? queue . peek ( ) : queue . remove ( ) ; if ( ! headNode . isExpanded ( ) ) { headNode . expandSuccessors ( queue , reverseEnqueue ) ; } SearchNode < O , T > currentNode = peekAtHead ? queue . peek ( ) : headNode ; if ( goalPredicate . evaluate ( currentNode . getState ( ) ) ) { return currentNode ; } } return null ; }
a Prolog parser .
clause ( ) { return clause ; }
a list of terms .
functor ( ) { return functor ( ) ; }
a Functor .
< Term > flattenTerm ( ) throws SourceCodeException { Term term = term ( ) ; List < Term > result = TermUtils . flattenTerm ( term , Term . class , " , " , interner ) ; return result . toArray ( new Term [ result . size ( ) ] ) ; }
the name of the variable .
a NumericType .
a double literal .
a StringLiteral .
( ) throws SourceCodeException { if ( peekAndConsumeTrace ( ) ) { return Directive . Trace ; } return null ; }
an operator .
void internOperator ( String operator , int XFY ) { internOperator ( operator , XFY ) ; internOperator ( operator , XFY ) ; internOperator ( operator , XFY ) ; internOperator ( operator , XFY ) ; }
a token .
the next token .
a TxId to a thread .
the transaction .
the elements of the collection .
a call point .
timeOfDayToTicks ( int hour , int minute , int second ) { return millisecond + ( MILLIS_PER_SECOND * second ) + ( MILLIS_PER_MINUTE * minute ) + ( MILLIS_PER_HOUR * hour ) ; }
the year from the ticks .
the ticks with the given hours .
the ticks with the specified minutes .
the ticks with the specified seconds .
the ticks of the current year .
the ticks with the given month .
the ticks for the given date .
the start of the year .
the day of the year .
a ByteBlock .
a new entry for the given key .
the entry for the given key .
the entry .
the table .
and discard the work .
( ) { return nextAvailable ; }
( ) { if ( prevAvailable != avail ) { prevAvailable = avail ; firePropertyChange ( new PropertyChangeEvent ( this , " prevAvailable " , ! avail , avail ) ) ; } }
the finished property to true .
a WAMResolvingNativeMachine .
< Set < Variable > > iterator ( ) { return new SequenceIterator < Set < Variable > > ( ) { public Set < Variable > nextInSequence ( ) { return resolve ( ) ; } } ; }
expectedI ( double [ ] probabilities ) { double result = 0.0 ; for ( double p : probabilities ) { if ( p > 0.0d ) { result -= p * Math . log ( p ) ; } } return result / LN2 ; }
the probabilities of the given counts .
the ticks for the current year .
perform ( ActionMapping mapping , ActionForm form , HttpServletRequest request , HttpServletResponse response ) throws IOException , ServletException { log . fine ( " perform " ) ; return ( mapping . findForward ( " success " ) ) ; }
a new URL from the specified spec .
the request properties .
the headers of the request .
the cookies of the current page .
the parameters of the request .
the request scope .
the page scope .
the session scope .
the application scope .
the user principal .
the debug tag to the page .
a HTML table .
search ( QueueSearchState < O , T > initSearch , Collection < T > startStates , boolean peekAtHead ) throws SearchNotExhaustiveException { SearchNode < O , T > currentNode = peekAtHead ? queue . peek ( ) : queue . remove ( ) ; if ( currentNode . isExpanded ( ) && goalPredicate . evaluate ( initSearch . getState ( ) ) ) { return currentNode ; } if ( currentNode . isExpanded ( ) && goalPredicate . evaluate ( initSearch . getState ( ) ) ) { return currentNode ; } if ( currentNode . isExpanded ( ) && goalPredicate . evaluate ( initSearch . getState ( ) ) ) { return currentNode ; } if ( currentNode . isExpanded ( ) && goalPredicate . evaluate ( initSearch . getState ( ) ) ) { return currentNode ; } if ( currentNode . isExpanded ( ) && goalPredicate . evaluate ( initSearch . getState ( ) ) ) { return currentNode ; } return null ;
the current screen state .
the term traverser .
the SearchNode object1 and SearchNode object2 .
registers .
the changes .
the clause .
the top level of a given PositionalContext .
a T [ ] array .
the arguments of the operator .
the Fixity for the given associativity .
whether the associativity is XFY or YFY .
int compareTo ( Object o ) { OpSymbol opSymbol = ( OpSymbol ) o ; return ( priority < opSymbol . priority ) ? - 1 : ( ( priority > opSymbol . priority ) ? 1 : 0 ) ; }
( WorkFlowScreenState screenState ) { this . screenState = screenState ; }
a WorkFlowController .
an enum attribute factory for the given class .
( String className ) { return ( ComponentFactory ) ReflectionUtils . newInstance ( ReflectionUtils . forName ( className ) ) ; }
the storage cell for the given variable .
boolean isBound ( ) { VariableBindingContext < Variable > context = getBindingContext ( ) ; return context != null && context . isBound ( ) ; }
the column attributes .
the row attributes .
( int c ) { if ( c >= 0 ) { return columnAttributes . get ( c ) ; } else { return null ; } }
( int r ) { if ( r >= 0 ) { return rowAttributes . get ( r ) ; } else { return null ; } }
a cell with the given attributes .
a new TimeRangeType .
a new instance of StringPatternType .
whether the given value is a valid string .
initial context .
the memory layout .
the value of the expression group .
< O , T > findGoalPath ( List < SearchNode < O , T > > forwardQueue , List < SearchNode < O , T > > reverseQueue ) { if ( ! forwardQueue . isEmpty ( ) ) { SearchNode < O , T > currentForwardNode = forwardQueue . remove ( ) ; forwardFringe . remove ( currentForwardNode . getState ( ) ) ; if ( reverseFringe . containsKey ( currentForwardNode . getState ( ) ) ) { return joinBothPaths ( reverseFringe . get ( currentForwardNode . getState ( ) ) , currentForwardNode ) ; } else { Queue < SearchNode < O , T > > newStates = new LinkedList < SearchNode < O , T > > ( ) ; currentForwardNode . expandSuccessors ( newStates , false ) ; forwardQueue . addAll ( newStates ) ; for ( SearchNode < O , T > nextSearchNode : newStates ) { reverse
both paths .
a list of blocks from a given block .
getProperties ( String resourceName ) { if ( propertyReaders . containsKey ( resourceName ) ) { return propertyReaders . get ( resourceName ) . getProperties ( ) ; } propertyReader = new DefaultPropertyReader ( resourceName ) ; propertyReaders . put ( resourceName , propertyReader ) ; return propertyReader . getProperties ( ) ; }
the rate of the given hertz .
a ByteBlock .
the current position of the source .
( Disjunction disjunction , List < Term > expressions ) { gatherDisjunctionsExploreArgument ( disjunction . getArguments ( ) [ 0 ] , expressions ) ; gatherDisjunctionsExploreArgument ( disjunction . getArguments ( ) [ 1 ] , expressions ) ; }
( byte [ ] buf ) { return getIntFromBytes ( buf , 0 ) ; }
the value to a byte array .
( byte [ ] buf , int offset , int value ) { buf [ offset ++ ] = ( byte ) ( value & 0x000000ff ) ; buf [ offset ++ ] = ( byte ) ( ( value & 0x0000ff00 ) >> 8 ) ; buf [ offset ++ ] = ( byte ) ( ( value & 0x00ff0000 ) >> 16 ) ; }
( byte [ ] buf , int offset ) { int i = 0 ; offset ++ ; i += buf [ offset ++ ] & 0xFF ; i += ( buf [ offset ++ ] & 0xFF ) << 8 ; i += ( ( buf [ offset ] & 0xFF ) << 16 ) ; return i ; }
a short from a byte array .
a short to a byte array .
< E > getChildStateForOperator ( Operator < Tree < E > > op ) { return new TreeSearchState < E > ( op . getOp ( ) ) ; }
< Operator < Tree < E > > > validOperators ( ) { if ( tree . isLeaf ( ) ) { return new ArrayList < Operator < Tree < E > > > ( ) . iterator ( ) ; } else { Tree . Node < E > node = tree . getAsNode ( ) ; return new TreeSearchOperatorIterator < E > ( node . getChildIterator ( ) ) ; } }
the id of the attribute .
the value of the attribute .
the value of the attribute .
a string to a list of strings .
a list of all the elements in the array .
the name to a camel case .
the value to lowercase .
a list of logging handlers .
a list of handlers for the given handler .
the WAMCallPoint for the given functor .
a new WAMCallPoint to the symbol table .
a sub category for a given attribute .
the id of the category .
the level of the attribute class .
the last path value .
the attribute class .
the path array value .
the h of the search node .
mod ( long c , int bucketSize ) { return ( int ) ( ( c < 0 ) ? ( ( bucketSize + ( c % bucketSize ) ) % bucketSize ) : ( c % bucketSize ) ) ; }
( String key , String userMessage ) { errors . add ( new UserReadableErrorImpl ( key , userMessage ) ) ; }
the exception .
a string to the output file .
a decision tree .
a and b in the same order .
a client iterator .
the log base of the value .
the value of the log table .
( int value ) { return ( value >= 1000000000 ) ? 9 : ( ( value >= 10000000 ) ? 7 : ( ( value >= 1000000 ) ? 6 : ( ( value >= 100000 ) ? 5 : ( ( value >= 10000 ) ? 4 : ( ( value >= 1000 ) ? 3 : ( ( value >= 100 ) ? 2 : ( ( value >= 10 ) ? 1 : 0 ) ) ) ) ) ) ) ; }
( int value ) { return ( value < 10 ) ? 0 : ( ( value < 100 ) ? 1 : ( ( value < 1000 ) ? 2 : ( ( value < 10000 ) ? 3 : ( ( value < 100000 ) ? 4 : ( ( value < 1000000 ) ? 5 : ( ( value < 10000000 ) ? 6 : ( ( value < 100000000 ) ? 7 : ( ( value < 1000000000 ) ? 8 : 9 ) ) ) ) ) ) ) ) ; }
the log base10 of the value .
( long value ) { if ( value == 0 ) { return 0 ; } if ( value == 1 ) { return 1 ; } if ( value == 2 ) { return 2 ; } if ( value == 3 ) { return 3 ; } if ( value == 4 ) { return 4 ; } return 5 ; }
the character count of a given integer .
the character count of a long .
the length of the integer .
( Functor head ) { this . head = head ; addInstructions ( instructions ) ; }
code .
( WorkFlowScreenPanel screen ) { state . setCurrentScreenState ( screen . getState ( ) ) ; }
whether a given predicate is true or false .
the properties of the current thread .
getProperties ( String key ) { String className = null ; String methodName = null ; return getProperties ( className , methodName , key ) ; }
getKeyIterator ( final String environment , final String base , final String modifier , final boolean useDefaults ) { return new Iterator ( ) { private int i ; public boolean hasNext ( ) { return ( useDefaults ? ( ( i < ORDER . length ) && ( ORDER [ i ] > ENVIRONMENT_DEFAULTS_CUTOFF ) ) : ( i < ORDER . length ) ) ; } public Object next ( ) { if ( ! hasNext ( ) ) { return null ; } int o = ORDER [ i ] ; String result = ( ( o & E ) != 0 ) ? ( environment + " . " ) : " " ) + ( ( ( o & B ) != 0 ) ? ( base + " . " ) : " " ) + ( ( ( o & M ) != 0 ) ? ( modifier + " . " ) : " " ) + key ; i ++ ; return result ; } public void remove ( ) { throw new UnsupportedOperationException
a new array property .
the throttle rate .
a numeric type .
the properties .
the properties from the specified path .
getProperties ( ) { InputStream is = this . getClass ( ) . getClassLoader ( ) . getResourceAsStream ( getPropertiesResourceName ( ) ) ; if ( is != null ) { try { return PropertiesHelper . getProperties ( is ) ; } catch ( IOException e ) { e = null ; } } return null ; }
properties using CWD .
a built in functor to the traverser .
the value of the substitution .
the substitution of the term .
< SearchNode < O , T > > createQueue ( ) { return new PriorityQueue < SearchNode < O , T > > ( 11 , new GreedyComparator ( ) ) ; }
oos and connectors .
the event to the SocketAppender .
a new connector thread .
( ) { printers . add ( new SourceClausePrinter ( interner , symbolTable , traverser , maxColumns ++ , printTable ) ) ; }
the transaction .
the transaction .
( TxOperation op ) { TxId txId = null ; if ( getIsolationLevel ( ) . compareTo ( IsolationLevel . None ) > 0 ) { txId = TxManager . getTxIdFromThread ( ) ; enlistWithSession ( ) ; } if ( getIsolationLevel ( ) . equals ( IsolationLevel . None ) ) { op . execute ( ) ; } else { addCachedOperation ( txId , op ) ; } }
a cached write operation .
( TxId txId ) throws InterruptedException { globalLock . writeLock ( ) . lock ( ) ; try { if ( ! txId . equals ( globalWriteLockTxId ) ) { while ( globalWriteLockTxId != null ) { globalWriteLockFree . await ( ) ; } globalWriteLockTxId = txId ; } } finally { globalLock . writeLock ( ) . unlock ( ) ; } }
( ) { globalLock . writeLock ( ) . lock ( ) ; try { globalWriteLockTxId = null ; globalWriteLockFree . signal ( ) ; } finally { globalLock . writeLock ( ) . unlock ( ) ; } }
the transactional resource .
if a rule set has a selector group .
a new element into the queue .
the element from the queue .
an element into the queue .
a record into a buffer .
the next object .
whether a property is a boolean .
Integer getPropertyAsInteger ( String propName ) { String prop = getProperty ( propName ) ; return ( prop != null ) ? Integer . valueOf ( prop ) : null ; }
( String propName ) { String prop = getProperty ( propName ) ; return ( prop != null ) ? Long . valueOf ( prop ) : null ; }
mixin scope .
a new property node .
the search node .
the code from the given WAMCallPoint .
bindings from a compiled query .
( int start , Map < Integer , Variable > variableContext ) { return decodeHeap ( start , variableContext ) ; }
an instance of the class .
the value of an object .
the value of the given class .
a value into a HashMap .
all field names from the given class .
a command .
a new node to the list .
the first item from the list .
< O , T > createSearchNode ( T state ) { return new SearchNode < O , T > ( state ) ; }
< SearchNode < O , T > > createQueue ( ) { return new PriorityQueue < SearchNode < O , T > > ( 11 , new UniformCostComparator ( ) ) ; }
a new TermWalker ( TermVisitor visitor ) { return new TermWalker ( visitor ) ; }
the goal of a unary predicate .
positionalWalker ( ) { PositionalTermTraverser positionalTraverser = new PositionalTermTraverserImpl ( ) ; positionalTraverser . setContextChangeVisitor ( visitor ) ; return new TermWalker ( new DepthFirstBacktrackingSearch < Term , Term > ( ) , positionalTraverser , visitor ) ; }
positionalWalker ( UnaryPredicate < Term > unaryPredicate , PositionalTermVisitor visitor ) { TermWalker walker = positionalWalker ( visitor ) ; walker . setGoalPredicate ( unaryPredicate ) ; return walker ; }
positionalPostfixWalker ( ) { PositionalTermTraverser positionalTraverser = new PositionalTermTraverserImpl ( ) ; positionalTraverser . setContextChangeVisitor ( visitor ) ; return new TermWalker ( new PostFixSearch < Term , Term > ( ) , positionalTraverser , visitor ) ; }
getProperties ( InputStream is ) throws IOException { Properties properties = new Properties ( ) ; properties . load ( is ) ; return properties ; }
getProperties ( File file ) { InputStream is = new FileInputStream ( file ) ; Properties properties = getProperties ( is ) ; is . close ( ) ; return properties ; }
properties from URL .
the properties of the given pathname .
the grid size .
( ) { if ( ! fontMetricsInitialized ) { fontMetrics = getFontMetrics ( getFont ( ) ) ; charWidth = fontMetrics . charWidth ( ' ' ) ; charHeight = fontMetrics . getHeight ( ) ; descent = fontMetrics . getDescent ( ) ; fontMetricsInitialized = true ; } }
a PropertyChangeListener to the list of listeners .
a PropertyChangeListener to the list of listeners .
( PropertyChangeListener l ) { if ( l == null ) { return ; } synchronized ( listeners ) { listeners . remove ( l ) ; } }
( final PropertyChangeEvent evt ) { if ( evt == null ) { return ; } if ( evt instanceof PropertyChangeListener ) { final PropertyChangeListener l = ( PropertyChangeListener ) evt ; SwingUtilities . invokeLater ( l ) ; } else { if ( evt instanceof PropertyChangeEvent ) { final PropertyChangeEvent l = ( PropertyChangeEvent ) evt ; SwingUtilities . invokeLater ( l ) ; } else { if ( evt instanceof PropertyChangeEvent ) { final PropertyChangeEvent l = ( PropertyChangeEvent ) evt ; SwingUtilities . invokeLater ( l ) ; } else if ( evt instanceof PropertyChangeEvent ) { final PropertyChangeEvent l = ( PropertyChangeEvent ) evt ; SwingUtilities . invokeLater ( l ) ; } else if ( evt instanceof PropertyChangeEvent ) { final PropertyChangeEvent l = ( PropertyChangeEvent ) evt ; SwingUtilities . invokeLater ( l ) ; } else if ( evt instanceof PropertyChangeEvent ) { final PropertyChangeEvent l = ( PropertyChangeEvent ) evt ; SwingUtilities . invokeLater ( l ) ; } else { SwingUtilities . invokeLater ( l ) ; } }
a new DoubleRangeType .
a new FadeState .
the status bar .
the left bar .
the right bar .
( FormElement form ) { Map < String , Element > controlsByName = new HashMap < String , Element > ( ) ; for ( Element control : form . elements ( ) ) { if ( " radio " . equals ( control . attr ( " type " ) ) && control . hasAttr ( " checked " ) ) { String name = control . attr ( " name " ) ; if ( controlsByName . containsKey ( name ) ) { controlsByName . get ( name ) . attr ( " checked " , false ) ; } controlsByName . put ( name , control ) ; } } }
the wait time .
for a T to be awaited .
the given command .
the classpath to the commandLine .
a new DateRangeType .
the introduction of the LoJiX Prolog .
( ) { }
a sentence .
the query .
a MultiTypeData .
a MultiTypeData from a byte array .
a MultiTypeData .
a MultiTypeData from a short .
the multi type data .
a multi type data .
a MultiTypeData object .
a MultiTypeData object .
a String to a MultiTypeData .
a MultiTypeData object .
a multi data type to an object .
the value of the given name .
up to the end of the array .
( int key ) { int start = offset ( key ) ; int end = offset ( key ) ; if ( start < end ) { throw new IllegalArgumentException ( ) ; } if ( end < start ) { throw new IllegalArgumentException ( ) ; } if ( end < start ) { throw new IllegalArgumentException ( ) ; } if ( start < end ) { throw new IllegalArgumentException ( ) ; } if ( end < start ) { throw new IllegalArgumentException ( ) ; } if ( start < end ) { throw new IllegalArgumentException ( ) ; } if ( end < start ) { throw new IllegalArgumentException ( ) ; } if ( start < end ) { throw new IllegalArgumentException ( ) ; } if ( end < start ) { throw new IllegalArgumentException ( ) ; } if ( start < end ) { throw new IllegalArgumentException ( ) ; } if ( end < start ) { throw new IllegalArgumentException ( ) ; } if ( start < end ) { throw new IllegalArgumentException (
a character into the database .
two paths .
parseOperators ( Term [ ] terms ) throws SourceCodeException { if ( terms . length == 0 ) { return null ; } if ( terms . length == 1 ) { return ( Functor ) outputStack . poll ( ) ; } if ( terms . length == 2 ) { return ( Functor ) outputStack . poll ( ) ; } if ( terms . length == 1 ) { return ( Functor ) outputStack . poll ( ) ; } if ( terms . length == 2 ) { return ( Functor ) outputStack . poll ( ) ; } if ( terms . length == 1 ) { return ( Functor ) outputStack . poll ( ) ; } if ( terms . length == 2 ) { return ( Functor ) outputStack . poll ( ) ; } return ( Functor ) outputStack . poll ( ) ; }
( String name ) { return operators . get ( name ) ; }
the required fixity for the given candidate .
a new search node .
the string to the padder .
a list of errors .
the options in force .
the usage of a given option .
trailing pairs to properties .
options to properties .
a new CommandLineOption .
free args as properties .
the format of the argument .
iterators .
< Option > listOptions ( ) { Vector < Option > result ; String desc ; SelectedTag tag ; int i ; result = new Vector < Option > ( ) ; desc = " " ; for ( i = 0 ; i < TAGS_STEMMERS . length ; i ++ ) { tag = new SelectedTag ( TAGS_STEMMERS [ i ] . getID ( ) , TAGS_STEMMERS ) ; desc += " \t " + tag . getSelectedTag ( ) . getIDStr ( ) + " = " + tag . getSelectedTag ( ) . getReadable ( ) + " \n " ; } return result ; }
a list of options .
the stemmer of the selected tag .
the actual stemmer .
the word stemmer .
the Stemmer to use the stemmer .
a new FloatRangeType .
the internal code address .
the env frame .
the choice frame .
an internal function .
the stack frame .
the data .
the given address .
( int a1 , int a2 ) { for ( int addr = a1 ; addr < a2 ; addr ++ ) { int tmp = data . get ( addr ) ; data . put ( tmp , refTo ( tmp ) ) ; } for ( int addr = a1 ; addr < a2 ; addr ++ ) { int tmp = data . get ( addr ) ; data . put ( tmp , refTo ( tmp ) ) ; } }
( int bp ) { int trp = data . get ( bp ) ; int hbp = data . get ( bp + 1 ) ; int hp = data . get ( bp + 2 ) ; while ( trp > 0 ) { int addr = data . get ( bp ) ; if ( ( addr < hbp ) || ( ( hp < addr ) && ( addr < bp ) ) ) { data . put ( i , data . get ( trp - 1 ) ) ; trp -- ; } else { data . put ( i , data . get ( trp - 1 ) ) ; trp -- ; } } }
( int a1 , int a2 ) { uPush ( a1 ) ; uPush ( a2 ) ; }
( int derefVal , int derefTag ) { if ( derefVal == derefTag ) { return true ; } if ( derefVal == derefTag ) { return false ; } if ( derefVal == derefTag ) { return true ; } if ( derefVal == derefTag ) { return false ; } if ( derefVal == derefTag ) { return true ; } if ( derefVal == derefTag ) { return true ; } if ( derefVal == derefTag ) { return true ; } if ( derefVal == derefTag ) { return true ; } if ( derefVal == derefTag ) { return true ; } if ( derefVal == derefTag ) { return true ; } if ( derefVal == derefTag ) { return true ; } if ( derefVal == derefTag ) { return true ; } if ( derefVal == derefTag ) { return true ; } if ( derefVal == derefTag ) { return true ; } if ( derefVal
( int xi , int mode ) { return ( ( mode == STACK_ADDR ) ? " Y " : " X " ) + ( ( mode == STACK_ADDR ) ? ( xi - ep - 3 ) : xi ) ; }
a new EightPuzzleState .
if the state is Solvable .
getChildStateForOperator ( Operator op ) { return getChildStateForOperator ( op . getOperator ( ) ) ; }
a list of valid operators .
out the board .
( int x , int y ) { int illegal = 0 ; int tileX = getXForTile ( t ) ; int tileY = getYForTile ( t ) ; if ( tileX != x ) { if ( swapTiles ( tileX , tileY , tileX - 1 , tileY ) ) { illegal ++ ; } tileX -- ; } if ( tileY != y ) { if ( swapTiles ( tileX , tileY , tileX - 1 , tileY ) ) { illegal ++ ; } tileY -- ; } if ( tileY != y ) { if ( swapTiles ( tileX , tileY , tileX + 1 , tileY ) ) { illegal ++ ; } tileY ++ ; } if ( tileY != y ) { if ( swapTiles ( tileX , tileY , tileX , tileY - 1 ) ) { illegal ++ ; } tileY -- ; } return illegal ; }
the tiles .
the board string to a list of characters .
a new EightPuzzleState .
the message to a log4j message .
log4j Level to log4j Level .
< E > record = new RequeueElementWrapper < E > ( element ) ; return record ; }
< E > requeue ( E element , Object owner ) { RequeueElementWrapper < E > record = new RequeueElementWrapper < E > ( element ) ; record . state = acquired ; record . owner = owner ; requeue . add ( record ) ; return record ; }
the size of the record .
( ) { if ( sizeable && ( record instanceof Sizeable ) ) { signalOnSizeThresholdCrossing ( ( Sizeable ) record ) ; } }
the size of the signalable .
a list of all the bindings .
all bindings of the given name .
a property to the environment .
the property from the environment .
( ) { long usedMem1 = usedMemory ( ) ; long usedMem2 = Long . MAX_VALUE ; for ( int i = 0 ; ( usedMem1 < usedMem2 ) && ( i < 500 ) ; i ++ ) { RUNTIME . runFinalization ( ) ; RUNTIME . gc ( ) ; usedMem2 = usedMem1 ; usedMem1 = usedMem2 ; } }
Literal ( ) { return Sequence ( FirstOf ( Color ( ) , MultiDimension ( ) , Dimension ( ) , String ( ) ) , push ( new SimpleNode ( match ( ) ) ) ) ; }
( String name ) { if ( ! isParserTranslationEnabled ( ) ) { return push ( new PlaceholderNode ( new SimpleNode ( name ) ) ) ; } }
( String name ) { if ( ! isParserTranslationEnabled ( ) ) { return push ( new VariableReferenceNode ( name ) ) ; } throw new UndefinedVariableException ( name ) ; }
the maximum row height .
maxColumnWidth ( int column ) { Integer previousValue = maxColumnSizes . get ( column ) ; if ( previousValue == null ) { maxColumnSizes . put ( column , width ) ; } else if ( previousValue < width ) { maxColumnSizes . put ( column , width ) ; } }
a paged list .
< O , T > makeNode ( Successor successor ) throws SearchNotExhaustiveException { return new HeuristicSearchNode < O , T > ( successor ) ; }
the given form .
( Term clause ) { TermWalker walk = TermWalkers . positionalWalker ( new BuiltInTransformVisitor ( interner , symbolTable , null , builtInTransform ) ) ; walk . walk ( clause ) ; }
symbol table .
the top level of the clause .
listToString ( VariableAndFunctorInterner interner , boolean isFirst , boolean printVarName , boolean printBindings ) { String result = " " ; if ( isFirst ) { result += " [ " ; } result += arguments [ 0 ] . toString ( interner , printVarName , printBindings ) ; if ( isFirst ) { result += " [ " ; } result += arguments [ 1 ] . toString ( interner , printVarName , printBindings ) ; }
true if the first number is greater than the second number .
the running state .
the application .
the application .
a new node into the queue .
log2 ( int n ) { if ( n >= ( 1 << b ) ) { return n ; } if ( n < ( 1 << b ) ) { return n ; } if ( n < ( 1 << b ) ) { return n ; } if ( n >= ( 1 << b ) ) { return n ; } if ( n >= ( 1 << b ) ) { return n ; } if ( n >= ( 1 << b ) ) { return n ; } if ( n >= ( 1 << b ) ) { return n ; } if ( n >= ( 1 << b ) ) { return n ; } if ( n >= ( 1 << b ) ) { return n ; } if ( n >= ( 1 << b ) ) { return n ; } if ( n >= ( 1 << b ) ) { return n ; } if ( n >= ( 1 << b ) ) { return n ; } return n ; }
the minimum node .
a node with another node .
a new node .
the cache .
< T > setOf ( SearchMethod < T > method ) { Set < T > result = new HashSet < T > ( ) ; findAll ( result , method ) ; return result ; }
the bag of a given search method .
all solutions for a given method .
the next item in the sequence .
the values of the given object .
the value of the given property .
< String , TypeConverter . MultiTypeData > put ( String property , TypeConverter . MultiTypeData value ) { values . put ( property , value ) ; return this ; }
void put ( Class cls , String property , Object value ) { values . put ( property , value ) ; }
the value of the given method .
( ) { if ( size ( ) == 0 ) { return null ; } return get ( 0 ) ; }
the modifiers .
a string to an integer .
toDate ( String s ) { DateFormat dateFormatter = new SimpleDateFormat ( dateFormat ) ; try { return dateFormatter . parse ( s ) ; } catch ( ParseException e ) { e = null ; return null ; } }
the date from the given string .
the time of the given string .
the date and time from the given string .
the token source for the given string .
the token source for the given file .
the token source for the given input .
whether a functor name is constant or not .
whether a variable is void .
if the function is non - arg .
the children of the traverser .
the argument of the given index .
traverse ( Operator < Term > [ ] arguments , boolean reverse ) { if ( ( traverser != null ) && ( traverser instanceof FunctorTraverser ) ) { return ( ( FunctorTraverser ) traverser ) . traverse ( this , reverse ) ; } else { if ( arguments == null ) { return new LinkedList < Operator < Term > > ( ) . iterator ( ) ; } else if ( reverse ) { return Arrays . asList ( ( Operator < Term > [ ] ) arguments ) . iterator ( ) ; } else { List < Operator < Term > > argList = new LinkedList < Operator < Term > > ( ) ; for ( int i = arity - 1 ; i >= 0 ; i -- ) { argList . add ( arguments [ i ] ) ; } return argList . iterator ( ) ; } } }
a string representation of the arguments .
the summary from the given schema .
records from the given schema .
SQL query .
( ByteBuffer codeBuffer , WAMMachine machine ) throws LinkageException { mnemonic . emmitCode ( this , codeBuffer , machine ) ; }
the basic type for the given class .
the input stream .
( Term var ) { return var . toString ( getInterner ( ) , true , false ) + " = " + var ; }
( Iterator < Set < Variable > > solutions ) { return new Filterator < Set < Variable > , Map < String , Variable > > ( solutions , new Function < Set < Variable > , Map < String , Variable > > ( ) { public Map < String , Variable > apply ( Set < Variable > variables ) { Map < String , Variable > results = new HashMap < String , Variable > ( ) ; for ( Variable var : variables ) { results . put ( var . getName ( ) , var ) ; } return results ; } } ) ; }
the stream .
a stream .
the current time .
( ) { if ( _currentMillis != System . currentTimeMillis ( ) ) { _currentMillis = System . currentTimeMillis ( ) ; _counter = 0 ; } }
( Playlist playlist ) { this . playlist = playlist ; }
Playlist info .
( List < T > data , EventModel eventModel ) { this . data = data ; this . eventModel = eventModel ; }
the start music request .
the event request .
music request .
a Smack Packet Reader .
a connection to the server .
the connection .
the parser .
a packet from the xmlstream .
the packet .
the cli option to the specified value .
Chat createChat ( String userJID , MessageListener listener ) { return createChat ( userJID , null , listener ) ; }
the content manager .
the content .
the content of the given key .
a new PacketFilter .
the request .
the store properties .
( final SmackConnection connection ) { this . connection = connection ; }
a packet to the server .
the next packet from the queue .
a stream .
< String > getAllInformations ( ) { ArrayList < String > strings = new ArrayList < > ( descriptors ) ; strings . add ( type ) ; return strings ; }
boolean containsDescriptor ( String descriptor ) { return descriptors . contains ( descriptor ) || type . equals ( descriptor ) ; }
a listener to the event life cycle .
the executor .
true if the content of the file1 and file2 is equal .
the MappedByteBuffer .
if the entry has been deleted .
static < T > T maskNull ( T key ) { return ( key == null ? ( T ) NULL_KEY : key ) ; }
true if x and y are equal .
< K , V > getEntry ( Object key ) { if ( key == null ) throw new NullPointerException ( ) ; int hash = hash ( key ) ; int i = indexFor ( hash , table . length ) ; Entry < K , V > e = table [ i ] ; while ( e != null && ! ( e . hash == hash && validEntry ( e ) && eq ( k , e . key ) ) ) e = e . next ; return e ; }
the table .
a new entry to the map .
remove ( Object key ) throws ConcurrentModificationException { Entry < K , V > e = removeEntryForKey ( key ) ; return ( e == null ? null : e . value ) ; }
the entry from the table .
the entry from the table .
a new entry .
< K , V > createDelegate ( final Map < K , V > base , final Set < ? extends K > keys , final Function < K , V > augmentation ) { final ImmutableMap . Builder < K , V > builder = ImmutableMap . builder ( ) ; keys . stream ( ) . filter ( key -> ! base . containsKey ( key ) ) . forEach ( key -> builder . put ( key , augmentation . apply ( key ) ) ) ; return builder . build ( ) ; }
the value to a binary string .
a hex string .
the base64 string .
Base64 encoded data .
( final FilterableCollection < ? extends T > c ) { checkUsed ( ) ; count = c . size ( ) ; return count ; }
the track selector controller .
( Consumer < Progress > controller ) { if ( controller == null ) return ; jumpProgress = controller ; }
changeable controller .
volume changeable controller .
all available Playlists .
command resources .
the volume of the event model .
the jump event .
the select track event .
the thread cache .
the request cache .
the field for the given streamId .
< K , V > getFilterMap ( Map < K , V > source , Map < K , V > modified , Set < K > include , Set < K > exclude , boolean includingRemoveProperties ) { if ( ( modified == null || modified . size ( ) == 0 ) && ( include == null || include . size ( ) == 0 ) && ( exclude == null || exclude . size ( ) == 0 ) ) { return ImmutableMap . copyOf ( source ) ; } if ( ( modified == null || modified . size ( ) == 0 ) && ( include == null || include . size ( ) == 0 ) && ( exclude == null || exclude . size ( ) == 0 ) ) { return ImmutableMap . copyOf ( source ) ; } ImmutableMap . Builder < K , V > filteredMap = ImmutableMap . Builder < K , V > ( ) ; for ( Entry < K , V > e : source . entrySet ( ) ) { K k = e . getKey ( ) ;
the shard path for the given id .
adaptToSession ( Object source ) { if ( source instanceof SessionAdaptable ) { return ( ( SessionAdaptable ) source ) . getSession ( ) ; } else { Object userManager = safeMethod ( source , " getUserManager " , new Object [ 0 ] , new Class [ 0 ] ) ; if ( userManager != null ) { return ( Session ) safeMethod ( userManager , " getSession " , new Object [ 0 ] , new Class [ 0 ] ) ; } return null ; } }
safeMethod ( Object target , String methodName , Object [ ] args , @ SuppressWarnings ( " rawtypes " ) Class [ ] argsTypes ) { if ( target != null ) { try { Method m = target . getClass ( ) . getMethod ( methodName , argsTypes ) ; if ( ! m . isAccessible ( ) ) { m . setAccessible ( true ) ; } return m . invoke ( target , args ) ; } catch ( Throwable e ) { LOGGER . info ( " Failed to invoke method " + methodName + " " + target , e ) ; } } return null ; }
the tree from the given path .
the object with the given properties .
the ping interval .
a periodic ping server task .
addAllOptions ( ApplicationOption < ? > [ ] options ) { if ( options != null ) { for ( ApplicationOption < ? > option : options ) { this . addOption ( option ) ; } } return this ; }
if a given option has been used .
the command line .
( String appName ) { HelpFormatter formatter = new HelpFormatter ( ) ; formatter . printHelp ( appName , null , this . options , null ) ; }
the command line .
a connection to the server .
TLS .
( ) { for ( XMPPInputOutputStream handler : compressionHandlers ) { if ( ! handler . isSupported ( ) ) continue ; String method = handler . getCompressionMethod ( ) ; if ( compressionMethods . contains ( method ) ) return handler ; } }
a stream compression method .
the stream compression .
that the connection is closed .
the connection .
( String name , Class < ? extends SASLMechanism > mClass ) { implementedMechanisms . put ( name , mClass ) ; }
.
the output plugin behaviour .
info ( String message ) { log ( System . out , " * INFO * " , message , t ) ; }
error ( String message ) { log ( System . err , " * ERROR * " , message ) ; }
the log message to the console .
a start event .
a start event .
the writer listeners .
true if the given resource does not exist .
boolean containsResourcesFromSource ( String sourceID ) { return resources . stream ( ) . map ( ResourceModel :: getResourceID ) . anyMatch ( source -> source . equals ( sourceID ) ) ; }
if a resource has been provided .
a list of resources for a given resourceID .
the cached data from the given keySpace .
the cache key for the given columnFamily .
cached marker from Cache .
the cached key into the cache .
the location of the given class .
a jar file .
a jar file .
( String mech ) { initialize ( ) ; if ( ! defaultMechs . contains ( mech ) ) { defaultMechs . add ( mech ) ; } }
( Collection < String > mechs ) { initialize ( ) ; for ( String mech : mechs ) { addSaslMech ( mech ) ; } }
a debug reader and writer .
a trustedLoginTokenProxyPostProcessor .
( ) { registerStandardEvents ( ) ; }
( EventListener eventListener ) { this . eventListener = eventListener ; }
a new eventID .
a lock for the channel .
the eventID .
public boolean canRun ( EventModel event ) { if ( event != null ) { return event . getListResourceContainer ( ) . providesResource ( getResourceIdWishList ( ) ) ; } return false ; }
a new DseSession .
a music player error .
music request .
music .
a player command .
a BroadcasterPlaylistRequest .
static BroadcasterPlaylist createPlaylistAnswer ( Identification provider , Playlist playlist ) { return new BroadcasterPlaylist ( provider , playlist . export ( ) ) ; }
a new URL to the given URL .
a query parameter .
the value of the query parameter .
UrlBuilder queryParam ( String name , String value ) { return queryParam ( name , value , true ) ; }
a new UrlBuilder with the given value .
a Playlist from the source .
Nakamura .
if the browser is running .
if the URL exists .
the browser .
a new ImageIcon from the given path .
( ) { }
a new IntArray with the given values .
the data .
a JSONResult .
a JSONResult .
the integer from the given value .
the value of the given number .
the string from the given value .
a command resource .
the command .
the capabilities of the given command .
the given command and capabilities .
( int maxSyncJobs ) { this . maxSyncJobs = maxSyncJobs ; }
all subclasses of a given class .
the subclasses of the given fqcn .
the Class < ? > for the given location .
the directory for the given class .
the jar for the given class .
< Resource > toList ( ) { List < Resource > resourceList = new ArrayList < > ( ) ; resourceList . add ( this ) ; return resourceList ; }
the size of the map .
( Packet packet ) { if ( packet != null ) { if ( packetFilter == null || packetFilter . accept ( packet ) ) { while ( ! resultQueue . offer ( packet ) ) { resultQueue . poll ( ) ; } } } }
a volume from a list of resources .
an error response .
a new error response .
static Optional < Boolean > isTarget ( EventModel eventModel , Identifiable identifiable ) { if ( eventModel . getListResourceContainer ( ) . providesResource ( Collections . singletonList ( SelectorResource . RESOURCE_ID ) ) ) { return Optional . of ( eventModel . getListResourceContainer ( ) . provideResource ( SelectorResource . RESOURCE_ID ) . stream ( ) . map ( ResourceModel :: getResource ) . filter ( resource -> resource instanceof Identification ) . findFirst ( ) ) ; } else if ( eventModel . getListResourceContainer ( ) . providesResource ( Collections . singletonList ( SelectorResource . RESOURCE_ID ) ) ) { return Optional . of ( eventModel . getListResourceContainer ( ) . provideResource ( SelectorResource . RESOURCE_ID ) . stream ( ) . map ( ResourceModel :: getResource ) . filter ( resource -> resource instanceof Identification ) . findFirst ( ) ) ; } else { return Optional . empty ( ) ; } }
( long from , long to , boolean day , TimeZone timeZone ) { String enabledSetting = EnabledPeriod . getEnableValue ( from , to , day , timeZone ) ; if ( enabledSetting == null ) { removeProperty ( LOGIN_ENABLED_PERIOD_FIELD ) ; } else { setProperty ( LOGIN_ENABLED_PERIOD_FIELD , enabledSetting ) ; } }
< E > decorate ( Set < E > set ) { return new SynchronizedSet < E > ( set ) ; }
the name of the user .
the state of the subscription .
the groups of the roster .
a set element to the query .
( Element queryElement ) { return new RSM ( ) ; }
a list of Identifiable objects .
a LeavingEvent .
the roster .
a new entry from the server .
all roster entries .
the presence of the user .
offline presence .
( Collection < String > addedEntries , Collection < String > updatedEntries , Collection < String > deletedEntries ) { for ( RosterListener listener : rosterListeners ) { if ( ! addedEntries . isEmpty ( ) ) { listener . entriesAdded ( addedEntries ) ; } if ( ! updatedEntries . isEmpty ( ) ) { listener . entriesUpdated ( updatedEntries ) ; } if ( ! deletedEntries . isEmpty ( ) ) { listener . entriesDeleted ( deletedEntries ) ; } } }
the digest for the given connectionID .
a music resource .
a player request .
< Long > getTimePassed ( EventModel eventModel ) { if ( eventModel . getListResourceContainer ( ) . containsResourcesFromSource ( ID ) ) { return Optional . of ( eventModel . getListResourceContainer ( ) . provideResource ( ID ) . stream ( ) . map ( ResourceModel :: getResource ) . filter ( ob -> ob instanceof Long ) . map ( ob -> ( Long ) ob ) . findAny ( ) ) ; } else { return Optional . empty ( ) ; } }
( Consumer < PropertiesAssistant > listener ) { if ( listener != null ) listeners . add ( new WeakReference < > ( listener ) ) ; }
a new Properties file .
the properties file .
( Element el ) throws IOException { if ( el . elements ( ) . size ( ) == 1 ) { return parseStreamError ( el . elements ( ) . get ( 0 ) ) ; } if ( el . elements ( ) . size ( ) == 2 ) { return parseStreamError ( el . elements ( ) . get ( 1 ) ) ; } return null ; }
( Element mechanismsEl ) throws Exception { List < Element > mechanisms = mechanismsEl . elements ( " mechanism " ) ; List < String > mechanismsStr = new LinkedList < String > ( ) ; for ( Element mechanismEl : mechanisms ) { mechanismsStr . add ( mechanismEl . getText ( ) ) ; } return mechanismsStr ; }
( Element compressionEl ) throws IOException { List < Element > methodsEls = compressionEl . elements ( " method " ) ; List < String > methodsStr = new LinkedList < String > ( ) ; for ( Element methodEl : methodsEls ) { methodsStr . add ( methodEl . getText ( ) ) ; } return methodsStr ; }
( String elementName , String namespace ) throws Exception { DefaultPacketExtension extension = new DefaultPacketExtension ( elementName , namespace ) ; if ( parser . isEmptyElementTag ( ) ) { extension . setValue ( elementName , " " ) ; } else { extension . setValue ( elementName , " " ) ; } }
a String to an object .
if the event model contains a StartMusicRequest .
( ResourceModel x ) { if ( x . getResourceID ( ) . equals ( ID ) ) return Optional . of ( PlaybackState . valueOf ( x . getPlaybackState ( ) ) ) ; }
the secret key from the subdomain .
boolean isMultipleAllowed ( String subdomain ) { Boolean allowed = allowMultiple . get ( subdomain ) ; return allowed != null && allowed ; }
the given key and value .
< K > keySet ( ) { if ( keySet == null ) { keySet = new ReferenceKeySet < K , V > ( this ) ; } return keySet ; }
< K , V > values ( ) { if ( values == null ) { values = new ReferenceValues < K , V > ( this ) ; } return values ; }
the given reference .
< K , V > getEntry ( ) { if ( key == null ) { return null ; } else { return super . getEntry ( key ) ; } }
the hash of the given key and value .
< K , V > createEntry ( int hashCode , K key , V value ) { return new HashEntry < K , V > ( this , ( ReferenceEntry < K , V > ) next , hashCode , key , value ) ; }
the presence indicator .
the presence of the Vague .
( ) { if ( mostVague . isPresent ( ) ) { mostVague . set ( mostVague . get ( ) ) ; } }
( Message message ) { message . setThread ( threadID ) ; for ( MessageListener listener : listeners ) { listener . processMessage ( this , message ) ; } }
a script for the given class .
the output directory .
properties from a file .
( String fn ) { try { FileWriter fs = new FileWriter ( fn ) ; BufferedWriter bw = new BufferedWriter ( fs ) ; bw . write ( st . render ( ) ) ; bw . close ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; return - 1 ; } return 0 ; }
the progress of the specified resource .
static < E > Collection < E > decorate ( Collection < E > coll ) { return new SynchronizedCollection < E > ( coll ) ; }
a list of all resolvers for a given host .
the config from the given url .
public org . intellimate . izou . sdk . specification . context . ThreadPool getThreadPool ( ) { return threadPool ; }
a StopMusic from a given Identification .
static boolean verify ( EventModel eventModel ) { if ( ! eventModel . containsDescriptor ( StopMusic . ID ) ) return false ; return SelectorResource . isTarget ( eventModel , player ) . orElse ( true ) ; }
( String hostsAndPorts , String username , String password ) { return getCluster ( ClusterIdentifier . getInstance ( hostsAndPorts , username , password ) ) ; }
a connection listener .
a packet listener .
a packet listener to the queue .
( Packet packet ) { for ( ListenerWrapper listenerWrapper : sendListeners . values ( ) ) { listenerWrapper . notifyListener ( packet ) ; } }
a packet interceptor .
( ) { if ( interceptors != null ) { for ( InterceptorWrapper interceptorWrapper : interceptors . values ( ) ) { interceptorWrapper . notifyListener ( packet ) ; } } }
the value to a string .
with the server .
the current thread id .
if a node has been deleted .
K getKeyForValue ( final Object value ) throws ClassCastException , NullPointerException { return ( K ) doGet ( value , VALUE ) ; }
the data for the specified index .
( final Object data , final int index ) { return nextEqualValid ( getFloorEqualNode ( lookup ( data , index ) , index ) , index , thread_id ) ; }
a node from the given data .
the two objects with the same status .
the least node from the given node .
the rightmost node .
if a node is greater than or equal to another node .
the most valid node .
the least valid Node < K , V > .
color ( final Node < K , V > from , final int index ) { if ( to != null ) { if ( from == null ) { to . setBlack ( index ) ; } else { to . copyColor ( from , index ) ; } } }
isRed ( final Node < K , V > node ) { return ( ( node == null ) ? false : node . isRed ( ) ) ; }
isBlack ( final Node < K , V > node ) { return ( ( node == null ) ? true : node . isBlack ( index ) ) ; }
the parent of the given node .
the parent of the node .
the right child .
the left child of the node .
the left child .
the left child .
a red black node .
( final Node < K , V > deletedNode ) { if ( deletedNode . getLeft ( index ) != null && deletedNode . getRight ( index ) != null ) { swapPosition ( deletedNode . getLeft ( index ) , deletedNode . getRight ( index ) ) ; } }
if the object is Comparable .
a new value into this Map .
boolean containsKey ( final Object key ) throws ClassCastException , NullPointerException { checkKey ( key ) ; return lookupValid ( key , KEY , getCurrentThreadId ( ) ) != null ; }
boolean containsValue ( final Object value ) { checkValue ( value ) ; return lookupValid ( value , VALUE , getCurrentThreadId ( ) ) != null ; }
( final Object key ) throws ClassCastException , NullPointerException { checkKey ( key ) ; return ( V ) doGet ( key , KEY ) ; }
( final Object key ) throws ConcurrentModificationException { checkKey ( key ) ; return ( V ) doRemove ( key , KEY ) ; }
the node .
< K > keySet ( ) { if ( setOfKeysByKey == null ) { setOfKeysByKey = new AbstractFilterableSet < K > ( ) { @ Override public Iterator < K > iterator ( ) { return new TransactionalBidiTreeMapIterator < K > ( KEY ) { @ Override protected K doGetNext ( ) { return ( K ) lastReturnedNode . getData ( KEY ) ; } } ; } @ Override public int size ( ) { return TransactionalBidiTreeMap . this . size ( ) ; } @ Override public boolean contains ( Object o ) { return containsKey ( o ) ; } @ Override public boolean remove ( Object o ) { int oldNodeCount = nodeCount ; TransactionalBidiTreeMap . this . remove ( o ) ; return nodeCount != oldNodeCount ; } @ Override public void clear ( ) { TransactionalBidiTreeMap . this . clear ( ) ; } } ; } return setOfKeysByKey ; }
all values from the BidiTreeMap .
< Entry < K , V > > allEntrySet ( ) { if ( setOfAllEntries == null ) { setOfAllEntries = new AbstractFilterableSet < Entry < K , V > > ( ) { @ Override public Iterator < Entry < K , V > > iterator ( ) { return new TransactionalBidiTreeMapIterator < Entry < K , V > > ( KEY ) { @ Override protected Entry < K , V > doGetNext ( ) { return lastReturnedNode ; } @ Override protected Node < K , V > getNextValidNode ( Node < K , V > node , String thread_id ) { return node ; } @ Override protected Node < K , V > getNextValidNode ( Node < K , V > node , String thread_id ) { return node ; } @ Override protected Node < K , V > getNextValidNode ( Node < K , V > node , String thread_id ) { return node ; } } ; }
all entries into a TransactionalBidiTreeMap .
expired entries from cache .
( ) { if ( lastAccessedList . getLast ( ) . object != null ) { if ( lastAccessedList . getLast ( ) . object . equals ( lastAccessedList . getLast ( ) . object ) ) { lastAccessedList . getLast ( ) . remove ( ) ; } } }
hostname and port .
a player request .
the default RosterStore .
the default RosterStore .
ranges for a given address .
the subnet address of the given subnet .
the data to the database .
a TrackInfo from a HashMap .
a class name to the set .
executeApplication ( Object svc ) { if ( svc != null && ( svc instanceof ExecS_Application ) ) { return ( ExecS_Application ) svc ; } return null ; }
the list of the classmap .
usage information .
execute ( String [ ] args ) { return new ExecS ( ) . execute ( args ) ; }
a mute event .
a mute event .
the schema of the given schema .
a line to a file .
whether the class is executable or not .
a new ApplicationOption < ? > to the list .
a list of GoodwillSchemaFields .
( final String name ) { return null ; }
the name of the package .
< C , V > mapContentToValues ( final ImmutableMap < K , V > base ) { final ImmutableMap . Builder < C , V > builder = ImmutableMap . builder ( ) ; for ( final Entry < K , V > entry : base . entrySet ( ) ) { builder . put ( this . key ( entry . getKey ( ) ) , entry . getValue ( ) ) ; } return builder . build ( ) ; }
a new EventListener .
a new IterativeState < T , R > .
over a FilterableCollection .
the current object .
the track info from the event model .
the data .
a resource .
the error image from the given string .
the image from the given URL .
the JSON result from the URL .
the Map < K , V > .
the Cartesian product result .
the thread .
to the pool .
a new EndedEvent .
the current track .
the playlist .
the playlist .
whether playback mode is REPEAT or SHUFFLE .
the data from the queue .
escapeForXML ( String string ) { if ( string == null ) { return null ; } return string . trim ( ) ; }
the response of the given challenge .
toJSON ( ) { final ByteArrayOutputStream out = new ByteArrayOutputStream ( ) ; mapper . writeValue ( out , this ) ; return out ; }
all output extensions .
event to the highest priority queue .
( ) { if ( queues != null ) { for ( QueueManager q : queues ) { q . getQueueDispatcher ( ) . join ( ) ; } } }
a property to the authorizable map .
the property .
a principal to the list of principals .
( String principal ) { if ( ! readOnly && principals . contains ( principal ) ) { principals . remove ( principal ) ; principalsModified = true ; } }
the root window .
a PresenceEvent .
the event .
static boolean isPermanent ( ResourceModel resourceModel ) { Object resource = resourceModel . getResource ( ) ; try { return ( Boolean ) resource ; } catch ( ClassCastException e ) { return false ; } }
the name of the RosterEntry .
boolean containsKey ( Object key ) { int hashCode = hash ( ( key == null ) ? NULL : key ) ; HashEntry entry = data [ hashIndex ( hashCode , data . length ) ] ; while ( entry != null ) { if ( entry . hashCode == hashCode && isEqualKey ( key , entry . getKey ( ) ) ) { return true ; } entry = entry . next ; } return false ; }
boolean containsValue ( Object value ) { if ( value == null ) { for ( int i = 0 , isize = data . length ; i < isize ; i ++ ) { HashEntry entry = data [ i ] ; while ( entry != null ) { if ( isEqualValue ( value , entry . getValue ( ) ) ) { return true ; } entry = entry . next ; } } } else { for ( int i = 0 , isize = data . length ; i < isize ; i ++ ) { HashEntry entry = data [ i ] ; while ( entry != null ) { if ( isEqualValue ( value , entry . getValue ( ) ) ) { return true ; } entry = entry . next ; } } } return false ; }
the value of the given key .
the data .
( Object key ) { int h = key . hashCode ( ) ; h ^= ( h >>> 14 ) ; h += ( h << 4 ) ; h ^= ( h >>> 10 ) ; return h ; }
boolean isEqual ( Object key1 , Object key2 ) { return ( key1 == key2 || ( ( key1 != null ) && key1 . equals ( key2 ) ) ) ; }
boolean isEqualValue ( Object value1 , Object value2 ) { return ( value1 == value2 || value1 . equals ( value2 ) ) ; }
the size of the array .
newCapacity ( int proposedCapacity ) { int newCapacity = 1 ; if ( proposedCapacity > MAXIMUM_CAPACITY ) { newCapacity = MAXIMUM_CAPACITY ; } else { while ( newCapacity < proposedCapacity ) { newCapacity <<= 1 ; } if ( newCapacity > MAXIMUM_CAPACITY ) { newCapacity = MAXIMUM_CAPACITY ; } } return newCapacity ; }
< Map . Entry < K , V > > entrySetIterator ( ) { if ( size ( ) == 0 ) { return EmptyIterator . INSTANCE ; } return new EntrySetIterator < K , V > ( this ) ; }
the data from the given key .
the content generator .
a new Context ( ) { }
( ) { if ( isReconnectionAllowed ( ) ) { for ( ConnectionListener listener : connection . connectionListeners ) { listener . reconnectionFailed ( exception ) ; } } }
in the specified seconds .
